{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Mosaico","text":"<p>Mosaico is a high-performance, open-source data platform engineered to bridge the critical gap between Robotics and Physical AI. </p> <p>Traditional robotic workflows often struggle with monolithic file formats like ROS bag, which are linear and difficult to search, index, or stream efficiently. Mosaico replaces these linear files with a structured, queryable archive powered by Rust and Python, designed specifically for the high-throughput demands of multi-modal sensor data.</p> <p>The platform adopts a strictly code-first approach. We believe engineers shouldn't have to learn a proprietary SQL-like sublanguage to move data around. Instead, Mosaico provides native Python SDK that allows you to query, upload, and manipulate data using the programming languages you already know and love.</p>"},{"location":"#streamlining-data-for-physical-ai","title":"Streamlining Data for Physical AI","text":"<p>The transition from classical robotics to Physical AI represents a fundamental shift in data requirements.</p> <p></p> <p>Classical Robotics operates in an event-driven world. Data is asynchronous, sparse, and stored in monolithic sequential files (like ROS bags). A Lidar might fire at 10Hz, an IMU at 100Hz, and a camera at 30Hz, all drifting relative to one another.</p> <p>Physical AI requires synchronous, dense, and tabular data. Models expect fixed-size tensors arriving at a constant frequency (e.g., a batch of state vectors at exactly 50Hz).</p> <p>Mosaico\u2019s ML module automates this tedious data plumbing. It ingests raw, unsynchronized data and transforms it on the fly into the aligned, flattened formats ready for model training, eliminating the need for massive intermediate CSV files.</p>"},{"location":"#core-concepts","title":"Core Concepts","text":"<p>To effectively use Mosaico, it is essential to understand the three pillars of its architecture: Ontology, Topic, and Sequence. These concepts transform raw binary streams into semantic, structured assets.</p>"},{"location":"#the-ontology","title":"The Ontology","text":"<p>The Ontology is the structural backbone of Mosaico.  It serves as a semantic representation of all data used within your application, whether that consists of simple sensor readings or the complex results of an algorithmic process.</p> <p>In Mosaico, all data is viewed through the lens of time series.  Even a single data point is treated as a singular case of a time series.  The ontology defines the shape of this data. It can represent base types (such as integers, floats, or strings) as well as complex structures (such as specific sensor arrays or processing results).</p> <p>This abstraction allows Mosaico to understand what your data is, rather than just storing it as raw bytes.  By using an ontology to inject and index data, you enable the platform to perform ad-hoc processing, such as custom compression or semantic indexing, tailored specifically to the type of data you have ingested.</p> <p>Mosaico provides a series of Ontology Models for all the main sensors and applications in robotics. These are specific data structures representing a single data type. For example, a GPS sensor might be modeled as follows:</p> <pre><code>class GPS:\n    latitude: float\n    longitude: float\n    altitude: float\n</code></pre> <p>An image classification algorithm can be represented with an ontology model like:</p> <pre><code>class SimpleImageClassification:\n    top_left_corner: mosaicolabs.Vector2d\n    bottom_right: mosaicolabs.Vector2d\n    label: str\n    confidence: float\n</code></pre> <p>Users can easily extend the platform by defining their own Ontology Models. </p>"},{"location":"#topics-and-sequences","title":"Topics and Sequences","text":"<p>Once you have an Ontology Model, you need a way to instantiate it and store actual data. This is where the Topic comes in.  A Topic is a concrete instance of a specific ontology model. It functions as a container for a particular time series holding that specific data model. There is a strict one-to-one relationship here: one Topic corresponds to exactly one Ontology Model. This relationship allows you to query specific topics within the platform based on their semantic structure.</p> <p>However, data rarely exists in isolation. Topics are usually part of a larger context. In Mosaico, this context is provided by the Sequence. A Sequence is a collection of logically related Topics.</p> <p>To visualize this, think of a ROS bag or a recording of a robot's run. The recording session itself is the Sequence. Inside that Sequence, you have readings from a Lidar sensor, a GPS unit, and an accelerometer. Each of those individual sensor streams is a Topic, and each Topic follows the structure defined by its Ontology Model. Both Topics and Sequences can hold metadata to further describe their contents.</p>"},{"location":"#architecture","title":"Architecture","text":"<p>Mosaico follows a client-server architecture where users interact with the platform through the Python SDK to query, read, and write data. The SDK communicates with the Mosaico daemon a.k.a. <code>mosaicod</code>, a high-performance server written in Rust, using Apache Arrow for efficient columnar data exchange without serialization overhead.</p> <p><code>mosaicod</code> daemon handles all core data operations including ingestion, retrieval, and query. It uses a database instance to accelerate metadata queries, manage system state, and implement an event queue for processing asynchronous tasks. Data files themselves are stored in an object store (such as S3, MinIO, or local filesystem) for durable, long-term persistence and scalability.</p> <p>This design enables Mosaico to efficiently manage complex multi-modal sensor data while providing a simple, code-first interface for developers.</p>"},{"location":"SDK/","title":"Mosaico SDK","text":"<p>The Mosaico SDK is a Python interface designed specifically for managing Physical AI and Robotics data. Its purpose is to handle the complete lifecycle of information, from the moment it is captured by a sensor to the moment it is used to train a neural network or analyze a robot's behavior.</p> <p>The SDK is built on the philosophy that robotics data is unique. Whether it comes from a autonomous car, a drone, or a factory arm, this data is multi-modal, highly frequent, and deeply interconnected in space and time. The Mosaico SDK provides the infrastructure to treat this data as a first-class citizen rather than just a collection of generic numbers. It understands the geometric and physical semantics of complex data types such as LIDAR point clouds, IMU readings, high-resolution camera feeds, and rigid-body transformations.</p>"},{"location":"SDK/#overview","title":"Overview","text":"<p>The SDK is built on the following core principles:</p>"},{"location":"SDK/#middleware-independence","title":"Middleware Independence","text":"<p>Mosaico is middleware-agnostic. While the SDK provides robust tools for ROS, it exists because robotics data itself is complex, regardless of the collection method. The platform serves as a standardized hub that can ingest data from:</p> <ul> <li>Existing Frameworks: Such as ROS 1, ROS 2, <code>.mcap</code> and <code>.db3</code> files.</li> <li>Custom Collectors: Proprietary data loggers or direct hardware drivers.</li> <li>Simulators: Synthetic data generated in virtual environments.</li> </ul>"},{"location":"SDK/#ontology","title":"Ontology","text":"<p>The Mosaico Data Ontology acts as the abstraction layer between your specific data collection system and your storage. Instead of saving \"Topic A from Robot B\" you save a <code>Pose</code>, an <code>IMU</code> reading, or an <code>Image</code>.  Once data is in the platform, its origin becomes secondary to its universal, semantic format. Moreover, the ontology is designed to be extensible with no effort, to meet the needs of any domain; the custom types are automatically validatable, serializable, and queryable alongside standard types.</p>"},{"location":"SDK/#high-performance","title":"High-Performance","text":"<p>Leveraging Apache Arrow for zero-copy performance, the SDK moves massive data volumes from the network to analysis tools without the CPU overhead of traditional data conversion. Every piece of data is time-synchronized, allowing the SDK to replay a session from dozens of sensors in the exact chronological order they occurred.</p>"},{"location":"SDK/#key-operations","title":"Key Operations","text":""},{"location":"SDK/#data-ingestion","title":"Data Ingestion","text":"<p>You can push data into Mosaico through two primary pathways, both designed to ensure your data is validated and standardized before storage:</p> <p>Native Ontology Ingestion. This approach allows you to stream data directly from your application, providing the highest level of control over serialization and real-time performance.</p> <p>Ecosystem Adapters &amp; Bridges. Use specialized adapters to translate data from existing middleware and log formats into Mosaico sequences. Mosaico currently supports ROS 1 bags (<code>.bag</code>) and more recent formats like <code>.mcap</code> and <code>.db3</code>.</p>"},{"location":"SDK/#data-retrieval","title":"Data Retrieval","text":"<p>Retrieving data goes beyond simple downloading. It is possible to stream and merge multiple topics into a single, time-ordered timeline, which is essential for sensor fusion.  Connect directly to a specific sensor, such as just the front-facing camera, to save bandwidth and memory.  The SDK fetches data in batches, allowing you to process datasets that are much larger than your computer's RAM.</p>"},{"location":"SDK/#querying-discovery","title":"Querying &amp; Discovery","text":"<p>Mosaico allows you to find data based on what happened, not just when it happened. You can search for specific sequences by metadata tags (like <code>robot_id</code> or <code>location</code>) or query the actual contents of the sensor data (e.g., \"Find all sequences where the vehicle acceleration exceeded 4 m/s^2\").</p>"},{"location":"SDK/#machine-learning-analytics","title":"Machine Learning &amp; Analytics","text":"<p>The ML Module transforms raw, sparse sensor streams into the tabular formats required by modern AI:</p> <ul> <li>Flattening: Converts nested sensor data into organized tables (e.g. <code>pandas.DataFrames</code>).</li> <li>Temporal Resampling: Aligns sensors running at different speeds (e.g., a 100Hz IMU and a 5Hz GPS) onto a uniform time grid with custom frame-rate for model training.</li> </ul>"},{"location":"SDK/client/","title":"Client","text":"<p>API Reference: <code>mosaicolabs.comm.MosaicoClient</code>.</p> <p>The <code>MosaicoClient</code> is a resource manager designed to orchestrate three distinct Layers of communication and processing.  This layered architecture ensures that high-throughput sensor data does not block critical control operations or application logic.</p>"},{"location":"SDK/client/#control-layer","title":"Control Layer","text":"<p>A single, dedicated connection is maintained for metadata operations.  This layer handles lightweight tasks such as creating sequences, querying the catalog, and managing schema definitions.  By isolating control traffic, the client ensures that critical commands (like <code>sequence_finalize</code>) are never queued behind heavy data transfers.</p>"},{"location":"SDK/client/#data-layer","title":"Data Layer","text":"<p>For high-bandwidth data ingestion (e.g., uploading 4x 1080p cameras simultaneously), the client maintains a Connection Pool of multiple Flight clients.  The SDK automatically stripes writes across these connections in a round-robin fashion, allowing the application to saturate the available network bandwidth.</p>"},{"location":"SDK/client/#processing-layer","title":"Processing Layer","text":"<p>Serialization of complex sensor data (like compressing images or encoding LIDAR point clouds) is CPU-intensive.  The SDK uses an Executor Pool of background threads to offload these tasks.  This ensures that while one thread is serializing the next batch of data, another thread is already transmitting the previous batch over the network.</p> <p>Best Practice: It is recomended to always use the client inside a <code>with</code> context to ensure resources in all layers are cleanly released.</p> <pre><code>from mosaicolabs import MosaicoClient\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Logic goes here\n    pass\n# Pools and connections are closed automatically\n</code></pre>"},{"location":"SDK/install/","title":"Setup","text":"<p>The SDK is currently available via source distribution. We use Poetry for robust dependency management and packaging.</p>"},{"location":"SDK/install/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python: Version 3.13 or newer is required.</li> <li>Poetry: For package management.</li> </ul>"},{"location":"SDK/install/#install-poetry","title":"Install Poetry","text":"<p>If you do not have Poetry installed, use the official installer:</p> <pre><code>curl -sSL https://install.python-poetry.org | python3 -\n</code></pre> <p>Ensure the poetry binary is in your path by verifying the version:</p> <pre><code>poetry --version\n</code></pre>"},{"location":"SDK/install/#install-sdk","title":"Install SDK","text":"<p>Clone the repository and navigate to the SDK directory:</p> <pre><code>cd mosaico/mosaico-sdk-py\n</code></pre> <p>Install the dependencies. This will automatically create a virtual environment and install all required libraries (PyArrow, NumPy, ROSBags, etc.):</p> <pre><code>poetry install\n</code></pre>"},{"location":"SDK/install/#activate-environment","title":"Activate Environment","text":"<p>You can spawn a shell within the configured virtual environment to work interactively:</p> <pre><code>eval $(poetry env activate)\n</code></pre> <p>Alternatively, you can run one-off commands without activating the shell:</p> <pre><code>poetry run python any_script.py\n</code></pre>"},{"location":"SDK/ontology/","title":"Data Models & Ontology","text":"<p>The Mosaico Data Ontology is the semantic backbone of the SDK.  It defines the structural \"rules\" that transform raw binary streams into meaningful physical data, such as GPS coordinates,  inertial measurements, or camera frames.</p> <p>By using a strongly-typed ontology, Mosaico ensures that your data remains consistent, validatable,  and highly optimized for both high-throughput transport and complex queries.</p>"},{"location":"SDK/ontology/#core-philosophy","title":"Core Philosophy","text":"<p>The ontology is designed to solve the \"generic data\" problem in robotics by ensuring every data object is:</p> <ol> <li>Validatable: Uses Pydantic for strict runtime type checking of sensor fields.</li> <li>Serializable: Automatically maps Python objects to efficient PyArrow schemas for high-speed binary transport.</li> <li>Queryable: Injects a fluent API (<code>.Q</code>) into every class, allowing you to filter databases based on physical values (e.g., <code>IMU.Q.acceleration.x &gt; 6.0</code>).</li> <li>Middleware-Agnostic: Acts as an abstraction layer so that your analysis code doesn't care if the data originally came from ROS, a simulator, or a custom logger.</li> </ol>"},{"location":"SDK/ontology/#available-ontology-classes","title":"Available Ontology Classes","text":"<p>The Mosaico SDK provides a comprehensive library of models that transform raw binary streams into validated, queryable Python objects. These are grouped by their physical and logical application below.</p>"},{"location":"SDK/ontology/#base-data-models","title":"Base Data Models","text":"<p>API Reference: Base Data Types</p> <p>These models serve as timestamped, metadata-aware wrappers for standard primitives. They allow simple diagnostic or scalar values to be treated as first-class members of the platform.</p> Module Classes Purpose Primitives <code>String</code>, <code>LargeString</code> UTF-8 text data for logs or status messages. Booleans <code>Boolean</code> Logic flags (True/False). Signed Integers <code>Integer8</code>, <code>Integer16</code>, <code>Integer32</code>, <code>Integer64</code> Signed whole numbers of varying bit-depth. Unsigned Integers <code>Unsigned8</code>, <code>Unsigned16</code>, <code>Unsigned32</code>, <code>Unsigned64</code> Non-negative integers for counters or IDs. Floating Point <code>Floating16</code>, <code>Floating32</code>, <code>Floating64</code> Real numbers for high-precision physical values."},{"location":"SDK/ontology/#geometry-kinematics-models","title":"Geometry &amp; Kinematics Models","text":"<p>API Reference: Geometry Models</p> <p>These structures define spatial relationships and the movement states of objects in 2D or 3D coordinate frames.</p> Module Classes Purpose Points &amp; Vectors <code>Vector2d/3d/4d</code>, <code>Point2d/3d</code> Fundamental spatial directions and locations. Rotations <code>Quaternion</code> Compact, singularity-free 3D orientation (). Spatial State <code>Pose</code>, <code>Transform</code> Absolute positions or relative coordinate frame shifts. Motion <code>Velocity</code>, <code>Acceleration</code> Linear and angular movement rates (Twists and Accels). Aggregated State <code>MotionState</code> An atomic snapshot combining Pose, Velocity, and Acceleration."},{"location":"SDK/ontology/#sensor-models","title":"Sensor Models","text":"<p>API Reference: Sensor Models</p> <p>High-level models representing physical hardware devices and their processed outputs.</p> Module Classes Purpose Inertial <code>IMU</code> 6-DOF inertial data: linear acceleration and angular velocity. Navigation <code>GPS</code>, <code>GPSStatus</code>, <code>NMEASentence</code> Geodetic fixes (WGS 84), signal quality, and raw NMEA strings. Vision <code>Image</code>, <code>CompressedImage</code>, <code>CameraInfo</code>, <code>ROI</code> Raw pixels, encoded streams (JPEG/H264), calibration, and regions of interest. Environment <code>Temperature</code>, <code>Pressure</code>, <code>Range</code> Thermal readings (K), pressure (Pa), and distance intervals (m). Dynamics <code>ForceTorque</code> 3D force and torque vectors for load sensing. Magnetic <code>Magnetometer</code> Magnetic field vectors measured in microTesla (). Robotics <code>RobotJoint</code> States (position, velocity, effort) for index-aligned actuator arrays."},{"location":"SDK/ontology/#architecture","title":"Architecture","text":"<p>The ontology architecture relies on three primary abstractions: the Factory (<code>Serializable</code>), the Envelope (<code>Message</code>) and the Mixins</p>"},{"location":"SDK/ontology/#1-serializable-the-factory","title":"1. <code>Serializable</code> (The Factory)","text":"<p>API Reference: <code>mosaicolabs.models.Serializable</code></p> <p>Every data payload in Mosaico inherits from the <code>Serializable</code> class. It manages the global registry of data types and ensures that the system knows exactly how to convert a string tag like <code>\"imu\"</code> back into a Python class with a specific binary schema. <code>Serializable</code> uses the <code>__init_subclass__</code> hook, which is automatically called whenever a developer defines a new subclass.</p> <p><pre><code>class MyCustomSensor(Serializable):  # &lt;--- __init_subclass__ triggers here\n    ...\n</code></pre> When this happens, <code>Serializable</code> performs the following steps automatically:</p> <ol> <li>Validates Schema: Checks if the subclass defined the PyArrow struct schema (<code>__msco_pyarrow_struct__</code>).  If missing, it raises an error at definition time (import time), preventing runtime failures later.</li> <li>Generates Tag: If the class doesn't define <code>__ontology_tag__</code>, it auto-generates one from the class name (e.g., <code>MyCustomSensor</code> -&gt; <code>\"my_custom_sensor\"</code>).</li> <li>Registers Class: It adds the new class to the global types registry.</li> <li>Injects Query Proxy: It dynamically adds a <code>.Q</code> attribute to the class, enabling the fluent query syntax (e.g., <code>MyCustomSensor.Q.voltage &gt; 12.0</code>).</li> </ol>"},{"location":"SDK/ontology/#2-message-the-envelope","title":"2. <code>Message</code> (The Envelope)","text":"<p>API Reference: <code>mosaicolabs.models.Message</code></p> <p>The <code>Message</code> class is the universal transport envelope for all data within the Mosaico platform.  It acts as a wrapper that combines specific sensor data (the payload) with middleware-level metadata.</p> <pre><code>from mosaicolabs import Message, Time, Header, Temperature\n# Use Case: Create a Temperature timestamped message with uncertainty\nmeas_time = Time.now()\ntemp_msg = Message(\n    timestamp_ns=meas_time.to_nanoseconds(), # here the message timestamp is the same as the measurement, but it can be different\n    data=Temperature.from_celsius(\n        value=57,\n        header=Header(stamp=meas_time, frame_id=\"comp_case\"),\n        variance=0.03\n    )\n)\n</code></pre> <p>While logically a <code>Message</code> contains a <code>data</code> object (e.g., an instance of an Ontology type), physically on the wire (PyArrow/Parquet), the fields are flattened.</p> <ul> <li>Logical: <code>Message(timestamp_ns=123567890, data=IMU(acceleration=Vector3d(x=1.0,...)))</code></li> <li>Physical: <code>Struct(timestamp_ns=123567890, acceleration, ...)</code></li> </ul> <p>This flattening is handled automatically by the class internal methods. This ensures zero-overhead access to nested data during queries while maintaining a clean object-oriented API in Python.</p>"},{"location":"SDK/ontology/#3-mixins-headers-uncertainty","title":"3. Mixins: Headers &amp; Uncertainty","text":"<p>Mosaico uses Mixins to inject standard fields across different data types, ensuring a consistent interface. Almost every class in the ontology, from high-level sensors down to elementary data primitives like <code>Vector3d</code> or <code>Float32</code>,  inherits from two Mixin classes, which inject standard fields into data models via composition, ensuring consistency across different sensor types. The integration of mixins into the Mosaico Data Ontology enables a flexible dual-usage pattern, Standalone Messages and Embedded Fields,  which will be detailed later and allow base geometric types to serve as either independent data streams or granular components of complex sensor models.</p>"},{"location":"SDK/ontology/#headermixin","title":"<code>HeaderMixin</code>","text":"<p>API Reference: <code>mosaicolabs.models.mixins.HeaderMixin</code></p> <p>Injects a standard (Optional) <code>header</code> containing a sequence ID, a frame ID (e.g., <code>\"base_link\"</code>), and a high-precision acquisition timestamp (<code>stamp</code>).</p> <pre><code>class MySensor(Serializable, HeaderMixin):\n    # Injects a header with stamp, frame_id, and seq fields\n    ...\n</code></pre>"},{"location":"SDK/ontology/#covariancemixin","title":"<code>CovarianceMixin</code>","text":"<p>API Reference: <code>mosaicolabs.models.mixins.CovarianceMixin</code></p> <p>Injects multidimensional uncertainty fields, typically used for flattened covariance matrices in sensor fusion applications.</p> <pre><code>class MySensor(Serializable, CovarianceMixin):\n    # Injects a covariance matrix with covariance and covariance_type fields\n    ...\n</code></pre>"},{"location":"SDK/ontology/#variancemixin","title":"<code>VarianceMixin</code>","text":"<p>API Reference: <code>mosaicolabs.models.mixins.VarianceMixin</code></p> <p>Injects monodimensional uncertainty fields, useful for sensors with 1-dimensional uncertain data (like <code>Temperature</code> or <code>Pressure</code>).</p> <pre><code>class MySensor(Serializable, VarianceMixin):\n    # Injects a variance with variance and variance_type fields\n    ...\n</code></pre>"},{"location":"SDK/ontology/#standalone-usage","title":"Standalone Usage","text":"<p>Because elementary types (such as <code>Vector3d</code>, <code>String</code>, or <code>Float32</code>) inherit directly from these mixins, they are \"first-class\" members of the ontology.  You can treat them as independent, timestamped messages without needing to wrap them in a more complex container.</p> <p>This is ideal for pushing processed signals, debug values, or simple sensor readings that require their own metadata and uncertainty context.</p> <pre><code># Use Case: Sending a raw 3D vector as a timestamped message with uncertainty\naccel_msg = Vector3d(\n    x=0.0, \n    y=0.0, \n    z=9.81,\n    header=Header(stamp=Time.now(), frame_id=\"base_link\"),\n    covariance=[0.01, 0, 0, 0, 0.01, 0, 0, 0, 0.01]  # 3x3 Diagonal matrix\n)\n\n# `acc_writer` is a TopicWriter associated to the new sequence that is being uploaded.\nacc_writer.push(message=Message(timestamp_ns=ts, data=accel_msg)) # (1)!\n\n# Use Case: Sending a timestamped diagnostic error\nerror_msg = String(\n    data=\"Waypoint-miss in navigation detected!\",\n    header=Header(stamp=Time.now(), frame_id=\"base_link\")\n)\n\n# `log_writer` is another TopicWriter associated to the new sequence that is being uploaded.\nlog_writer.push(message=Message(timestamp_ns=ts, data=error_msg))\n</code></pre> <ol> <li>The <code>push</code> command will be covered in the documentation of the Writers     API Reference:<ul> <li><code>mosaicolabs.handlers.SequenceWriter</code></li> <li><code>mosaicolabs.handlers.TopicWriter</code></li> </ul> </li> </ol>"},{"location":"SDK/ontology/#embedded-usage","title":"Embedded Usage","text":"<p>When these base types are used as internal fields within a larger structure (e.g., an <code>IMU</code> or <code>MotionState</code> model), the mixins allow you to attach metadata to specific parts of a message.</p> <p>In this context, while the parent object (the <code>IMU</code>) carries a global timestamp, the individual fields (like <code>acceleration</code>) can carry their own specific covariance matrices. To avoid data redundancy, the internal <code>header</code> of the embedded field is typically left as <code>None</code>, as it inherits the temporal context from the parent message.</p> <pre><code># Use Case: Embedding Vector3d inside a complex IMU message\nimu_msg = IMU(\n    # Parent Header: Defines the time and frame for the entire sensor packet\n    header=Header(stamp=Time.now(), frame_id=\"imu_link\"),\n\n    # Embedded Field 1: Acceleration\n    # Inherits global time, but specifies its own unique uncertainty\n    acceleration=Vector3d(\n        x=0.5, y=-0.2, z=9.8,\n        covariance=[0.1, 0, 0, 0, 0.1, 0, 0, 0, 0.1] # Specific to acceleration\n    ),\n\n    # Embedded Field 2: Angular Velocity\n    # Carries a distinct covariance matrix independent of the acceleration\n    angular_velocity=Vector3d(\n        x=0.01, y=0.0, z=-0.01,\n        covariance=[0.05, 0, 0, 0, 0.05, 0, 0, 0, 0.05] # Specific to velocity\n    )\n)\n\n# as above, `imu_writer` is another TopicWriter associated to the new sequence that is being uploaded.\nimu_writer.push(imu_msg)\n</code></pre>"},{"location":"SDK/ontology/#querying-data-ontology-with-the-query-q-proxy","title":"Querying Data Ontology with the Query (<code>.Q</code>) Proxy","text":"<p>The Mosaico SDK allows you to perform deep discovery directly on the physical content of your sensor streams. Every class inheriting from <code>Serializable</code>, including standard sensors, geometric primitives, and custom user models, is automatically injected with a static <code>.Q</code> proxy attribute.</p> <p>This proxy acts as a type-safe bridge between your Python data models and the platform's search engine, enabling you to construct complex filters using standard Python dot notation.</p>"},{"location":"SDK/ontology/#how-the-proxy-works","title":"How the Proxy Works","text":"<p>The <code>.Q</code> proxy recursively inspects the model\u2019s schema to expose every queryable field path. It identifies the data type of each field and provides only the operators valid for that type (e.g., numeric comparisons for acceleration, substring matches for frame IDs).</p> <ul> <li>Direct Field Access: Filter based on primary values, such as <code>Temperature.Q.value.gt(25.0)</code>.</li> <li>Nested Navigation: Traverse complex, embedded structures. For example, in the <code>GPS</code> model, you can drill down into the status sub-field: <code>GPS.Q.status.satellites.geq(8)</code>.</li> <li>Mixin Integration: Fields inherited from mixins are automatically included in the proxy. This allows you to query standard metadata (from <code>HeaderMixin</code>) or uncertainty metrics (from <code>VarianceMixin</code> or <code>CovarianceMixin</code>) across any model.</li> </ul>"},{"location":"SDK/ontology/#queryability-examples","title":"Queryability Examples","text":"<p>The following table illustrates how the proxy flattens complex hierarchies into queryable paths:</p> Type Field Path Proxy Field Path Source Type Queryable Type Supported Operators <code>IMU.acceleration.x</code> <code>IMU.Q.acceleration.x</code> <code>float</code> Numeric <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>GPS.status.hdop</code> <code>GPS.Q.status.hdop</code> <code>float</code> Numeric <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>IMU.header.frame_id</code> <code>IMU.Q.header.frame_id</code> <code>str</code> String <code>.eq()</code>, <code>.neq()</code>, <code>.match()</code>, <code>.in_()</code> <code>GPS.covariance_type</code> <code>GPS.Q.covariance_type</code> <code>int</code> Numeric <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code>"},{"location":"SDK/ontology/#practical-usage","title":"Practical Usage","text":"<p>To execute these filters, pass the expressions generated by the proxy to the <code>QueryOntologyCatalog</code> builder.</p> <pre><code>from mosaicolabs import MosaicoClient, IMU, GPS, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # orchestrate a query filtering by physical thresholds AND metadata\n    qresponse = client.query(\n        QueryOntologyCatalog(include_timestamp_range=True) # Ask for the start/end timestamps of occurrences\n        .with_expression(IMU.Q.acceleration.z.gt(15.0))\n        .with_expression(GPS.Q.status.service.eq(2))\n    )\n\n    # The server returns a QueryResponse grouped by Sequence for structured data management\n    if qresponse is not None:\n        for item in qresponse:\n            # 'item.sequence' contains the name for the matched sequence\n            print(f\"Sequence: {item.sequence.name}\") \n\n            # 'item.topics' contains only the topics and time-segments \n            # that satisfied the QueryOntologyCatalog criteria\n            for topic in item.topics:\n                # Access high-precision timestamps for the data segments found\n                start, end = topic.timestamp_range.start, topic.timestamp_range.end\n                print(f\"  Topic: {topic.name} | Match Window: {start} to {end}\")\n</code></pre> <p>For a comprehensive list of all supported operators and advanced filtering strategies (such as query chaining), see the Full Query Documentation and the Ontology types SDK Reference in the API Reference:</p> <ul> <li>Base Data Models</li> <li>Sensors Models</li> <li>Geometry Models</li> <li>Platform Models</li> </ul>"},{"location":"SDK/ontology/#customizing-the-ontology","title":"Customizing the Ontology","text":"<p>The Mosaico SDK is built for extensibility, allowing you to define domain-specific data structures that can be registered to the platform and live alongside standard types. Custom types are automatically validatable, serializable, and queryable once registered in the platform.</p> <p>Follow these three steps to implement a compatible custom data type:</p>"},{"location":"SDK/ontology/#1-inheritance-and-mixins","title":"1. Inheritance and Mixins","text":"<p>Your custom class must inherit from <code>Serializable</code> to enable auto-registration, factory creation, and the queryability of the model.  To align with the Mosaico ecosystem, use the following mixins:</p> <ul> <li><code>HeaderMixin</code>: Required for timestamped data or sensor readings. It injects a standard <code>header</code> (stamp, frame_id, seq), ensuring your data remains compatible with time-synchronization and coordinate frame logic.</li> <li><code>CovarianceMixin</code>: Used for data including measurement uncertainty, standardizing the storage of covariance matrices.</li> </ul>"},{"location":"SDK/ontology/#2-define-the-wire-schema-__msco_pyarrow_struct__","title":"2. Define the Wire Schema (<code>__msco_pyarrow_struct__</code>)","text":"<p>You must define a class-level <code>__msco_pyarrow_struct__</code> using <code>pyarrow.struct</code>. This explicitly dictates how your Python object is serialized into high-performance Apache Arrow/Parquet buffers for network transmission and storage.</p>"},{"location":"SDK/ontology/#21-serialization-format-optimization","title":"2.1 Serialization Format Optimization","text":"<p>API Reference: <code>mosaicolabs.enum.SerializationFormat</code></p> <p>You can optimize remote server performance by overriding the <code>__serialization_format__</code> attribute. This controls how the server compresses and organizes your data.</p> Format Identifier Use Case Recommendation Default <code>\"default\"</code> Standard Table: Fixed-width data with a constant number of fields. Ragged <code>\"ragged\"</code> Variable Length: Best for lists, sequences, or point clouds. Image <code>\"image\"</code> Blobs: Raw or compressed images requiring specialized codec handling. <p>If not explicitly set, the system defaults to <code>Default</code> format.</p>"},{"location":"SDK/ontology/#3-define-class-fields","title":"3. Define Class Fields","text":"<p>Define the Python attributes for your class using standard type hints.  Note that the names of your Python class fields must match exactly the field names defined in your <code>__msco_pyarrow_struct__</code> schema.</p>"},{"location":"SDK/ontology/#customization-example-environmentsensor","title":"Customization Example: <code>EnvironmentSensor</code>","text":"<p>This example demonstrates a custom sensor for environmental monitoring that tracks temperature, humidity, and pressure.</p> <pre><code># file: custom_ontology.py\n\nfrom typing import Optional\nimport pyarrow as pa\nfrom mosaicolabs.models import Serializable, HeaderMixin\n\nclass EnvironmentSensor(Serializable, HeaderMixin):\n    \"\"\"\n    Custom sensor reading for Temperature, Humidity, and Pressure.\n    \"\"\"\n\n    # --- 1. Define the Wire Schema (PyArrow Layout) ---\n    __msco_pyarrow_struct__ = pa.struct(\n        [\n            pa.field(\"temperature\", pa.float32(), nullable=False),\n            pa.field(\"humidity\", pa.float32(), nullable=True),\n            pa.field(\"pressure\", pa.float32(), nullable=True),\n        ]\n    )\n\n    # --- 2. Define Python Fields (Must match schema exactly) ---\n    temperature: float\n    humidity: Optional[float] = None\n    pressure: Optional[float] = None\n\n\n# --- Usage Example ---\nfrom mosaicolabs.models import Message, Header, Time\n\n# Initialize with standard metadata\nmeas = EnvironmentSensor(\n    header=Header(stamp=Time.now(), frame_id=\"lab_sensor_1\"),\n    temperature=23.5,\n    humidity=0.45\n)\n\n# Ready for streaming or querying\n# writer.push(Message(timestamp_ns=ts, data=meas))\n</code></pre> Schema for defining a custom ontology model."},{"location":"SDK/query/","title":"Querying Catalogs","text":"<p>The Query Module provides a high-performance, fluent interface for discovering and filtering data within the Mosaico Data Platform. It is designed to move beyond simple keyword searches, allowing you to perform deep, semantic queries across metadata, system catalogs, and the physical content of sensor streams.</p> <p>A typical query workflow involves chaining methods within specialized builders to create a unified request that the server executes atomically. In the example below, the code orchestrates a multi-domain search to isolate high-interest data segments. Specifically, it queries for:</p> <ul> <li>Sequence Discovery: Finds any recording session whose name contains the string <code>\"test_drive\"</code> AND where the custom user metadata indicates an <code>\"environment.visibility\"</code> value strictly less than 50.</li> <li>Topic Filtering: Restricts the search specifically to the data channel named <code>\"/front/camera/image\"</code>.</li> <li>Ontology Analysis: Performs a deep inspection of IMU sensor payloads to identify specific time segments where the X-axis acceleration exceeds a certain threshold while simultaneously the Y-axis acceleration exceeds a certain threshold.</li> </ul> <pre><code>from mosaicolabs import QueryOntologyCatalog, QuerySequence, QueryTopic, IMU, MosaicoClient\n\n# Establish a connection to the Mosaico Data Platform\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Perform a unified server-side query across multiple domains:\n    qresponse = client.query(\n        # Filter Sequence-level metadata\n        QuerySequence()\n        .with_name_match(\"test_drive\")  # Use convenience method for fuzzy name matching\n        .with_expression(               # Use the .Q proxy to filter the `user_metadata` field\n            Sequence.Q.user_metadata[\"environment.visibility\"].lt(50)\n        ),\n        # Search on topics with specific names\n        QueryTopic()\n        .with_name(\"/front/camera/image\"),\n        # Perform deep time-series discovery within sensor payloads\n        QueryOntologyCatalog(include_timestamp_range=True) # Request temporal bounds for matches\n        .with_expression(IMU.Q.acceleration.x.gt(5.0))     # Use the .Q proxy to filter the `acceleration` field\n        .with_expression(IMU.Q.acceleration.y.gt(4.0)),\n    )\n\n    # The server returns a QueryResponse grouped by Sequence for structured data management\n    if qresponse is not None:\n        for item in qresponse:\n            # 'item.sequence' contains the name for the matched sequence\n            print(f\"Sequence: {item.sequence.name}\") \n\n            # 'item.topics' contains only the topics and time-segments \n            # that satisfied the QueryOntologyCatalog criteria\n            for topic in item.topics:\n                # Access high-precision timestamps for the data segments found\n                start, end = topic.timestamp_range.start, topic.timestamp_range.end\n                print(f\"  Topic: {topic.name} | Match Window: {start} to {end}\")\n</code></pre> <p>The provided example illustrates the core architecture of the Mosaico Query DSL. To effectively use this module, it is important to understand the two primary mechanisms that drive data discovery:</p> <ul> <li>Query Builders (Fluent Logic Collectors): Specialized builders like <code>QuerySequence</code>, <code>QueryTopic</code>, and <code>QueryOntologyCatalog</code> serve as containers for your search criteria. They provide a Fluent Interface where you can chain two types of methods:<ul> <li>Convenience Methods: High-level helpers for common fields, such as <code>with_name()</code>, <code>with_name_match()</code>, or <code>with_created_timestamp()</code>.</li> <li>Generic <code>with_expression()</code>: A versatile method that accepts any expression obtained via the <code>.Q</code> proxy, allowing you to define complex filters for nested user metadata or deep sensor payloads.</li> </ul> </li> <li>The <code>.Q</code> Proxy (Dynamic Model Inspection): Every <code>Serializable</code> model in the Mosaico ontology features a static <code>.Q</code> attribute. This proxy dynamically inspects the model's underlying schema to build dot-notated field paths and intercepts attribute access (e.g., <code>IMU.Q.acceleration.x</code>). When a terminal method is called\u2014such as <code>.gt()</code>, <code>.lt()</code>, or <code>.between()</code>\u2014it generates a type-safe Atomic Expression used by the platform to filter physical sensor data or metadata fields.</li> </ul> <p>By combining these mechanisms, the Query Module delivers a robust filtering experience:</p> <ul> <li>Multi-Domain Orchestration: Execute searches across Sequence metadata, Topic configurations, and raw Ontology sensor data in a single, atomic request.</li> <li>Structured Response Management: Results are returned in a <code>QueryResponse</code> that is automatically grouped by <code>Sequence</code>, making it easier to manage multi-sensor datasets.</li> </ul>"},{"location":"SDK/query/#query-execution-the-response-model","title":"Query Execution &amp; The Response Model","text":"<p>Queries are executed via the <code>query()</code> method exposed by the <code>MosaicoClient</code> class. When multiple builders are provided, they are combined with a logical AND.</p> Method Return Description <code>query(*queries, query)</code> <code>Optional[QueryResponse]</code> Executes one or more queries against the platform catalogs. The provided queries are joined in AND condition. The method accepts a variable arguments of query builder objects or a pre-constructed <code>Query</code> object. <p>The query execution returns a <code>QueryResponse</code> object, which behaves like a standard Python list containing <code>QueryResponseItem</code> objects.</p> Class Description <code>QueryResponseItem</code> Groups all matches belonging to the same Sequence. Contains a <code>QueryResponseItemSequence</code> and a list of related <code>QueryResponseItemTopic</code>. <code>QueryResponseItemSequence</code> Represents a specific Sequence where matches were found. It includes the sequence name. <code>QueryResponseItemTopic</code> Represents a specific Topic where matches were found. It includes the normalized topic path and the optional <code>timestamp_range</code> (the first and last occurrence of the condition). <pre><code>import sys\nfrom mosaicolabs import MosaicoClient, QueryOntologyCatalog\nfrom mosaicolabs.models.sensors import IMU\n\n# Establish a connection to the Mosaico Data Platform\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n\n    # Define a Deep Data Filter using the .Q Query Proxy\n    # We are searching for vertical impact events where acceleration.z &gt; 15.0 m/s^2\n    impact_qbuilder = QueryOntologyCatalog(\n        IMU.Q.acceleration.z.gt(15.0),\n        # include_timestamp_range returns the precise start/end of the matching event\n        include_timestamp_range=True\n    )\n\n    # Execute the query via the client\n    results = client.query(impact_qbuilder)\n    # The same can be obtained by using the Query object\n    # results = client.query(\n    #     query = Query(\n    #         impact_qbuilder\n    #     )\n    # )\n\n    if results is not None:\n        # Parse the structured QueryResponse object\n        # Results are automatically grouped by Sequence for easier data management\n        for item in results:\n            print(f\"Sequence: {item.sequence.name}\")\n\n            # Iterate through matching topics within the sequence\n            for topic in item.topics:\n                # Topic names are normalized (sequence prefix is stripped) for direct use\n                print(f\"  - Match in: {topic.name}\")\n\n                # Extract the temporal bounds of the event\n                if topic.timestamp_range:\n                    start = topic.timestamp_range.start\n                    end = topic.timestamp_range.end\n                    print(f\"    Occurrence: {start} ns to {end} ns\")\n</code></pre> <ul> <li>Temporal Windows: The <code>timestamp_range</code> provides the first and last occurrence of the queried condition within a topic, allowing you to slice data accurately for further analysis.</li> <li>Result Normalization: <code>topic.name</code> returns the relative topic path (e.g., <code>/sensors/imu</code>), making it immediately compatible with other SDK methods like <code>topic_handler()</code>.</li> </ul>"},{"location":"SDK/query/#restricted-queries-chaining","title":"Restricted Queries (Chaining)","text":"<p>The <code>QueryResponse</code> class enables a powerful mechanism for iterative search refinement by allowing you to convert your current results back into a new query builder. This approach is essential for resolving complex, multi-modal dependencies where a single monolithic query would be logically ambiguous, inefficient or technically impossible.</p> Method Return Type Description <code>to_query_sequence()</code> <code>QuerySequence</code> Returns a query builder pre-filtered to include only the sequences present in the response. <code>to_query_topic()</code> <code>QueryTopic</code> Returns a query builder pre-filtered to include only the specific topics identified in the response. <p>When you invoke these factory methods, the SDK generates a new query expression containing an explicit <code>$in</code> filter populated with the identifiers held in the current response. This effectively \"locks\" the search domain, allowing you to apply new criteria to a restricted subset of your data without re-scanning the entire platform catalog.</p> <pre><code>from mosaicolabs import MosaicoClient, QueryTopic, QueryOntologyCatalog, GPS, String\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Broad Search: Find all sequences where a GPS sensor reached a high-precision state (status=2)\n    initial_response = client.query(\n        QueryOntologyCatalog(GPS.Q.status.status.eq(2))\n    )\n    # 'initial_response' now acts as a filtered container of matching sequences.\n\n    # Domain Locking: Restrict the search scope to the results of the initial query\n    if not initial_response.is_empty():\n        # .to_query_sequence() generates a QuerySequence pre-filled with the matching sequence names.\n        refined_query_builder = initial_response.to_query_sequence()\n\n        # Targeted Refinement: Search for error patterns ONLY within the restricted domain\n        # This ensures the platform only scans for '[ERR]' strings within sequences already validated for GPS precision.\n        final_response = client.query(\n            refined_query_builder,                                         # The \"locked\" sequence domain\n            QueryTopic().with_name(\"/localization/log_string\"),    # Target a specific log topic\n            QueryOntologyCatalog(String.Q.data.match(\"[ERR]\"))     # Filter by exact data content pattern\n        )\n</code></pre> <p>When a specific set of topics has been identified through a data-driven query (e.g., finding every camera topic that recorded a specific event), you can use <code>to_query_topic()</code> to \"lock\" your next search to those specific data channels. This is particularly useful when you need to verify a condition on a very specific subset of sensors across many sequences, bypassing the need to re-identify those topics in the next step.</p> <p>In the next example, we first find all topics of a specific channel from a specific sequence name pattern, and then search specifically within those topics for any instances where the data content matches a specific pattern.</p> <pre><code>from mosaicolabs import MosaicoClient, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Broad Search: Find sequences with high-precision GPS\n    initial_response = client.query(\n            QueryTopic().with_name(\"/localization/log_string\"), # Target a specific log topic\n            QuerySequence().with_name_match(\"test_winter_2025_\")  # Filter by sequence name pattern\n        )\n\n    # Chaining: Use results to \"lock\" the domain and find specific log-patterns in those sequences\n    if not initial_response.is_empty():\n        final_response = client.query(\n            initial_response.to_query_topic(),              # The \"locked\" topic domain\n            QueryOntologyCatalog(String.Q.data.match(\"[ERR]\"))  # Filter by content\n        )\n</code></pre>"},{"location":"SDK/query/#when-chaining-is-necessary","title":"When Chaining is Necessary","text":"<p>The previous example of the <code>GPS.status</code> query and the subsequent <code>/localization/log_string</code> topic search highlight exactly when query chaining becomes a technical necessity rather than just a recommendation. In the Mosaico Data Platform, a single <code>client.query()</code> call applies a logical AND across all provided builders to locate individual data streams (topics) that satisfy every condition simultaneously. Because a single topic cannot physically represent two different sensor types at once, such as being both a <code>GPS</code> sensor and a <code>String</code> log, a monolithic query attempting to filter for both on the same stream will inherently return zero results. Chaining resolves this by allowing you to find the correct Sequence context in step one, then \"locking\" that domain to find a different Topic within that same context in step two.</p> <pre><code># AMBIGUOUS: This looks for ONE topic that is BOTH GPS and String\nresponse = client.query(\n    QueryOntologyCatalog(GPS.Q.status.status.eq(DGPS_FIX)),\n    QueryOntologyCatalog(String.Q.data.match(\"[ERR]\")),\n    QueryTopic().with_name(\"/localization/log_string\")\n)\n</code></pre>"},{"location":"SDK/query/#architecture","title":"Architecture","text":""},{"location":"SDK/query/#query-layers","title":"Query Layers","text":"<p>Mosaico organizes data into three distinct architectural layers, each with its own specialized Query Builder:</p>"},{"location":"SDK/query/#querysequence-sequence-layer","title":"<code>QuerySequence</code> (Sequence Layer)","text":"<p>API Reference: <code>mosaicolabs.models.query.builders.QuerySequence</code>.</p> <p>Filters recordings based on high-level session metadata, such as the sequence name or the time it was created.</p> <p>Example Querying for sequences by name and creation date</p> <pre><code>from mosaicolabs import MosaicoClient, Topic, QuerySequence\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Search for sequences by project name and creation date\n    qresponse = client.query(\n        QuerySequence()\n        .with_name_match(\"test_drive\")\n        .with_expression(Sequence.Q.user_metadata[\"project\"].eq(\"Apollo\"))\n        .with_created_timestamp(time_start=Time.from_float(1690000000.0))\n    )\n\n    # Inspect the response\n    for item in qresponse:\n        print(f\"Sequence: {item.sequence.name}\")\n        print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/query/#querytopic-topic-layer","title":"<code>QueryTopic</code> (Topic Layer)","text":"<p>API Reference: <code>mosaicolabs.models.query.builders.QueryTopic</code>.</p> <p>Targets specific data channels within a sequence. You can search for topics by name pattern or by their specific Ontology type (e.g., \"Find all GPS topics\").</p> <p>Example Querying for image topics by ontology tag, metadata key and topic creation timestamp</p> <pre><code>from mosaicolabs import MosaicoClient, Image, Topic, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Query for all 'image' topics created in a specific timeframe, matching some metadata (key, value) pair\n    qresponse = client.query(\n        QueryTopic()\n        .with_ontology_tag(Image.ontology_tag())\n        .with_created_timestamp(time_start=Time.from_float(1700000000))\n        .with_expression(Topic.Q.user_metadata[\"camera_id.serial_number\"].eq(\"ABC123_XYZ\"))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/query/#queryontologycatalog-ontology-catalog-layer","title":"<code>QueryOntologyCatalog</code> (Ontology Catalog Layer)","text":"<p>API Reference: <code>mosaicolabs.models.query.builders.QueryOntologyCatalog</code>.</p> <p>Filters based on the actual time-series content of the sensors (e.g., \"Find events where <code>acceleration.z</code> exceeded a specific value\").</p> <p>Example Querying for mixed sensor data</p> <pre><code>from mosaicolabs import MosaicoClient, QueryOntologyCatalog, GPS, IMU\n\n    with MosaicoClient.connect(\"localhost\", 6726) as client:\n        # Chain multiple sensor filters together\n        qresponse = client.query(\n            QueryOntologyCatalog()\n            .with_expression(GPS.Q.status.satellites.geq(8))\n            .with_expression(Temperature.Q.value.between([273.15, 373.15]))\n            .with_expression(Pressure.Q.value.geq(100000))\n        )\n\n        # Inspect the response\n        if qresponse is not None:\n            # Results are automatically grouped by Sequence for easier data management\n            for item in qresponse:\n                print(f\"Sequence: {item.sequence.name}\")\n                print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n        # Filter for a specific component value and extract the first and last occurrence times\n        qresponse = client.query(\n            QueryOntologyCatalog(include_timestamp_range=True)\n            .with_expression(IMU.Q.acceleration.x.lt(-4.0))\n            .with_expression(IMU.Q.acceleration.y.gt(5.0))\n            .with_expression(Pose.Q.rotation.z.geq(0.707))\n        )\n\n        # Inspect the response\n        if qresponse is not None:\n            # Results are automatically grouped by Sequence for easier data management\n            for item in qresponse:\n                print(f\"Sequence: {item.sequence.name}\")\n                print(f\"Topics: {{topic.name:\n                            [topic.timestamp_range.start, topic.timestamp_range.end]\n                            for topic in item.topics}}\")\n</code></pre> <p>The Mosaico Query Module offers two distinct paths for defining filters,  Convenience Methods and Generic Expression Method, both of which support method chaining to compose multiple criteria into a single query using a logical AND.</p>"},{"location":"SDK/query/#convenience-methods","title":"Convenience Methods","text":"<p>The query layers provide high-level fluent helpers (<code>with_&lt;attribute&gt;</code>), built directly into the query builder classes and designed for ease of use. They allow you to filter data without deep knowledge of the internal model schema.  The builder automatically selects the appropriate field and operator (such as exact match vs. substring pattern) based on the method used.</p> <pre><code>from mosaicolabs import QuerySequence, QueryTopic, RobotJoint\n\n# Build a filter with name pattern\nqbuilder = QuerySequence()\n    .with_name_match(\"test_drive\")\n# Execute the query\nqresponse = client.query(qbuilder)\n\n# Inspect the response\nif qresponse is not None:\n    # Results are automatically grouped by Sequence for easier data management\n    for item in qresponse:\n        print(f\"Sequence: {item.sequence.name}\")\n        print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n# Build a filter with ontology tag AND a specific creation time window\nqbuilder = QueryTopic()\n    .with_ontology_tag(RobotJoint.ontology_tag())\n    .with_created_timestamp(start=t1, end=t2)\n# Execute the query\nqresponse = client.query(qbuilder)\n\n# Inspect the response\nif qresponse is not None:\n    # Results are automatically grouped by Sequence for easier data management\n    for item in qresponse:\n        print(f\"Sequence: {item.sequence.name}\")\n        print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre> <ul> <li>Best For: Standard system-level fields like Names and Timestamps.</li> </ul>"},{"location":"SDK/query/#generic-expression-method","title":"Generic Expression Method","text":"<p>The <code>with_expression()</code> method accepts raw Query Expressions generated through the <code>.Q</code> proxy.  This provides full access to every supported operator (<code>.gt()</code>, <code>.lt()</code>, <code>.between()</code>, etc.) for specific fields.</p> <pre><code>from mosaicolabs import QueryOntologyCatalog, QuerySequence, IMU\n\n# Build a filter with name pattern and metadata-related expression\nqbuilder = QuerySequence()\n    .with_expression(\n        # Use query proxy for generating a QueryExpression\n        Sequence.Q.user_metadata['environment.visibility'].lt(50)\n    )\n    # Can be AND-chained with convenience methods\n    .with_name_match(\"test_drive\")\n# Execute the query\nqresponse = client.query(qbuilder)\n\n# Inspect the response\nif qresponse is not None:\n    # Results are automatically grouped by Sequence for easier data management\n    for item in qresponse:\n        print(f\"Sequence: {item.sequence.name}\")\n        print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n# Build a filter with deep time-series data discovery and measurement time windowing\nqbuilder = QueryOntologyCatalog()\n    .with_expression(IMU.Q.acceleration.x.gt(5.0))\n    .with_expression(IMU.Q.header.stamp.sec.gt(1700134567))\n    .with_expression(IMU.Q.header.stamp.nanosec.between([123456, 789123]))\n# Execute the query\nqresponse = client.query(qbuilder)\n\n# Inspect the response\nif qresponse is not None:\n    # Results are automatically grouped by Sequence for easier data management\n    for item in qresponse:\n        print(f\"Sequence: {item.sequence.name}\")\n        print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre> <ul> <li>Best For: Accessing specific Ontology data fields (e.g., acceleration, position, etc.) and custom <code>user_metadata</code> in <code>Sequence</code> and <code>Topic</code> data models.</li> </ul>"},{"location":"SDK/query/#the-q-proxy-mechanism","title":"The <code>.Q</code> Proxy Mechanism","text":"<p>The Query Proxy is the cornerstone of Mosaico's type-safe data discovery. Every data model in the Mosaico Ontology (e.g., <code>IMU</code>, <code>GPS</code>, <code>Image</code>) is automatically injected with a static <code>.Q</code> attribute during class initialization. This mechanism transforms static data structures into dynamic, fluent interfaces for constructing complex filters.</p> <p>The proxy follows a three-step lifecycle to ensure that your queries are both semantically correct and high-performance:</p> <ol> <li>Intelligent Mapping: During system initialization, the proxy inspects the sensor's schema recursively. It maps every nested field path (e.g., <code>\"acceleration.x\"</code>) to a dedicated queryable object, i.e. an object providing comparison operators and expression generation methods.</li> <li>Type-Aware Operators: The proxy identifies the data type of each field (numeric, string, dictionary, or boolean) and exposes only the operators valid for that type. This prevents logical errors, such as attempting a substring <code>.match()</code> on a numeric acceleration value.</li> <li>Intent Generation: When you invoke an operator (e.g., <code>.gt(15.0)</code>), the proxy generates a <code>QueryExpression</code>. This object encapsulates your search intent and is serialized into an optimized JSON format for the platform to execute.</li> </ol> <p>To understand how the proxy handles nested structures, inherited attributes, and data types, consider the <code>IMU</code> ontology class:</p> <pre><code>class IMU(Serializable, HeaderMixin):\n    acceleration: Vector3d      # Composed type: contains x, y, z\n    angular_velocity: Vector3d  # Composed type: contains x, y, z\n    orientation: Optional[Quaternion] = None # Composed type: contains x, y, z, w\n</code></pre> <p>The <code>.Q</code> proxy enables you to navigate the data exactly as it is defined in the model. By following the <code>IMU.Q</code> instruction, you can drill down through nested fields and inherited mixins using standard dot notation until you reach a base queryable type.</p> <p>The proxy automatically flattens the hierarchy, including fields inherited from <code>HeaderMixin</code> (like <code>frame_id</code> and <code>stamp</code>), assigning the correct queryable type and operators to each leaf node: (API Reference: <code>mosaicolabs.models.sensors.IMU</code>)</p> Proxy Field Path Queryable Type Supported Operators (Examples) <code>IMU.Q.acceleration.x/y/z</code> Numeric <code>.gt()</code>, <code>.lt()</code>, <code>.geq()</code>, <code>.leq()</code>, <code>.eq()</code>, <code>.between()</code>, <code>.in_()</code> <code>IMU.Q.angular_velocity.x/y/z</code> Numeric <code>.gt()</code>, <code>.lt()</code>, <code>.geq()</code>, <code>.leq()</code>, <code>.eq()</code>, <code>.between()</code>, <code>.in_()</code> <code>IMU.Q.orientation.x/y/z/w</code> Numeric <code>.gt()</code>, <code>.lt()</code>, <code>.geq()</code>, <code>.leq()</code>, <code>.eq()</code>, <code>.between()</code>, <code>.in_()</code> <code>IMU.Q.header.frame_id</code> String <code>.eq()</code>, <code>.match()</code> <code>IMU.Q.header.stamp.sec</code> Numeric <code>.gt()</code>, <code>.lt()</code>, <code>.geq()</code>, <code>.leq()</code>, <code>.eq()</code>, <code>.between()</code>, <code>.in_()</code> <code>IMU.Q.header.stamp.nanosec</code> Numeric <code>.gt()</code>, <code>.lt()</code>, <code>.geq()</code>, <code>.leq()</code>, <code>.eq()</code>, <code>.between()</code>, <code>.in_()</code> <p>The following table lists the supported operators for each data type:</p> Data Type Operators Numeric <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.leq()</code>, <code>.gt()</code>, <code>.geq()</code>, <code>.between()</code>, <code>.in_()</code> String <code>.eq()</code>, <code>.neq()</code>, <code>.match()</code> (i.e. substring), <code>.in_()</code> Boolean <code>.eq(True/False)</code> Dictionary <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.leq()</code>, <code>.gt()</code>, <code>.geq()</code>, <code>.between()</code>, <code>.in_()</code>, <code>.match()</code>"},{"location":"SDK/query/#supported-vs-unsupported-types","title":"Supported vs. Unsupported Types","text":"<p>While the <code>.Q</code> proxy is highly versatile, it enforces specific rules on which data structures can be queried:</p> <ul> <li>Supported Types: The proxy resolves all simple (int, float, str, bool) or composed types (like <code>Vector3d</code> or <code>Quaternion</code>). It will continue to expose nested fields as long as they lead to a primitive base type.</li> <li> <p>Dictionaries: Dynamic fields, such as the <code>user_metadata</code> found in the <code>Topic</code> and <code>Sequence</code> platform models, are fully queryable through the proxy using bracket notation (e.g., <code>Topic.Q.user_metadata[\"key\"]</code> or <code>Topic.Q.user_metadata[\"key.subkey.subsubkey\"]</code>). This approach provides the flexibility to search across custom tags and dynamic properties that aren't part of a fixed schema. This dictionary-based querying logic is not restricted to platform models; it applies to any custom ontology model created by the user that contains a <code>dict</code> field.</p> <ul> <li>Syntax: Instead of the standard dot notation used for fixed fields, you must use square brackets <code>[\"key\"]</code> to target specific dictionary entries.</li> <li>Nested Access: For dictionaries containing nested structures, you can use dot notation within the key string (e.g., <code>[\"environment.visibility\"]</code>) to traverse sub-fields.</li> <li>Operator Support: Because dictionary values are dynamic, these fields are \"promiscuous,\" meaning they support all available numeric, string, and boolean operators without strict SDK-level type checking.</li> </ul> </li> <li> <p>Unsupported Types (Lists and Tuples): Any field defined as a container, such as a List or Tuple (e.g., <code>covariance: List[float]</code>), is currently skipped by the proxy generator. These fields will not appear in autocomplete and cannot be used in a query expression.</p> </li> </ul>"},{"location":"SDK/query/#constraints-limitations","title":"Constraints &amp; Limitations","text":"<p>While fully functional, the current implementation (v0.x) has a Single Occurrence Constraint.</p> <ul> <li>Constraint: A specific data field path may appear only once within a single query builder instance. You cannot chain two separate conditions on the same field (e.g., <code>.gt(0.5)</code> and <code>.lt(1.0)</code>).     <pre><code># INVALID: The same field (acceleration.x) is used twice in the constructor\nQueryOntologyCatalog() \\\n    .with_expression(IMU.Q.acceleration.x.gt(0.5))\n    .with_expression(IMU.Q.acceleration.x.lt(1.0)) # &lt;- Error! Duplicate field path\n</code></pre></li> <li>Solution: Use the built-in <code>.between([min, max])</code> operator to perform range filtering on a single field path.</li> <li>Note: You can still query multiple different fields from the same sensor model (e.g., <code>acceleration.x</code> and <code>acceleration.y</code>) in one builder.     <pre><code># VALID: Each expression targets a unique field path\nQueryOntologyCatalog(\n    IMU.Q.acceleration.x.gt(0.5),              # Unique field\n    IMU.Q.acceleration.y.lt(1.0),              # Unique field\n    IMU.Q.angular_velocity.x.between([0, 1]),   # Correct way to do ranges\n    include_timestamp_range=True\n)\n</code></pre></li> </ul>"},{"location":"SDK/API_reference/comm/","title":"Communication Module","text":""},{"location":"SDK/API_reference/comm/#mosaicolabs.comm.MosaicoClient","title":"mosaicolabs.comm.MosaicoClient","text":"<pre><code>MosaicoClient(\n    *,\n    host,\n    port,\n    timeout,\n    control_client,\n    connection_pool,\n    executor_pool,\n    sentinel,\n)\n</code></pre> <p>The gateway to the Mosaico Data Platform.</p> <p>This class centralizes connection management, resource pooling, and serves as a factory for specialized handlers. It is designed to manage the lifecycle of both network connections and asynchronous executors efficiently.</p> Context Manager Usage <p>The <code>MosaicoClient</code> is best used as a context manager to ensure all internal pools and connections are gracefully closed.</p> <pre><code>from mosaicolabs import MosaicoClient\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    sequences = client.list_sequences()\n    print(f\"Available data: {sequences}\")\n</code></pre> <p>Internal Constructor (do not call this directly): The <code>MosaicoClient</code> enforces a strict factory pattern for security and proper resource setup. Please use the <code>connect()</code> method instead to obtain an initialized client.</p> Sentinel Enforcement <p>This constructor checks for a private internal sentinel. Attempting to instantiate this class manually will result in a <code>RuntimeError</code>.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The remote server host.</p> required <code>port</code> <code>int</code> <p>The remote server port.</p> required <code>timeout</code> <code>int</code> <p>The connection timeout.</p> required <code>control_client</code> <code>FlightClient</code> <p>The primary PyArrow Flight control client.</p> required <code>connection_pool</code> <code>Optional[_ConnectionPool]</code> <p>Internal pool for data connections.</p> required <code>executor_pool</code> <code>Optional[_ExecutorPool]</code> <p>Internal pool for async I/O.</p> required <code>sentinel</code> <code>object</code> <p>Private object used to verify factory-based instantiation.</p> required"},{"location":"SDK/API_reference/comm/#mosaicolabs.comm.MosaicoClient.connect","title":"connect  <code>classmethod</code>","text":"<pre><code>connect(host, port, timeout=5)\n</code></pre> <p>The primary entry point to the Mosaico Data Platform.</p> <p>This factory method is the only recommended way to obtain a valid <code>MosaicoClient</code> instance. It orchestrates the necessary handshake, initializes the primary control channel, and prepares the internal resource pools.</p> Factory Pattern <p>Direct instantiation via <code>__init__</code> is restricted through a sentinel pattern and will raise a <code>RuntimeError</code>. This ensures that every client in use has been correctly configured with a valid network connection.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The server host address (e.g., \"127.0.0.1\" or \"mosaico.local\").</p> required <code>port</code> <code>int</code> <p>The server port (e.g., 6726).</p> required <code>timeout</code> <code>int</code> <p>Maximum time in seconds to wait for a connection response. Defaults to 5.</p> <code>5</code> <p>Returns:</p> Name Type Description <code>MosaicoClient</code> <code>MosaicoClient</code> <p>An initialized and connected client ready for operations.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If the server is unreachable or the handshake fails.</p> <code>RuntimeError</code> <p>If the class is instantiated directly instead of using this method.</p> Example <pre><code>from mosaicolabs import MosaicoClient\n\n# Establish a connection to the Mosaico Data Platform\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Perform operations using the client\n    pass\n</code></pre>"},{"location":"SDK/API_reference/comm/#mosaicolabs.comm.MosaicoClient.sequence_handler","title":"sequence_handler","text":"<pre><code>sequence_handler(sequence_name)\n</code></pre> <p>Retrieves a <code>SequenceHandler</code> for the given sequence.</p> <p>Handlers are cached; subsequent calls for the same sequence return the existing object to avoid redundant handshakes.</p> <p>Parameters:</p> Name Type Description Default <code>sequence_name</code> <code>str</code> <p>The unique identifier of the sequence.</p> required <p>Returns:</p> Type Description <code>Optional[SequenceHandler]</code> <p>Optional[SequenceHandler]: A handler for managing sequence operations, or None if not found.</p> Example <pre><code>from mosaicolabs import MosaicoClient\n\n# Establish a connection to the Mosaico Data Platform\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Retrieve a sequence handler\n    sequence_handler = client.sequence_handler(\"my_sequence\")\n    if sequence_handler:\n        # Print sequence details\n        print(f\"Sequence: {sequence_handler.name}\")\n        print(f\"Created: {sequence_handler.created_datetime}\")\n        print(f\"Topic list: {sequence_handler.topics}\")\n        print(f\"User Metadata: {sequence_handler.user_metadata}\")\n        print(f\"Size (MB): {sequence_handler.total_size_bytes / 1024 / 1024}\")\n</code></pre>"},{"location":"SDK/API_reference/comm/#mosaicolabs.comm.MosaicoClient.topic_handler","title":"topic_handler","text":"<pre><code>topic_handler(sequence_name, topic_name)\n</code></pre> <p>Retrieves a <code>TopicHandler</code> for a specific data channel.</p> <p>Parameters:</p> Name Type Description Default <code>sequence_name</code> <code>str</code> <p>The parent sequence name.</p> required <code>topic_name</code> <code>str</code> <p>The specific topic name.</p> required <p>Returns:</p> Type Description <code>Optional[TopicHandler]</code> <p>Optional[TopicHandler]: A handler for managing topic operations, or None if not found.</p> Example <pre><code>from mosaicolabs import MosaicoClient\n\n# Establish a connection to the Mosaico Data Platform\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Retrieve a topic handler\n    topic_handler = client.topic_handler(\"my_sequence\", \"/front/camera/image_raw)\n    if topic_handler:\n        # Print topic details\n        print(f\"Topic: {topic_handler.sequence_name}:{topic_handler.name}\")\n        print(f\"Ontology Tag: {topic_handler.ontology_tag}\")\n        print(f\"Created: {topic_handler.created_datetime}\")\n        print(f\"User Metadata: {topic_handler.user_metadata}\")\n        print(f\"Size (MB): {topic_handler.total_size_bytes / 1024 / 1024}\")\n</code></pre>"},{"location":"SDK/API_reference/comm/#mosaicolabs.comm.MosaicoClient.sequence_create","title":"sequence_create","text":"<pre><code>sequence_create(\n    sequence_name,\n    metadata,\n    on_error=Delete,\n    max_batch_size_bytes=None,\n    max_batch_size_records=None,\n)\n</code></pre> <p>Creates a new sequence on the platform and returns a <code>SequenceWriter</code> for ingestion.</p> Important <p>The function must be called inside a with context, otherwise a RuntimeError is raised.</p> <p>Parameters:</p> Name Type Description Default <code>sequence_name</code> <code>str</code> <p>Unique name for the sequence.</p> required <code>metadata</code> <code>dict[str, Any]</code> <p>User-defined metadata to attach.</p> required <code>on_error</code> <code>OnErrorPolicy</code> <p>Behavior on write failure. Defaults to <code>Delete</code>.</p> <code>Delete</code> <code>max_batch_size_bytes</code> <code>Optional[int]</code> <p>Max bytes per Arrow batch.</p> <code>None</code> <code>max_batch_size_records</code> <code>Optional[int]</code> <p>Max records per Arrow batch.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SequenceWriter</code> <code>SequenceWriter</code> <p>An initialized writer instance.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the method is called outside a <code>with</code> context.</p> <code>Exception</code> <p>If any error occurs during sequence injection.</p> Example <pre><code>from mosaicolabs import MosaicoClient, OnErrorPolicy\n\n# Open the connection with the Mosaico Client\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Start the Sequence Orchestrator\n    with client.sequence_create(\n        sequence_name=\"mission_log_042\",\n        # Custom metadata for this data sequence.\n        metadata={\n            \"driver\": {\n                \"driver_id\": \"drv_sim_017\",\n                \"role\": \"validation\",\n                \"experience_level\": \"senior\",\n            },\n            \"location\": {\n                \"city\": \"Milan\",\n                \"country\": \"IT\",\n                \"facility\": \"Downtown\",\n                \"gps\": {\n                    \"lat\": 45.46481,\n                    \"lon\": 9.19201,\n                },\n            },\n        }\n        on_error = OnErrorPolicy.Delete # Default\n        ) as seq_writer:\n            # Start creating topics and pushing data...\n            # (1)!\n</code></pre> <ol> <li>See also:<ul> <li><code>SequenceWriter.topic_create()</code></li> <li><code>TopicWriter.push()</code></li> </ul> </li> </ol>"},{"location":"SDK/API_reference/comm/#mosaicolabs.comm.MosaicoClient.sequence_delete","title":"sequence_delete","text":"<pre><code>sequence_delete(sequence_name)\n</code></pre> <p>Permanently deletes a sequence and all its associated data from the server.</p> <p>This operation is destructive and triggers a cascading deletion of all underlying resources, including all topics and data chunks belonging to the sequence. Once executed, all storage occupied by the sequence is freed.</p> Sequence Locking <p>This action can only be performed on unlocked sequences. If a sequence is currently locked (e.g., for archival or safety reasons), the deletion request will be rejected by the server.</p> <p>Parameters:</p> Name Type Description Default <code>sequence_name</code> <code>str</code> <p>The unique name of the sequence to remove.</p> required"},{"location":"SDK/API_reference/comm/#mosaicolabs.comm.MosaicoClient.list_sequences","title":"list_sequences","text":"<pre><code>list_sequences()\n</code></pre> <p>Retrieves a list of all sequence names available on the server.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: The list of sequence identifiers.</p> Example <pre><code>from mosaicolabs import MosaicoClient\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    sequences = client.list_sequences()\n    print(f\"Available sequences: {sequences}\")\n</code></pre>"},{"location":"SDK/API_reference/comm/#mosaicolabs.comm.MosaicoClient.list_sequence_notify","title":"list_sequence_notify","text":"<pre><code>list_sequence_notify(sequence_name)\n</code></pre> <p>Retrieves a list of all notifications available on the server for a specific sequence.</p> <p>Parameters:</p> Name Type Description Default <code>sequence_name</code> <code>str</code> <p>The name of the sequence to list notifications for.</p> required <p>Returns:</p> Type Description <code>List[Notified]</code> <p>List[Notified]: The list of sequence notifications.</p> Example <pre><code>from mosaicolabs import MosaicoClient\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    sequence_notifications = client.list_sequence_notify(\"my_sequence\")\n    for notify in sequence_notifications:\n        print(f\"Notification Type: {notify.notify_type}\")\n        print(f\"Notification Message: {notify.message}\")\n        print(f\"Notification Created: {notify.created_datetime}\")\n</code></pre>"},{"location":"SDK/API_reference/comm/#mosaicolabs.comm.MosaicoClient.clear_sequence_notify","title":"clear_sequence_notify","text":"<pre><code>clear_sequence_notify(sequence_name)\n</code></pre> <p>Clears the notifications for a specific sequence from the server.</p> <p>Parameters:</p> Name Type Description Default <code>sequence_name</code> <code>str</code> <p>The name of the sequence.</p> required"},{"location":"SDK/API_reference/comm/#mosaicolabs.comm.MosaicoClient.list_topic_notify","title":"list_topic_notify","text":"<pre><code>list_topic_notify(sequence_name, topic_name)\n</code></pre> <p>Retrieves a list of all notifications available on the server for a specific topic</p> <p>Parameters:</p> Name Type Description Default <code>sequence_name</code> <code>str</code> <p>The name of the sequence to list notifications for.</p> required <code>topic_name</code> <code>str</code> <p>The name of the topic to list notifications for.</p> required <p>Returns:</p> Type Description <code>List[Notified]</code> <p>List[str]: The list of topic notifications.</p> Example <pre><code>from mosaicolabs import MosaicoClient\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    topic_notifications = client.list_topic_notify(\"my_sequence\", \"my_topic\")\n    for notify in topic_notifications:\n        print(f\"Notification Type: {notify.notify_type}\")\n        print(f\"Notification Message: {notify.message}\")\n        print(f\"Notification Created: {notify.created_datetime}\")\n</code></pre>"},{"location":"SDK/API_reference/comm/#mosaicolabs.comm.MosaicoClient.clear_topic_notify","title":"clear_topic_notify","text":"<pre><code>clear_topic_notify(sequence_name, topic_name)\n</code></pre> <p>Clears the notifications for a specific topic from the server.</p> <p>Parameters:</p> Name Type Description Default <code>sequence_name</code> <code>str</code> <p>The name of the sequence.</p> required <code>topic_name</code> <code>str</code> <p>The name of the topic.</p> required"},{"location":"SDK/API_reference/comm/#mosaicolabs.comm.MosaicoClient.query","title":"query","text":"<pre><code>query(*queries, query=None)\n</code></pre> <p>Executes one or more queries against the Mosaico database.</p> <p>Multiple provided queries are joined using a logical AND condition.</p> <p>Parameters:</p> Name Type Description Default <code>*queries</code> <code>QueryableProtocol</code> <p>Variable arguments of query builder objects (e.g., <code>QuerySequence</code>).</p> <code>()</code> <code>query</code> <code>Optional[Query]</code> <p>An alternative pre-constructed Query object.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[QueryResponse]</code> <p>Optional[QueryResponse]: The query results, or None if an error occurs.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If conflicting query types are passed or no queries are provided.</p> Query with variadic arguments <pre><code>from mosaicolabs import QueryOntologyCatalog, QuerySequence, Query, IMU, MosaicoClient\n\n# Establish a connection to the Mosaico Data Platform\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Perform the server side query\n    results = client.query(\n        # Append a filter for sequence metadata\n        QuerySequence()\n        .with_expression(\n            # Use query proxy for generating a _QuerySequenceExpression\n            Sequence.Q.user_metadata[\"environment.visibility\"].lt(50)\n        )\n        .with_name_match(\"test_drive\"),\n        # Append a filter with deep time-series data discovery and measurement time windowing\n        QueryOntologyCatalog()\n        .with_expression(IMU.Q.acceleration.x.gt(5.0))\n        .with_expression(IMU.Q.header.stamp.sec.gt(1700134567))\n        .with_expression(IMU.Q.header.stamp.nanosec.between([123456, 789123])),\n    )\n    # Inspect the results\n    if results is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in results:\n            print(f\"Sequence: {item.sequence.name}\")\n</code></pre> Query with <code>Query</code> object <pre><code>from mosaicolabs import QueryOntologyCatalog, QuerySequence, Query, IMU, MosaicoClient\n\n# Establish a connection to the Mosaico Data Platform\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Build a filter with name pattern and metadata-related expression\n    query = Query(\n        # Append a filter for sequence metadata\n        QuerySequence()\n        .with_expression(\n            # Use query proxy for generating a _QuerySequenceExpression\n            Sequence.Q.user_metadata[\"environment.visibility\"].lt(50)\n        )\n        .with_name_match(\"test_drive\"),\n        # Append a filter with deep time-series data discovery and measurement time windowing\n        QueryOntologyCatalog()\n        .with_expression(IMU.Q.acceleration.x.gt(5.0))\n        .with_expression(IMU.Q.header.stamp.sec.gt(1700134567))\n        .with_expression(IMU.Q.header.stamp.nanosec.between([123456, 789123])),\n    )\n    # Perform the server side query\n    results = client.query(query=query)\n    # Inspect the results\n    if results is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in results:\n            print(f\"Sequence: {item.sequence.name}\")\n</code></pre>"},{"location":"SDK/API_reference/comm/#mosaicolabs.comm.MosaicoClient.clear_sequence_handlers_cache","title":"clear_sequence_handlers_cache","text":"<pre><code>clear_sequence_handlers_cache()\n</code></pre> <p>Clears the internal cache of <code>SequenceHandler</code> objects.</p>"},{"location":"SDK/API_reference/comm/#mosaicolabs.comm.MosaicoClient.clear_topic_handlers_cache","title":"clear_topic_handlers_cache","text":"<pre><code>clear_topic_handlers_cache()\n</code></pre> <p>Clears the internal cache of <code>TopicHandler</code> objects.</p>"},{"location":"SDK/API_reference/comm/#mosaicolabs.comm.MosaicoClient.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Gracefully shuts down the Mosaico client and releases all underlying resources.</p> <p>This method ensures a clean termination of the client's lifecycle by: * Closing Handlers: Invalidates and closes all cached <code>SequenceHandlers</code> and <code>TopicHandlers</code> to prevent stale data access. * Network Cleanup: Terminated the connection pool to the <code>mosaicod</code> backend. * Thread Termination: Shuts down the internal thread executor pool responsible for asynchronous data fetching and background streaming.</p> Note <p>If using the client as a context manager (via <code>with MosaicoClient.connect(...)</code>), this method is invoked automatically on exit. Explicit calls are required only for manual lifecycle management.</p> Example <pre><code>from mosaicolabs import MosaicoClient\n\n# Manual connection management\nclient = MosaicoClient.connect(\"localhost\", 6726)\n# High-performance streaming or ML extraction\nqresp = client.query(...)\n# Do something else...\n\n# Ensure resources are consistently freed.\nclient.close()\n</code></pre>"},{"location":"SDK/API_reference/comm/#mosaicolabs.comm.NotifyType","title":"mosaicolabs.comm.NotifyType","text":"<p>               Bases: <code>StrEnum</code></p> <p>Classification of platform-level notifications.</p> <p>These identifiers distinguish the severity and intent of messages sent from the Mosaico server regarding resource states or operation failures.</p> <p>Attributes:</p> Name Type Description <code>ERROR</code> <p>Indicates a critical failure during resource operations, such as a writing interruption or serialization fault.</p>"},{"location":"SDK/API_reference/comm/#mosaicolabs.comm.NotifyType.ERROR","title":"ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ERROR = 'error'\n</code></pre> <p>Critical error notification.</p>"},{"location":"SDK/API_reference/comm/#mosaicolabs.comm.Notified","title":"mosaicolabs.comm.Notified  <code>dataclass</code>","text":"<pre><code>Notified(\n    sequence_name,\n    notify_type,\n    message,\n    created_datetime,\n    topic_name=None,\n)\n</code></pre> <p>Platform diagnostic notification.</p> <p>A <code>Notified</code> object represents a specific event or error report stored on the platform server. These are typically generated by asynchronous ingestion tasks and are critical for debugging failures when using <code>OnErrorPolicy.Report</code>.</p>"},{"location":"SDK/API_reference/comm/#mosaicolabs.comm.Notified--discovery","title":"Discovery","text":"<p>Notifications can be retrieved at both the sequence and topic level via the Mosaico client:</p> <ul> <li><code>MosaicoClient.list_sequence_notify()</code></li> <li><code>MosaicoClient.list_topic_notify()</code></li> </ul> Example <pre><code>with MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Retrieve notifications for a problematic sequence\n    errors = client.list_sequence_notify(\"mission_alpha\")\n    for error in errors:\n        print(f\"[{error.created_datetime}] {error.notify_type}: {error.message}\")\n</code></pre> <p>Attributes:</p> Name Type Description <code>sequence_name</code> <code>str</code> <p>The unique identifier of the associated sequence.</p> <code>notify_type</code> <code>NotifyType</code> <p>The <code>NotifyType</code> categorization of this event.</p> <code>message</code> <code>str</code> <p>A detailed string describing the event or error cause.</p> <code>created_datetime</code> <code>datetime</code> <p>The timestamp when the server generated the notification.</p> <code>topic_name</code> <code>Optional[str]</code> <p>Optional; the specific topic name if the notification is granular to a single data channel.</p>"},{"location":"SDK/API_reference/enum/","title":"Enum Module","text":""},{"location":"SDK/API_reference/enum/#mosaicolabs.enum.SerializationFormat","title":"mosaicolabs.enum.SerializationFormat","text":"<p>               Bases: <code>StrEnum</code></p> <p>Defines the structural format used when serializing ontology data for storage or transmission.</p> <p>The format dictates how the data is organized (e.g., fixed-schema tables vs. variable-length structures) and may imply specific handling during the serialization and deserialization process.</p>"},{"location":"SDK/API_reference/enum/#mosaicolabs.enum.SerializationFormat.Default","title":"Default  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Default = 'default'\n</code></pre> <p>Represents data that conforms to a strict, fixed-width tabular format  (like a standard DataFrame or a PyArrow Table of records).  Suitable for simple sensors with a constant number of fields and fixed-size data.</p>"},{"location":"SDK/API_reference/enum/#mosaicolabs.enum.SerializationFormat.Ragged","title":"Ragged  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Ragged = 'ragged'\n</code></pre> <p>Represents data containing variable-length lists or sequences (e.g., point clouds,  lists of detections, or non-uniform arrays).  This format is typically serialized using specialized PyArrow features  to handle the non-uniform structure efficiently.</p>"},{"location":"SDK/API_reference/enum/#mosaicolabs.enum.SerializationFormat.Image","title":"Image  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Image = 'image'\n</code></pre> <p>Represents raw or compressed image data.  This format signals that the data consists primarily of a binary blob  (the image content) along with associated metadata (width, height, format),  often requiring specialized compression/decompression handling.</p>"},{"location":"SDK/API_reference/enum/#mosaicolabs.enum.SequenceStatus","title":"mosaicolabs.enum.SequenceStatus","text":"<p>               Bases: <code>Enum</code></p> <p>Represents the operational lifecycle state of a Sequence during the ingestion process (see also <code>SequenceWriter</code>).</p> <p>This enumeration tracks the state of a sequence from its initial creation through data writing until it reaches a terminal state (Finalized or Error).</p>"},{"location":"SDK/API_reference/enum/#mosaicolabs.enum.SequenceStatus.Null","title":"Null  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Null = 'null'\n</code></pre> <p>The initial state of a writer before server-side registration.</p> <p>In this state, the local <code>SequenceWriter</code> instance  has been created but the <code>SEQUENCE_CREATE</code> handshake has not yet been performed  or completed.</p>"},{"location":"SDK/API_reference/enum/#mosaicolabs.enum.SequenceStatus.Pending","title":"Pending  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Pending = 'pending'\n</code></pre> <p>The sequence is registered on the server and actively accepting data.</p> <p>This state is entered upon successful execution of the <code>__enter__</code> method of the <code>SequenceWriter</code> class. While pending, the sequence allows for the  creation of new topics and the ingestion of data batches.</p>"},{"location":"SDK/API_reference/enum/#mosaicolabs.enum.SequenceStatus.Finalized","title":"Finalized  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Finalized = 'finalized'\n</code></pre> <p>The sequence has been successfully closed and its data is now immutable.</p> <p>This terminal state indicates that the <code>SequenceWriter._finalize()</code> action was acknowledged by the server. Once finalized,  the sequence is typically locked and cannot be deleted unless explicitly  unlocked by an administrator.</p>"},{"location":"SDK/API_reference/enum/#mosaicolabs.enum.SequenceStatus.Error","title":"Error  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Error = 'error'\n</code></pre> <p>The ingestion process failed or was explicitly aborted.</p> <p>This state is reached if an exception occurs within the <code>with</code> block or during  the finalization phase. Depending on the  <code>OnErrorPolicy</code>, the data may have been  purged (<code>Delete</code>) or retained in an unlocked state for debugging (<code>Report</code>).</p>"},{"location":"SDK/API_reference/enum/#mosaicolabs.enum.OnErrorPolicy","title":"mosaicolabs.enum.OnErrorPolicy","text":"<p>               Bases: <code>Enum</code></p> <p>Defines the behavior of the <code>SequenceWriter</code> when an exception occurs during ingestion.</p> <p>This policy determines how the platform handles partially uploaded data if the ingestion process is interrupted or fails.</p>"},{"location":"SDK/API_reference/enum/#mosaicolabs.enum.OnErrorPolicy.Report","title":"Report  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Report = 'report'\n</code></pre> <p>Notify the server of the error but retain partial data.</p> <p>The system will attempt to finalize the sequence and notify the server of the  specific failure, allowing existing data chunks to remain accessible for  inspection. </p> Lock Status <p>Unlike standard successful finalization, a sequence finalized via a  <code>Report</code> policy is not placed in a locked state.  This means the sequence remains mutable at a system level and can be  deleted in a later moment once debugging or triage is complete.</p>"},{"location":"SDK/API_reference/enum/#mosaicolabs.enum.OnErrorPolicy.Delete","title":"Delete  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Delete = 'delete'\n</code></pre> <p>Abort the sequence and instruct the server to discard all data.</p> <p>This is the default \"all-or-nothing\" strategy. If a failure occurs, the  <code>SequenceWriter</code> will send an abort  command to ensure the server purges all traces of the failed ingestion,  preventing inconsistent or incomplete sequences from appearing in the  catalog.</p>"},{"location":"SDK/API_reference/enum/#mosaicolabs.enum.FlightAction","title":"mosaicolabs.enum.FlightAction","text":"<p>               Bases: <code>StrEnum</code></p> <p>Internal enumeration of PyArrow Flight action identifiers.</p> <p>This enum serves as the single source of truth for all action names used in the handshakes between the SDK and the Mosaico server.</p> Internal Use Only <p>This class is part of the internal communication protocol. End-users should never need to use these identifiers directly, as they are abstracted by the public methods in <code>MosaicoClient</code>, <code>SequenceWriter</code>, and <code>TopicWriter</code>.</p>"},{"location":"SDK/API_reference/enum/#mosaicolabs.enum.FlightAction.SEQUENCE_CREATE","title":"SEQUENCE_CREATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SEQUENCE_CREATE = 'sequence_create'\n</code></pre> <p>Initiates the registration of a new sequence on the server.</p>"},{"location":"SDK/API_reference/enum/#mosaicolabs.enum.FlightAction.SEQUENCE_FINALIZE","title":"SEQUENCE_FINALIZE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SEQUENCE_FINALIZE = 'sequence_finalize'\n</code></pre> <p>Marks a sequence as complete and makes its data immutable.</p>"},{"location":"SDK/API_reference/enum/#mosaicolabs.enum.FlightAction.SEQUENCE_NOTIFY_CREATE","title":"SEQUENCE_NOTIFY_CREATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SEQUENCE_NOTIFY_CREATE = 'sequence_notify_create'\n</code></pre> <p>Sends asynchronous notifications or error reports during the sequence creation phase.</p>"},{"location":"SDK/API_reference/enum/#mosaicolabs.enum.FlightAction.SEQUENCE_NOTIFY_LIST","title":"SEQUENCE_NOTIFY_LIST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SEQUENCE_NOTIFY_LIST = 'sequence_notify_list'\n</code></pre> <p>Request the list of notifications for a specific sequence</p>"},{"location":"SDK/API_reference/enum/#mosaicolabs.enum.FlightAction.SEQUENCE_NOTIFY_PURGE","title":"SEQUENCE_NOTIFY_PURGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SEQUENCE_NOTIFY_PURGE = 'sequence_notify_purge'\n</code></pre> <p>Request the deletion of the list of notifications for a specific sequence</p>"},{"location":"SDK/API_reference/enum/#mosaicolabs.enum.FlightAction.SEQUENCE_SYSTEM_INFO","title":"SEQUENCE_SYSTEM_INFO  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SEQUENCE_SYSTEM_INFO = 'sequence_system_info'\n</code></pre> <p>Requests physical diagnostics such as storage size and lock status for a sequence.</p>"},{"location":"SDK/API_reference/enum/#mosaicolabs.enum.FlightAction.SEQUENCE_ABORT","title":"SEQUENCE_ABORT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SEQUENCE_ABORT = 'sequence_abort'\n</code></pre> <p>Signals the server to stop an active ingestion and discard partial data.</p>"},{"location":"SDK/API_reference/enum/#mosaicolabs.enum.FlightAction.SEQUENCE_DELETE","title":"SEQUENCE_DELETE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SEQUENCE_DELETE = 'sequence_delete'\n</code></pre> <p>Requests the permanent removal of a sequence and all associated topics from the server.</p>"},{"location":"SDK/API_reference/enum/#mosaicolabs.enum.FlightAction.TOPIC_CREATE","title":"TOPIC_CREATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TOPIC_CREATE = 'topic_create'\n</code></pre> <p>Registers a new topic within an existing sequence context.</p>"},{"location":"SDK/API_reference/enum/#mosaicolabs.enum.FlightAction.TOPIC_NOTIFY_CREATE","title":"TOPIC_NOTIFY_CREATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TOPIC_NOTIFY_CREATE = 'topic_notify_create'\n</code></pre> <p>Reports errors or status updates specific to an individual topic stream.</p>"},{"location":"SDK/API_reference/enum/#mosaicolabs.enum.FlightAction.TOPIC_NOTIFY_LIST","title":"TOPIC_NOTIFY_LIST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TOPIC_NOTIFY_LIST = 'topic_notify_list'\n</code></pre> <p>Request the list of notifications for a specific topic in a sequence</p>"},{"location":"SDK/API_reference/enum/#mosaicolabs.enum.FlightAction.TOPIC_NOTIFY_PURGE","title":"TOPIC_NOTIFY_PURGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TOPIC_NOTIFY_PURGE = 'topic_notify_purge'\n</code></pre> <p>Request the deletion of the list of notifications for a topic in a sequence</p>"},{"location":"SDK/API_reference/enum/#mosaicolabs.enum.FlightAction.TOPIC_SYSTEM_INFO","title":"TOPIC_SYSTEM_INFO  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TOPIC_SYSTEM_INFO = 'topic_system_info'\n</code></pre> <p>Requests storage and chunk metadata for an individual topic.</p>"},{"location":"SDK/API_reference/enum/#mosaicolabs.enum.FlightAction.TOPIC_DELETE","title":"TOPIC_DELETE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TOPIC_DELETE = 'topic_delete'\n</code></pre> <p>Requests the permanent removal of a specific topic from the platform.</p>"},{"location":"SDK/API_reference/enum/#mosaicolabs.enum.FlightAction.QUERY","title":"QUERY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QUERY = 'query'\n</code></pre> <p>Commands a multi-layer search query against the platform.</p>"},{"location":"SDK/API_reference/bridges/ml/","title":"Machine Learning Module","text":""},{"location":"SDK/API_reference/bridges/ml/#mosaicolabs.ml.DataFrameExtractor","title":"mosaicolabs.ml.DataFrameExtractor","text":"<pre><code>DataFrameExtractor(sequence_handler)\n</code></pre> <p>Extracts and manages data from Mosaico Sequences, converting them into tabular DataFrames.</p> <p>This class serves as a high-performance bridge for training ML models or performing data analysis. It extracts data from multiple sequence topics and unifies them into a single, flattened, sparse DataFrame aligned by timestamps.</p> <p>Key Features:</p> <ul> <li>Memory Efficiency: Uses a windowed approach to process multi-gigabyte sequences in chunks   without overloading RAM.</li> <li>Flattening: Automatically flattens nested structures (e.g., <code>pose.position.x</code>) into   dot-notation columns.</li> <li>Sparse Alignment: Merges multiple topics with different frequencies into a single timeline   (using <code>NaN</code> for missing values at specific timestamps).</li> </ul> <p>Initializes the DataFrameExtractor.</p> <p>Parameters:</p> Name Type Description Default <code>sequence_handler</code> <code>SequenceHandler</code> <p>An active handle to a Mosaico sequence.</p> required"},{"location":"SDK/API_reference/bridges/ml/#mosaicolabs.ml.DataFrameExtractor.to_pandas_chunks","title":"to_pandas_chunks","text":"<pre><code>to_pandas_chunks(\n    topics=None,\n    window_sec=5.0,\n    timestamp_ns_start=None,\n    timestamp_ns_end=None,\n)\n</code></pre> <p>Generator that yields time-windowed pandas DataFrames from the sequence.</p> <p>This method leverages server-side filtering and local batch processing to maintain a low memory footprint. It handles batches that cross window boundaries by carrying over the remainder to the next chunk.</p> Important <p>This function must be iterated (e.g. called in a for loop)</p> Warning <p>Setting <code>window_sec</code> to a very large value might disable windowing. The extractor will attempt to load the entire requested time range into memory. This is only recommended for small sequences or systems with high RAM capacity.</p> <p>Parameters:</p> Name Type Description Default <code>topics</code> <code>List[str]</code> <p>Topics to extract. Defaults to all topics.</p> <code>None</code> <code>window_sec</code> <code>float</code> <p>Duration of each DataFrame chunk in seconds.</p> <code>5.0</code> <code>timestamp_ns_start</code> <code>int</code> <p>Global start time for extraction.</p> <code>None</code> <code>timestamp_ns_end</code> <code>int</code> <p>Global end time for extraction.</p> <code>None</code> <p>Yields:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A sparse, flattened DataFrame containing data from all selected topics and their fields within the current time window.</p> Example <pre><code># Obtain a dataframe with DataFrameExtractor\nfrom mosaicolabs import MosaicoClient, IMU, Image\nfrom mosaicolabs.ml import DataFrameExtractor, SyncTransformer\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    sequence_handler = client.get_sequence_handler(\"example_sequence\")\n    for df in DataFrameExtractor(sequence_handler).to_pandas_chunks(\n        topics = [\"/front/imu\", \"/front/camera/image_raw\"]\n    ):\n        # Do something with the dataframe.\n        # For example, you can sync the data using the `SyncTransformer`:\n        sync_transformer = SyncTransformer(\n            target_fps = 30, # resample at 30 Hz and fill the Nans with a Hold policy\n        )\n        synced_df = sync_transformer.transform(df)\n\n        # Reconstruct the image message from a dataframe row\n        image_msg = Message.from_dataframe_row(synced_df, \"/front/camera/image_raw\")\n        image_data = image_msg.get_data(Image)\n        # Show the image\n        image_data.to_pillow().show()\n        # ...\n</code></pre>"},{"location":"SDK/API_reference/bridges/ml/#mosaicolabs.ml.SyncTransformer","title":"mosaicolabs.ml.SyncTransformer","text":"<pre><code>SyncTransformer(\n    target_fps,\n    policy=SyncHold(),\n    timestamp_column=\"timestamp_ns\",\n)\n</code></pre> <p>Stateful resampler for Mosaico DataFrames.</p> <p>This class aligns heterogeneous sensor streams onto a uniform time grid. It is designed to consume the windowed outputs of the <code>DataFrameExtractor</code> sequentially, maintaining internal state to ensure signal continuity across batch boundaries.</p>"},{"location":"SDK/API_reference/bridges/ml/#mosaicolabs.ml.SyncTransformer--scikit-learn-compatibility","title":"Scikit-Learn Compatibility","text":"<p>The class implements the standard <code>fit</code>/<code>transform</code> interface, making it fully compliant with Scikit-learn <code>Pipeline</code> and <code>FeatureUnion</code> objects.</p> <ul> <li>fit(X): Captures the initial timestamp from the first chunk to align   the grid.</li> <li>transform(X): Executes the temporal resampling logic for a single   DataFrame chunk and returns a dense DataFrame.</li> <li>fit_transform(X): Fits the transformer to the data and then transforms it.</li> </ul> <p>Key Features:</p> <ul> <li>Fixed Frequency: Normalizes multi-rate sensors to a target FPS.</li> <li>Stateful Persistence: Carries the last known sensor state into the next chunk.</li> <li>Semantic Integrity: Correctly handles 'Late Arrivals' by yielding None for   ticks preceding the first physical measurement.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>target_fps</code> <code>float</code> <p>The desired output frequency in Hz.</p> required <code>policy</code> <code>SyncPolicy</code> <p>A strategy implementing the <code>SyncPolicy</code> protocol.</p> <code>SyncHold()</code> <code>timestamp_column</code> <code>str</code> <p>The column name containing the timestamp data.</p> <code>'timestamp_ns'</code>"},{"location":"SDK/API_reference/bridges/ml/#mosaicolabs.ml.SyncTransformer.fit","title":"fit","text":"<pre><code>fit(X, y=None)\n</code></pre> <p>Initializes the grid alignment based on the first observed timestamp.</p>"},{"location":"SDK/API_reference/bridges/ml/#mosaicolabs.ml.SyncTransformer.transform","title":"transform","text":"<pre><code>transform(X)\n</code></pre> <p>Syncronizes a sparse DataFrame chunk into a dense, uniform DataFrame.</p> Example with generic dataframe <pre><code>from mosaicolabs.ml import SyncTransformer, SyncHold\n\n# 5 Hz Target (200ms steps)\ntransformer = SyncTransformer(target_fps=5, policy=SyncHold())\n\n# Define a sparse dataframe with two sensors:\n# `sensor_a` starts at 0, `sensor_b` arrives at 600ms\nsparse_data = {\n    \"timestamp_ns\": [\n        0,\n        600_000_000,\n        900_000_000,\n        1_200_000_000,\n        1_500_000_000,\n    ],\n    \"val1\": [10.0, 11.0, None, 12.0, 13.0],\n    \"val2\": [None, 1.0, 2.0, None, 3.0],\n}\ndf = pd.DataFrame(sparse_data)\ndense_df = transformer.fit(df).transform(df)\n\n# Expected output\n# \"timestamp_ns\",   \"sensor_a\", \"sensor_b\"\n# 0,                10.0,       None        # &lt;- avoid hallucination on `sensor_b`\n# 200_000_000,      10.0,       None        # &lt;- avoid hallucination on `sensor_b`\n# 400_000_000,      10.0,       None        # &lt;- avoid hallucination on `sensor_b`\n# 600_000_000,      11.0,       1.0\n# 800_000_000,      11.0,       2.0\n# 1_000_000_000,    11.0,       2.0\n# 1_200_000_000,    12.0,       2.0\n# 1_400_000_000,    12.0,       2.0\n</code></pre> Example with Mosaico dataframe <pre><code># Obtain a dataframe with DataFrameExtractor\nfrom mosaicolabs import MosaicoClient, IMU, Image\nfrom mosaicolabs.ml import DataFrameExtractor, SyncTransformer\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    sequence_handler = client.get_sequence_handler(\"example_sequence\")\n    for df in DataFrameExtractor(sequence_handler).to_pandas_chunks(\n        topics = [\"/front/imu\", \"/front/camera/image_raw\"]\n    ):\n        # Synch the data at 30 Hz:\n        sync_transformer = SyncTransformer(\n            target_fps = 30, # resample at 30 Hz and fill the Nans with a `Hold` policy\n        )\n        synced_df = sync_transformer.transform(df)\n        # Do something with the synced dataframe\n        # ...\n</code></pre>"},{"location":"SDK/API_reference/bridges/ml/#mosaicolabs.ml.SyncTransformer.fit_transform","title":"fit_transform","text":"<pre><code>fit_transform(X, y=None)\n</code></pre> <p>Fits the transformer to the data and then transforms it.</p>"},{"location":"SDK/API_reference/bridges/ml/#mosaicolabs.ml.SyncTransformer.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Resets the internal temporal state and cached sensor values.</p>"},{"location":"SDK/API_reference/bridges/ml/#mosaicolabs.ml.SyncPolicy","title":"mosaicolabs.ml.SyncPolicy","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol defining the interface for data synchronization policies.</p> <p>A <code>SyncPolicy</code> determines how sparse data samples are mapped onto a standard, dense time grid. Classes implementing this protocol are used by <code>SyncTransformer</code> to resample sensor data (e.g., holding the last value, interpolating, or dropping old data).</p> <p>Common implementations include:</p> <ul> <li><code>SyncHold</code>: Zero-order hold (carries the last value forward).</li> <li><code>SyncAsOf</code>: Tolerance-based hold (carries value forward only for a specific duration).</li> <li><code>SyncDrop</code>: Strict interval matching (drops data outside the current grid step).</li> </ul>"},{"location":"SDK/API_reference/bridges/ml/#mosaicolabs.ml.SyncPolicy.apply","title":"apply","text":"<pre><code>apply(grid, s_ts, s_val)\n</code></pre> <p>Applies the synchronization logic to sparse samples, mapping them to the target grid.</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>ndarray</code> <p>The target dense timeline (nanosecond timestamps).</p> required <code>s_ts</code> <code>ndarray</code> <p>The source acquisition timestamps (sparse data).</p> required <code>s_val</code> <code>ndarray</code> <p>The source sensor values corresponding to <code>s_ts</code>.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An object-array of the same length as <code>grid</code>, containing the synchronized values. Slots with no valid data are filled with <code>None</code>.</p>"},{"location":"SDK/API_reference/bridges/ml/#mosaicolabs.ml.SyncHold","title":"mosaicolabs.ml.SyncHold","text":"<p>Classic Last-Value-Hold (Zero-Order Hold) synchronization.</p> <p>This policy carries the most recent valid sample forward to all future grid ticks until a new sample is received. It effectively creates a \"step\" function from the sparse samples.</p>"},{"location":"SDK/API_reference/bridges/ml/#mosaicolabs.ml.SyncHold.apply","title":"apply","text":"<pre><code>apply(grid, s_ts, s_val)\n</code></pre> <p>Applies the Zero-Order Hold logic.</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>ndarray</code> <p>The target dense timeline (nanosecond timestamps).</p> required <code>s_ts</code> <code>ndarray</code> <p>The source acquisition timestamps.</p> required <code>s_val</code> <code>ndarray</code> <p>The source sensor values.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Densely populated array where each point holds the last known value.</p>"},{"location":"SDK/API_reference/bridges/ml/#mosaicolabs.ml.SyncAsOf","title":"mosaicolabs.ml.SyncAsOf","text":"<pre><code>SyncAsOf(tolerance_ns)\n</code></pre> <p>Tolerance-based 'As-Of' synchronization.</p> <p>Similar to <code>SyncHold</code>, but limits how far a value can be carried forward. If the time difference between the grid tick and the last sample exceeds <code>tolerance_ns</code>, the value is considered stale and the slot is left as <code>None</code>.</p> <p>Parameters:</p> Name Type Description Default <code>tolerance_ns</code> <code>int</code> <p>Maximum allowed age (in nanoseconds) for a sample to be valid.</p> required"},{"location":"SDK/API_reference/bridges/ml/#mosaicolabs.ml.SyncAsOf.apply","title":"apply","text":"<pre><code>apply(grid, s_ts, s_val)\n</code></pre> <p>Applies the As-Of synchronization logic with tolerance check.</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>ndarray</code> <p>The target dense timeline.</p> required <code>s_ts</code> <code>ndarray</code> <p>The source acquisition timestamps.</p> required <code>s_val</code> <code>ndarray</code> <p>The source sensor values.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Densely populated array, with <code>None</code> where data is missing or stale.</p>"},{"location":"SDK/API_reference/bridges/ml/#mosaicolabs.ml.SyncDrop","title":"mosaicolabs.ml.SyncDrop","text":"<pre><code>SyncDrop(step_ns)\n</code></pre> <p>Strict Interval-based 'Drop' synchronization.</p> <p>Only yields a value if a sample was acquired strictly within the current grid interval <code>(t_grid - step_ns, t_grid]</code>. If no sample falls in this window, the result is <code>None</code>. This is useful for event-based matching.</p> <p>Parameters:</p> Name Type Description Default <code>step_ns</code> <code>int</code> <p>The duration of the backward-looking window in nanoseconds.</p> required"},{"location":"SDK/API_reference/bridges/ml/#mosaicolabs.ml.SyncDrop.apply","title":"apply","text":"<pre><code>apply(grid, s_ts, s_val)\n</code></pre> <p>Applies the Drop synchronization logic.</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>ndarray</code> <p>The target dense timeline.</p> required <code>s_ts</code> <code>ndarray</code> <p>The source acquisition timestamps.</p> required <code>s_val</code> <code>ndarray</code> <p>The source sensor values.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Array containing values only for populated intervals, otherwise <code>None</code>.</p>"},{"location":"SDK/API_reference/bridges/ros/custom_ontology/","title":"ROS Custom Ontology","text":"<p>The following data models are specific to the ROS bridge and are not part of the official Mosaico Data Ontology yet.</p>"},{"location":"SDK/API_reference/bridges/ros/custom_ontology/#mosaicolabs.ros_bridge.data_ontology.BatteryState","title":"mosaicolabs.ros_bridge.data_ontology.BatteryState","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code></p> <p>Represents the state of a battery power supply.</p> <p>modeled after: sensor_msgs/msg/BatteryState</p> Note <p>This model is still not included in the default ontology of Mosaico and is defined specifically for the ros-bridge module</p>"},{"location":"SDK/API_reference/bridges/ros/custom_ontology/#mosaicolabs.ros_bridge.data_ontology.BatteryState.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/bridges/ros/custom_ontology/#mosaicolabs.ros_bridge.data_ontology.BatteryState.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/bridges/ros/custom_ontology/#mosaicolabs.ros_bridge.data_ontology.BatteryState.voltage","title":"voltage  <code>instance-attribute</code>","text":"<pre><code>voltage\n</code></pre> <p>The battery voltage value</p>"},{"location":"SDK/API_reference/bridges/ros/custom_ontology/#mosaicolabs.ros_bridge.data_ontology.BatteryState.temperature","title":"temperature  <code>instance-attribute</code>","text":"<pre><code>temperature\n</code></pre> <p>The optional battery temperature in \u00b0C</p>"},{"location":"SDK/API_reference/bridges/ros/custom_ontology/#mosaicolabs.ros_bridge.data_ontology.BatteryState.current","title":"current  <code>instance-attribute</code>","text":"<pre><code>current\n</code></pre> <p>The optional battery current in A</p>"},{"location":"SDK/API_reference/bridges/ros/custom_ontology/#mosaicolabs.ros_bridge.data_ontology.BatteryState.charge","title":"charge  <code>instance-attribute</code>","text":"<pre><code>charge\n</code></pre> <p>The optional battery charge in Ah</p>"},{"location":"SDK/API_reference/bridges/ros/custom_ontology/#mosaicolabs.ros_bridge.data_ontology.BatteryState.capacity","title":"capacity  <code>instance-attribute</code>","text":"<pre><code>capacity\n</code></pre> <p>The optional battery capacity in Ah</p>"},{"location":"SDK/API_reference/bridges/ros/custom_ontology/#mosaicolabs.ros_bridge.data_ontology.BatteryState.design_capacity","title":"design_capacity  <code>instance-attribute</code>","text":"<pre><code>design_capacity\n</code></pre> <p>The optional battery design capacity in Ah</p>"},{"location":"SDK/API_reference/bridges/ros/custom_ontology/#mosaicolabs.ros_bridge.data_ontology.BatteryState.percentage","title":"percentage  <code>instance-attribute</code>","text":"<pre><code>percentage\n</code></pre> <p>The battery percentage in %</p>"},{"location":"SDK/API_reference/bridges/ros/custom_ontology/#mosaicolabs.ros_bridge.data_ontology.BatteryState.power_supply_status","title":"power_supply_status  <code>instance-attribute</code>","text":"<pre><code>power_supply_status\n</code></pre> <p>The charging status</p>"},{"location":"SDK/API_reference/bridges/ros/custom_ontology/#mosaicolabs.ros_bridge.data_ontology.BatteryState.power_supply_health","title":"power_supply_health  <code>instance-attribute</code>","text":"<pre><code>power_supply_health\n</code></pre> <p>The battery health</p>"},{"location":"SDK/API_reference/bridges/ros/custom_ontology/#mosaicolabs.ros_bridge.data_ontology.BatteryState.power_supply_technology","title":"power_supply_technology  <code>instance-attribute</code>","text":"<pre><code>power_supply_technology\n</code></pre> <p>The battery technology</p>"},{"location":"SDK/API_reference/bridges/ros/custom_ontology/#mosaicolabs.ros_bridge.data_ontology.BatteryState.present","title":"present  <code>instance-attribute</code>","text":"<pre><code>present\n</code></pre> <p>The battery presence</p>"},{"location":"SDK/API_reference/bridges/ros/custom_ontology/#mosaicolabs.ros_bridge.data_ontology.BatteryState.location","title":"location  <code>instance-attribute</code>","text":"<pre><code>location\n</code></pre> <p>The battery location (like the slot)</p>"},{"location":"SDK/API_reference/bridges/ros/custom_ontology/#mosaicolabs.ros_bridge.data_ontology.BatteryState.serial_number","title":"serial_number  <code>instance-attribute</code>","text":"<pre><code>serial_number\n</code></pre> <p>The battery serial number</p>"},{"location":"SDK/API_reference/bridges/ros/custom_ontology/#mosaicolabs.ros_bridge.data_ontology.BatteryState.cell_voltage","title":"cell_voltage  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cell_voltage = None\n</code></pre> <p>The battery cells voltage</p>"},{"location":"SDK/API_reference/bridges/ros/custom_ontology/#mosaicolabs.ros_bridge.data_ontology.BatteryState.cell_temperature","title":"cell_temperature  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cell_temperature = None\n</code></pre> <p>The battery cells temperature</p>"},{"location":"SDK/API_reference/bridges/ros/custom_ontology/#mosaicolabs.ros_bridge.data_ontology.BatteryState.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/bridges/ros/custom_ontology/#mosaicolabs.ros_bridge.data_ontology.BatteryState.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/bridges/ros/custom_ontology/#mosaicolabs.ros_bridge.data_ontology.FrameTransform","title":"mosaicolabs.ros_bridge.data_ontology.FrameTransform","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code></p> <p>Represents a list of transformations between two coordinates.</p> <p>modeled after: tf2_msgs/msg/TFMessage</p> Note <p>This model is not included in the default ontology of Mosaico and is defined specifically for the ros-bridge module</p>"},{"location":"SDK/API_reference/bridges/ros/custom_ontology/#mosaicolabs.ros_bridge.data_ontology.FrameTransform.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/bridges/ros/custom_ontology/#mosaicolabs.ros_bridge.data_ontology.FrameTransform.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/bridges/ros/custom_ontology/#mosaicolabs.ros_bridge.data_ontology.FrameTransform.transforms","title":"transforms  <code>instance-attribute</code>","text":"<pre><code>transforms\n</code></pre> <p>List of coordinate frames transformations.</p>"},{"location":"SDK/API_reference/bridges/ros/custom_ontology/#mosaicolabs.ros_bridge.data_ontology.FrameTransform.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/bridges/ros/custom_ontology/#mosaicolabs.ros_bridge.data_ontology.FrameTransform.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/bridges/ros/ros/","title":"ROS","text":""},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.ROSBridge","title":"mosaicolabs.ros_bridge.ROSBridge","text":"<p>               Bases: <code>Generic[T]</code></p> <p>A central registry and API for ROS message to Mosaico Ontology translation.</p> <p>The <code>ROSBridge</code> serves as the orchestration hub for the ROS Bridge system. It maintains  a global registry of all available <code>ROSAdapterBase</code> implementations and provides  the high-level API used to transform raw ROS message containers into strongly-typed  Mosaico <code>Message</code> objects.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.ROSBridge--key-responsibilities","title":"Key Responsibilities","text":"<ul> <li>Adapter Discovery: Provides methods to lookup adapters based on ROS message type strings (e.g., <code>sensor_msgs/msg/Imu</code>).</li> <li>Type Validation: Checks if a given ROS type or Mosaico Ontology class is currently supported by the bridge.</li> <li>Execution Dispatch: Acts as the primary entry point for the injection pipeline to delegate translation tasks to specific specialized adapters.</li> </ul> <p>Attributes:</p> Name Type Description <code>_adapters</code> <code>Dict[str, Type[ROSAdapterBase]]</code> <p>A private class-level dictionary mapping canonical ROS message type strings to their respective adapter classes.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.ROSBridge.get_adapter","title":"get_adapter  <code>classmethod</code>","text":"<pre><code>get_adapter(ros_msg_type)\n</code></pre> <p>Retrieves the registered adapter class for a given ROS message type.</p> <p>Parameters:</p> Name Type Description Default <code>ros_msg_type</code> <code>str</code> <p>The full ROS message type string (e.g., \"sensor_msgs/msg/Image\").</p> required <p>Returns:</p> Type Description <code>Optional[Type[ROSAdapterBase]]</code> <p>The corresponding <code>ROSAdapterBase</code> subclass if found, otherwise <code>None</code>.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.ROSBridge.is_msgtype_adapted","title":"is_msgtype_adapted  <code>classmethod</code>","text":"<pre><code>is_msgtype_adapted(ros_msg_type)\n</code></pre> <p>Checks if a specific ROS message type has a registered translator.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the type is supported, False otherwise.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.ROSBridge.is_adapted","title":"is_adapted  <code>classmethod</code>","text":"<pre><code>is_adapted(mosaico_cls)\n</code></pre> <p>Checks if a specific Mosaico Ontology class has a registered adapter.</p> <p>Parameters:</p> Name Type Description Default <code>mosaico_cls</code> <code>T</code> <p>The Mosaico class to check (e.g., <code>Image</code>, <code>Imu</code>).</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if an adapter exists for this class, False otherwise.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.ROSBridge.from_ros_message","title":"from_ros_message  <code>classmethod</code>","text":"<pre><code>from_ros_message(ros_msg, **kwargs)\n</code></pre> <p>The high-level API for translating raw ROS message containers.</p> <p>This method identifies the appropriate adapter based on the <code>msg_type</code> inside the <code>ROSMessage</code> and invokes its <code>translate</code> method. It is the core function called by the <code>RosbagInjector</code> during the ingestion loop.</p> Example <pre><code># Within an ingestion loop\nmosaico_msg = ROSBridge.from_ros_message(raw_ros_container)\nif mosaico_msg:\n    writer.push(mosaico_msg)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ros_msg</code> <code>ROSMessage</code> <p>The <code>ROSMessage</code> container produced by the <code>ROSLoader</code>.</p> required <code>**kwargs</code> <code>Any</code> <p>Arbitrary context arguments passed directly to the adapter's translate method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[Message]</code> <p>A fully constructed Mosaico <code>Message</code> if an adapter is available, otherwise <code>None</code>.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.register_adapter","title":"mosaicolabs.ros_bridge.register_adapter","text":"<pre><code>register_adapter(cls)\n</code></pre> <p>A class decorator for streamlined adapter registration.</p> <p>This is the recommended way to register adapters in a production environment, as it couples the adapter definition directly with its registration in the bridge.</p> Example <pre><code>from mosaicolabs.ros_bridge import register_adapter, ROSAdapterBase\n\n@register_adapter\nclass MySensorAdapter(ROSAdapterBase):\n    ros_msgtype = \"sensor_msgs/msg/Temperature\"\n    # ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>Type[ROSAdapterBase]</code> <p>The adapter class to register.</p> required <p>Returns:</p> Type Description <code>Type[ROSAdapterBase]</code> <p>The same class, unmodified, after successful registration.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.loader.ROSLoader","title":"mosaicolabs.ros_bridge.loader.ROSLoader","text":"<pre><code>ROSLoader(\n    file_path,\n    topics=None,\n    typestore_name=EMPTY,\n    error_policy=LOG_WARN,\n    custom_types=None,\n)\n</code></pre> <p>Unified loader for reading and deserializing ROS 1 (.bag) and ROS 2 (.mcap, .db3) data.</p> <p>The <code>ROSLoader</code> acts as a resource manager that abstracts the underlying <code>rosbags</code> library. It provides a standardized Pythonic interface for filtering topics, managing custom message registries, and streaming data into the Mosaico adaptation pipeline.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.loader.ROSLoader--key-features","title":"Key Features","text":"<ul> <li>Multi-Format Support: Automatically detects and handles ROS 1 and ROS 2 bag containers.</li> <li>Semantic Filtering: Supports glob-style patterns (e.g., <code>/sensors/*</code>) to load only relevant data channels.</li> <li>Dynamic Schema Resolution: Integrates with the <code>ROSTypeRegistry</code> to resolve proprietary message types on-the-fly.</li> <li>Memory Efficient: Implements a generator-based iteration pattern to process large bags without loading them into RAM.</li> </ul> <p>Attributes:</p> Name Type Description <code>ACCEPTED_EXTENSIONS</code> <p>Set of supported file extensions {'.bag', '.db3', '.mcap'}.</p> <p>Initializes the loader and prepares the type registry.</p> <p>Upon initialization, the loader merges the global definitions from the <code>ROSTypeRegistry</code> with any <code>custom_types</code> provided specifically for this session.</p> Example <pre><code>from rosbags.typesys import Stores\nfrom mosaicolabs.ros_bridge import ROSLoader, LoaderErrorPolicy\n\n# Initialize to read only IMU and GPS data from an MCAP file\nwith ROSLoader(\n    file_path=\"mission_01.mcap\",\n    topics=[\"/imu*\", \"/gps/fix\"],\n    typestore_name=Stores.ROS2_HUMBLE,\n    error_policy=LoaderErrorPolicy.RAISE\n) as loader:\n    for msg, exc in loader:\n        if not exc:\n            print(f\"Read {msg.msg_type} from {msg.topic}\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Union[str, Path]</code> <p>Path to the bag file or directory.</p> required <code>topics</code> <code>Optional[Union[str, List[str]]]</code> <p>A single topic name, a list of names, or glob patterns.</p> <code>None</code> <code>typestore_name</code> <code>Stores</code> <p>The target ROS distribution for default message schemas. See <code>rosbags.typesys.Stores</code>.</p> <code>EMPTY</code> <code>error_policy</code> <code>LoaderErrorPolicy</code> <p>How to handle errors during message iteration.</p> <code>LOG_WARN</code> <code>custom_types</code> <code>Optional[Dict[str, Union[str, Path]]]</code> <p>Local overrides for message definitions (type_name: path/to/msg).</p> <code>None</code>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.loader.ROSLoader.topics","title":"topics  <code>property</code>","text":"<pre><code>topics\n</code></pre> <p>Retrieves the list of canonical topic names that will be processed.</p> <p>This property returns the result of the \"Smart Filtering\" process, which resolves any glob patterns (e.g., <code>/camera/*</code>) provided during initialization against  the actual metadata contained within the bag file.</p> Example <pre><code>with ROSLoader(file_path=\"data.mcap\", topics=[\"/sensors/*\"]) as loader:\n    # If the bag contains /sensors/imu and /sensors/gps,\n    # this property returns ['/sensors/imu', '/sensors/gps']\n    print(f\"Loading topics: {loader.topics}\")\n</code></pre> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: A list of topic names currently matched and scheduled for loading.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.loader.ROSLoader.msg_types","title":"msg_types  <code>property</code>","text":"<pre><code>msg_types\n</code></pre> <p>Retrieves the list of ROS message types corresponding to the resolved topics.</p> <p>Each entry in this list represents the schema name (e.g., <code>sensor_msgs/msg/Image</code>) required to correctly deserialize the messages for the topics returned by the <code>.topics</code> property.</p> Example <pre><code>with ROSLoader(file_path=\"data.mcap\") as loader:\n    for topic, msg_type in zip(loader.topics, loader.msg_types):\n        print(f\"Topic {topic} requires schema: {msg_type}\")\n</code></pre> <p>Returns:</p> Type Description <code>List[str | None]</code> <p>List[str]: A list of ROS message type strings in the same order</p> <code>List[str | None]</code> <p>as the resolved topics.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.loader.ROSLoader.msg_count","title":"msg_count","text":"<pre><code>msg_count(topic=None)\n</code></pre> <p>Returns the total number of messages to be processed based on active filters.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>Optional[str]</code> <p>If provided, returns the count for that specific topic. If None, returns the aggregate count for all filtered topics.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The total message count.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.loader.ROSLoader.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Explicitly closes the bag file and releases system resources.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.loader.LoaderErrorPolicy","title":"mosaicolabs.ros_bridge.loader.LoaderErrorPolicy","text":"<p>               Bases: <code>Enum</code></p> <p>Defines the strategy for handling deserialization failures during bag playback.</p> <p>In heterogeneous datasets, it is common to encounter corrupted messages or missing type definitions for specific topics. This policy allows the user to balance system robustness against data integrity.</p> <p>Attributes:</p> Name Type Description <code>IGNORE</code> <p>Silently skips any message that fails to deserialize. The pipeline continues uninterrupted without any log output.</p> <code>LOG_WARN</code> <p>(Default) Logs a warning containing the topic name and error details, then skips the message and continues.</p> <code>RAISE</code> <p>Immediately halts execution and raises the exception. Best used for critical data ingestion where missing even a single record is unacceptable.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.loader.LoaderErrorPolicy.IGNORE","title":"IGNORE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IGNORE = 'ignore'\n</code></pre> <p>Silently skips any message that fails to deserialize.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.loader.LoaderErrorPolicy.LOG_WARN","title":"LOG_WARN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LOG_WARN = 'log_warn'\n</code></pre> <p>Logs a warning containing the topic name and error details, then skips the message and continues.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.loader.LoaderErrorPolicy.RAISE","title":"RAISE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RAISE = 'raise'\n</code></pre> <p>Immediately halts execution and raises the exception. Best used for critical data ingestion where missing even a single record is unacceptable.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.ROSMessage","title":"mosaicolabs.ros_bridge.ROSMessage  <code>dataclass</code>","text":"<pre><code>ROSMessage(bag_timestamp_ns, topic, msg_type, data)\n</code></pre> <p>The standardized container for a single ROS message record yielded by the loader.</p> <p>This object serves as the primary \"unit of work\" within the ROS Bridge pipeline. It encapsulates the raw deserialized payload along with essential storage-level metadata needed for accurate platform ingestion.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.ROSMessage--life-cycle","title":"Life Cycle","text":"<ol> <li>Produced by <code>ROSLoader</code> during bag iteration.</li> <li>Consumed by <code>ROSBridge</code> to identify the correct adapter.</li> <li>Translated by a <code>ROSAdapter</code> into a Mosaico <code>Message</code>.</li> </ol> Example <pre><code># Manual construction (usually handled by the loader)\nmsg = ROSMessage(\n    bag_timestamp_ns=1625000000000000000,\n    topic=\"/odom\",\n    msg_type=\"nav_msgs/msg/Odometry\",\n    data={\"header\": {...}, \"pose\": {...}}\n)\n\nprint(f\"Processing {msg.msg_type} from {msg.topic}\")\nif msg.header:\n    print(f\"Frame: {msg.header.frame_id}\")\n</code></pre> <p>Attributes:</p> Name Type Description <code>bag_timestamp_ns</code> <code>int</code> <p>Timestamp (nanoseconds) when the message was recorded to the bag file. This is the \"storage time\".</p> <code>topic</code> <code>str</code> <p>The specific topic string source (e.g., \"/camera/left/image_raw\").</p> <code>msg_type</code> <code>str</code> <p>The canonical ROS type string (e.g., \"sensor_msgs/msg/Image\").</p> <code>data</code> <code>Optional[Dict[str, Any]]</code> <p>The message payload converted into a standard nested Python dictionary.</p> <code>header</code> <code>Optional[ROSHeader]</code> <p>An automatically parsed <code>ROSHeader</code> if the <code>data</code> payload contains a valid header field.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.ROSMessage.bag_timestamp_ns","title":"bag_timestamp_ns  <code>instance-attribute</code>","text":"<pre><code>bag_timestamp_ns\n</code></pre> <p>Timestamp (nanoseconds) when the message was written to the rosbag. This corresponds to the rosbag storage time and may differ from the time the data was originally generated.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.ROSMessage.topic","title":"topic  <code>instance-attribute</code>","text":"<pre><code>topic\n</code></pre> <p>The topic string of the message source.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.ROSMessage.msg_type","title":"msg_type  <code>instance-attribute</code>","text":"<pre><code>msg_type\n</code></pre> <p>The message ros type string.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.ROSMessage.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data\n</code></pre> <p>The message payload, converted into a standard nested Python dictionary.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.ROSMessage.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>The message payload header</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.ROSInjectionConfig","title":"mosaicolabs.ros_bridge.ROSInjectionConfig  <code>dataclass</code>","text":"<pre><code>ROSInjectionConfig(\n    file_path,\n    sequence_name,\n    metadata,\n    host=\"localhost\",\n    port=6726,\n    ros_distro=None,\n    on_error=Delete,\n    custom_msgs=None,\n    topics=None,\n    log_level=\"INFO\",\n)\n</code></pre> <p>The central configuration object for the ROS Bag injection process.</p> <p>This data class serves as the single source of truth for all injection settings, decoupling the orchestration logic from CLI arguments or configuration files. It encapsulates network parameters, file paths, and advanced filtering logic required to drive a successful ingestion session.</p> <p>Attributes:</p> Name Type Description <code>file_path</code> <code>Path</code> <p>Absolute or relative path to the input ROS bag file (.mcap, .db3, or .bag).</p> <code>sequence_name</code> <code>str</code> <p>The name for the new sequence to be created on the Mosaico server.</p> <code>metadata</code> <code>dict</code> <p>User-defined metadata to attach to the sequence (e.g., driver, weather, location).</p> <code>host</code> <code>str</code> <p>Hostname or IP of the Mosaico server. Defaults to \"localhost\".</p> <code>port</code> <code>int</code> <p>Port of the Mosaico server. Defaults to 6726.</p> <code>ros_distro</code> <code>Optional[Stores]</code> <p>The target ROS distribution for message parsing (e.g., Stores.ROS2_HUMBLE). See <code>rosbags.typesys.Stores</code>.</p> <code>on_error</code> <code>OnErrorPolicy</code> <p>Behavior when an ingestion error occurs (Delete the partial sequence or Report the error).</p> <code>custom_msgs</code> <code>Optional[List[Tuple]]</code> <p>List of custom .msg definitions to register before loading.</p> <code>topics</code> <code>Optional[List[str]]</code> <p>List of topics to filter, supporting glob patterns (e.g., [\"/cam/*\"]).</p> <code>log_level</code> <code>str</code> <p>Logging verbosity level (\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\").</p> Example <pre><code>from pathlib import Path\nfrom rosbags.typesys import Stores\nfrom mosaicolabs.enum import OnErrorPolicy\nfrom mosaicolabs.ros_bridge import ROSInjectionConfig\n\nconfig = ROSInjectionConfig(\n    file_path=Path(\"recording.mcap\"),\n    sequence_name=\"test_drive_01\",\n    metadata={\"environment\": \"urban\", \"vehicle\": \"robot_alpha\"},\n    ros_distro=Stores.ROS2_FOXY,\n    on_error=OnErrorPolicy.Delete\n)\n</code></pre>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.ROSInjectionConfig.ros_distro","title":"ros_distro  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ros_distro = None\n</code></pre> <p>The specific ROS distribution to use for message parsing (e.g., Stores.ROS2_HUMBLE). If None, defaults to Empty/Auto.</p> <p>See <code>rosbags.typesys.Stores</code>.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.ROSInjectionConfig.on_error","title":"on_error  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>on_error = Delete\n</code></pre> <p>the <code>SequenceWriter</code> <code>on_error</code> behavior when a sequence write fails (Report vs Delete)</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.ROSInjectionConfig.custom_msgs","title":"custom_msgs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>custom_msgs = None\n</code></pre> <p>A list of tuples (package_name, path, store) to register custom .msg definitions before loading.</p> <p>For example, for \"my_robot_msgs/msg/Location\" pass: </p> <p>package_name = \"my_robot_msgs\"; path = path/to/Location.msg; store = Stores.ROS2_HUMBLE (e.g.) or None</p> <p>See <code>rosbags.typesys.Stores</code>.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.ROSInjectionConfig.topics","title":"topics  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>topics = None\n</code></pre> <p>A list of specific topics to filter (supports glob patterns). If None, all compatible topics are loaded.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.RosbagInjector","title":"mosaicolabs.ros_bridge.RosbagInjector","text":"<pre><code>RosbagInjector(config)\n</code></pre> <p>Main controller for the ROS Bag ingestion workflow.</p> <p>The <code>RosbagInjector</code> orchestrates the entire data pipeline from the physical storage to the remote Mosaico server. It manages the initialization of the registry, establishes network connections, and drives the main adaptation loop.</p> <p>Core Workflow Architecture:</p> <ol> <li>Registry Initialization: Pre-loads custom message definitions via the <code>ROSTypeRegistry</code>.</li> <li>Resource Management: Opens the <code>ROSLoader</code> for file access and the <code>MosaicoClient</code> for networking.</li> <li>Stream Negotiation: Creates a <code>SequenceWriter</code> on the server and opens individual <code>TopicWriter</code> streams.</li> <li>Adaptation Loop: Iterates through ROS records, translates them via the <code>ROSBridge</code>, and pushes them to the server.</li> </ol> Example <pre><code>from mosaicolabs.ros_bridge import RosbagInjector, ROSInjectionConfig\n\n# Define configuration\nconfig = ROSInjectionConfig(file_path=Path(\"data.db3\"), sequence_name=\"auto_ingest\")\n\n# Initialize and run\ninjector = RosbagInjector(config)\ninjector.run() # This handles the full lifecycle including cleanup on failure\n</code></pre> <p>Attributes:</p> Name Type Description <code>cfg</code> <code>ROSInjectionConfig</code> <p>The active configuration settings.</p> <code>console</code> <code>Console</code> <p>The rich console instance for logging and UI output.</p> <code>_ignored_topics</code> <code>Set[str]</code> <p>Cache of topics that lack a compatible adapter, used for fast-fail filtering.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ROSInjectionConfig</code> <p>The fully resolved configuration object.</p> required"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.RosbagInjector.run","title":"run","text":"<pre><code>run()\n</code></pre> <p>Main execution entry point for the injection pipeline.</p> <p>This method establishes the necessary contexts (Network Client, File Loader, Server Writer) and executes the processing loop. It handles graceful shutdowns in case of user interrupts and provides a summary report upon completion.</p> <p>Raises:</p> Type Description <code>KeyboardInterrupt</code> <p>If the user cancels the operation via Ctrl+C.</p> <code>Exception</code> <p>Any fatal error encountered during networking or file access.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.ROSTypeRegistry","title":"mosaicolabs.ros_bridge.ROSTypeRegistry","text":"<p>A context-aware singleton registry for custom ROS message definitions.</p> <p>ROS message definitions (<code>.msg</code>) are not self-contained; they often vary between distributions (e.g., <code>std_msgs/Header</code> has different fields in ROS 1 Noetic vs. ROS 2 Humble). The <code>ROSTypeRegistry</code> resolves this by implementing a Context-Aware Singleton that organizes schemas into \"Profiles\" (<code>rosbags.typesys.Stores</code>).</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.ROSTypeRegistry--why-use-a-registry","title":"Why Use a Registry?","text":"<ul> <li>Conflict Resolution: Prevents name collisions when processing data from mixed ROS 1 and ROS 2 sources in the same environment.</li> <li>Proprietary Support: Allows the system to ingest non-standard messages (e.g., custom robot state or specialized sensor payloads).</li> <li>Cascading Logic: Implements an \"Overlay\" mechanism where global definitions provide a baseline, and distribution-specific definitions provide high-precision overrides.</li> </ul> <p>Attributes:</p> Name Type Description <code>_registry</code> <code>Dict[str, Dict[str, str]]</code> <p>Internal private storage for definitions. The first key level represents the Scope (e.g., \"GLOBAL\", \"Stores.ROS2_FOXY\"), and the second level maps the Message Type to its raw Definition String.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.ROSTypeRegistry.register","title":"register  <code>classmethod</code>","text":"<pre><code>register(msg_type, source, store=None)\n</code></pre> <p>Registers a single custom message type into the registry.</p> <p>This is the primary method for adding individual schema definitions. The <code>source</code> can be a physical file path or a raw string containing the ROS <code>.msg</code> syntax.</p> Example <pre><code># Register a proprietary battery message for a specific distro\nROSTypeRegistry.register(\n    msg_type=\"limo_msgs/msg/BatteryState\",\n    source=Path(\"./msgs/BatteryState.msg\"),\n    store=Stores.ROS2_HUMBLE\n)\n\n# Register a simple custom type globally using a raw string\nROSTypeRegistry.register(\n    msg_type=\"custom_msgs/msg/SimpleFlag\",\n    source=\"bool flag_active\\nstring label\"\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>msg_type</code> <code>str</code> <p>The canonical ROS type name (e.g., \"package/msg/TypeName\").</p> required <code>source</code> <code>Union[str, Path]</code> <p>A <code>Path</code> object to a <code>.msg</code> file or a raw text string of the definition.</p> required <code>store</code> <code>Optional[Union[Stores, str]]</code> <p>The target scope. If <code>None</code>, the definition is stored in the GLOBAL profile and becomes available to all loaders regardless of their distribution.</p> <code>None</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If <code>source</code> is a <code>Path</code> that does not exist on the filesystem.</p> <code>TypeError</code> <p>If the <code>source</code> is neither a <code>str</code> nor a <code>Path</code>.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.ROSTypeRegistry.register_directory","title":"register_directory  <code>classmethod</code>","text":"<pre><code>register_directory(package_name, dir_path, store=None)\n</code></pre> <p>Batch registers all <code>.msg</code> files found within a specified directory.</p> <p>This helper is essential for ingesting entire ROS packages. It automatically infers the full ROS type name by combining the <code>package_name</code> with the filename (e.g., <code>Status.msg</code> becomes <code>package_name/msg/Status</code>).</p> Example <pre><code># Register all messages in a local workspace for ROS1\nROSTypeRegistry.register_directory(\n    package_name=\"robot_logic\",\n    dir_path=\"./src/robot_logic/msg\",\n    store=Stores.ROS1_NOETIC\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>package_name</code> <code>str</code> <p>The name of the ROS package to use as a prefix.</p> required <code>dir_path</code> <code>Union[str, Path]</code> <p>The filesystem path to the directory containing <code>.msg</code> files.</p> required <code>store</code> <code>Optional[Union[Stores, str]]</code> <p>The target distribution scope for the entire directory.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>dir_path</code> does not point to a valid directory.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.ROSTypeRegistry.get_types","title":"get_types  <code>classmethod</code>","text":"<pre><code>get_types(store)\n</code></pre> <p>Retrieves a merged view of message definitions for a specific distribution.</p> <p>This method implements the Registry Cascade: 1. It starts with a base layer of all GLOBAL definitions. 2. It overlays (overwrites) those with any Store-Specific definitions matching    the provided <code>store</code> parameter.</p> <p>This ensures that distribution-specific nuances are respected while maintaining access to shared custom types.</p> <p>Parameters:</p> Name Type Description Default <code>store</code> <code>Optional[Union[Stores, str]]</code> <p>The distribution identifier (e.g., <code>Stores.ROS2_HUMBLE</code>) to fetch overrides for.</p> required <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>A flat dictionary mapping <code>msg_type</code> to <code>definition</code>, formatted for</p> <code>Dict[str, str]</code> <p>direct injection into <code>rosbags</code> high-level readers.</p>"},{"location":"SDK/API_reference/bridges/ros/ros/#mosaicolabs.ros_bridge.ROSTypeRegistry.reset","title":"reset  <code>classmethod</code>","text":"<pre><code>reset()\n</code></pre> <p>Completely clears the singleton registry.</p> <p>This is primarily used for Unit Testing and CI/CD pipelines to ensure total isolation between different test cases.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/base/","title":"Base Adapter","text":""},{"location":"SDK/API_reference/bridges/ros/adapters/base/#mosaicolabs.ros_bridge.adapter_base","title":"mosaicolabs.ros_bridge.adapter_base","text":""},{"location":"SDK/API_reference/bridges/ros/adapters/base/#mosaicolabs.ros_bridge.adapter_base.ROSAdapterBase","title":"ROSAdapterBase","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Abstract Base Class for converting ROS messages to Mosaico Ontology types.</p> <p>The Adaptation Layer is the semantic core of the ROS Bridge. Rather than performing simple parsing, adapters actively translate raw ROS data into standardized, strongly-typed Mosaico Ontology objects.</p> <p>Attributes:</p> Name Type Description <code>ros_msgtype</code> <code>str | Tuple[str, ...]</code> <p>The ROS message type string (e.g., 'sensor_msgs/msg/Imu') or a tuple of supported types.</p> <code>__mosaico_ontology_type__</code> <code>Type[T]</code> <p>The target Mosaico class (e.g., IMU).</p> <code>_REQUIRED_KEYS</code> <code>Tuple[str, ...]</code> <p>Internal validation list for mandatory ROS message fields.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/base/#mosaicolabs.ros_bridge.adapter_base.ROSAdapterBase.ros_msg_type","title":"ros_msg_type  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>ros_msg_type()\n</code></pre> <p>Returns the specific ROS message type handled by this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/base/#mosaicolabs.ros_bridge.adapter_base.ROSAdapterBase.translate","title":"translate  <code>classmethod</code>","text":"<pre><code>translate(ros_msg, **kwargs)\n</code></pre> <p>Translates a ROS message instance into a Mosaico Message.</p> <p>Implementation should handle recursive unwrapping, unit conversion, and validation.</p> <p>Parameters:</p> Name Type Description Default <code>ros_msg</code> <code>ROSMessage</code> <p>The source container yielded by the ROSLoader.</p> required <code>**kwargs</code> <code>Any</code> <p>Contextual data such as calibration parameters or frame overrides.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Message</code> <p>A Mosaico Message object containing the instantiated ontology data.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/base/#mosaicolabs.ros_bridge.adapter_base.ROSAdapterBase.from_dict","title":"from_dict  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>from_dict(ros_data)\n</code></pre> <p>Maps the raw ROS dictionary to the EncoderTicks Pydantic model.</p> <p>This method performs field validation and header reconstruction.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/base/#mosaicolabs.ros_bridge.adapter_base.ROSAdapterBase.schema_metadata","title":"schema_metadata  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>schema_metadata(ros_data, **kwargs)\n</code></pre> <p>Extracts ROS-specific schema metadata for the Mosaico platform.</p> <p>This allows preserving original ROS attributes that may not fit directly into the physical ontology fields.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/base/#mosaicolabs.ros_bridge.adapter_base.ROSAdapterBase.ontology_data_type","title":"ontology_data_type  <code>classmethod</code>","text":"<pre><code>ontology_data_type()\n</code></pre> <p>Returns the Ontology class type associated with this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/","title":"geometry_msgs","text":""},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs","title":"mosaicolabs.ros_bridge.adapters.geometry_msgs","text":"<p>Geometry Messages Adaptation Module.</p> <p>This module provides specialized adapters for translating ROS <code>geometry_msgs</code> into the standardized Mosaico Ontology. It implements recursive unwrapping to handle common ROS patterns, such as \"Stamped\" envelopes and covariance wrappers, ensuring that spatial data is normalized before ingestion.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.PoseAdapter","title":"PoseAdapter","text":"<p>               Bases: <code>ROSAdapterBase[Pose]</code></p> <p>Adapter for translating ROS Pose-related messages to Mosaico <code>Pose</code>.</p> <p>This adapter follows the \"Adaptation, Not Just Parsing\" philosophy by actively unwrapping nested ROS structures and normalizing them into strongly-typed Mosaico <code>Pose</code> objects.</p> <p>Supported ROS Types:</p> <ul> <li><code>geometry_msgs/msg/Pose</code></li> <li><code>geometry_msgs/msg/PoseStamped</code></li> <li><code>geometry_msgs/msg/PoseWithCovariance</code></li> <li><code>geometry_msgs/msg/PoseWithCovarianceStamped</code></li> </ul> <p>Recursive Unwrapping Strategy: The adapter checks for nested <code>'pose'</code> keys. If found (as in <code>PoseStamped</code>), it recurses to the leaf node while collecting metadata like headers and covariance matrices along the way.</p> Example <pre><code># Internal usage within the ROS Bridge\nros_msg = ROSMessage(\n    timestamp=17000,\n    topic=\"/pose\",\n    msg_type=\"geometry_msgs/msg/PoseStamped\",\n    data={\n        \"header\": {\"frame_id\": \"map\", \"stamp\": {\"sec\": 17000, \"nanosec\": 0}},\n        \"pose\": {\n            \"position\": {\"x\": 1.0, \"y\": 2.0, \"z\": 0.0},\n            \"orientation\": {\"x\": 0, \"y\": 0, \"z\": 0, \"w\": 1}\n        },\n    }\n}\n# Automatically resolves to a flat Mosaico Pose with attached metadata\nmosaico_pose = PoseAdapter.translate(ros_msg)\n</code></pre>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.PoseAdapter.translate","title":"translate  <code>classmethod</code>","text":"<pre><code>translate(ros_msg, **kwargs)\n</code></pre> <p>Main entry point for translating a high-level <code>ROSMessage</code>.</p> <p>Parameters:</p> Name Type Description Default <code>ros_msg</code> <code>ROSMessage</code> <p>The source ROS message yielded by the loader.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional context for the translation.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Message</code> <p>A Mosaico <code>Message</code> containing the normalized <code>Pose</code> payload.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.PoseAdapter.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(ros_data)\n</code></pre> <p>Recursively parses a dictionary to extract a <code>Pose</code> object.</p> <p>Strategy:</p> <ul> <li>Recurse: If a 'pose' key is found, dive deeper into the structure.</li> <li>Leaf Node: At the base level, map 'position' and 'orientation' to    <code>Point3d</code> and    <code>Quaternion</code>.</li> <li>Metadata Binding: Headers and covariances are attached during    recursion unwinding.</li> </ul> Example <pre><code>ros_data=\n{\n    \"header\": {\"frame_id\": \"map\", \"stamp\": {\"sec\": 17000, \"nanosec\": 0}},\n    \"pose\": {\n        \"position\": {\"x\": 1.0, \"y\": 2.0, \"z\": 0.0},\n        \"orientation\": {\"x\": 0, \"y\": 0, \"z\": 0, \"w\": 1}\n    },\n}\n# Automatically resolves to a flat Mosaico Pose with attached metadata\nmosaico_pose = PoseAdapter.from_dict(ros_data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ros_data</code> <code>dict</code> <p>The raw dictionary from the ROS message.</p> required <p>Returns:</p> Name Type Description <code>Pose</code> <code>Pose</code> <p>The constructed Mosaico Pose object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the recursive 'pose' key exists but is not a dict, or if required keys are missing.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.PoseAdapter.ros_msg_type","title":"ros_msg_type  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>ros_msg_type()\n</code></pre> <p>Returns the specific ROS message type handled by this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.PoseAdapter.schema_metadata","title":"schema_metadata  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>schema_metadata(ros_data, **kwargs)\n</code></pre> <p>Extracts ROS-specific schema metadata for the Mosaico platform.</p> <p>This allows preserving original ROS attributes that may not fit directly into the physical ontology fields.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.PoseAdapter.ontology_data_type","title":"ontology_data_type  <code>classmethod</code>","text":"<pre><code>ontology_data_type()\n</code></pre> <p>Returns the Ontology class type associated with this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.TwistAdapter","title":"TwistAdapter","text":"<p>               Bases: <code>ROSAdapterBase[Velocity]</code></p> <p>Adapter for translating ROS Twist-related messages to Mosaico <code>Velocity</code>.</p> <p>Commonly referred to as a \"Twist,\" this model captures the instantaneous motion of an object split into linear and angular components.</p> <p>Supported ROS Types:</p> <ul> <li><code>geometry_msgs/msg/Twist</code></li> <li><code>geometry_msgs/msg/TwistStamped</code></li> <li><code>geometry_msgs/msg/TwistWithCovariance</code></li> <li><code>geometry_msgs/msg/TwistWithCovarianceStamped</code></li> </ul> <p>Recursive Unwrapping Strategy: The adapter checks for nested <code>'twist'</code> keys. If found (as in <code>TwistStamped</code>), it recurses to the leaf node while collecting metadata like headers and covariance matrices along the way.</p> Example <pre><code>ros_msg= ROSMessage(\n    timestamp=1700000000000,\n    topic=\"/cmd_vel\",\n    msg_type=\"geometry_msgs/msg/TwistStamped\",\n    data=\n    {\n        \"header\": {\"frame_id\": \"map\", \"stamp\": {\"sec\": 17000, \"nanosec\": 0}},\n        \"twist\": {\n            \"linear\": {\"x\": 5.0, \"y\": 0.0, \"z\": 0.0},\n            \"angular\": {\"x\": 0.0, \"y\": 0.0, \"z\": 1.0}\n    },\n    \"covariance\": [0.1] * 36\n)\n# Automatically resolves to a flat Mosaico Velocity with attached metadata\nmosaico_velocity = TwistAdapter.translate(ros_msg)\n</code></pre>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.TwistAdapter.translate","title":"translate  <code>classmethod</code>","text":"<pre><code>translate(ros_msg, **kwargs)\n</code></pre> <p>Translates a ROS message into a Mosaico Message.</p> <p>Returns:</p> Name Type Description <code>Message</code> <code>Message</code> <p>The translated message containing a <code>Velocity</code> object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Wraps any translation error with context (topic name, timestamp).</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.TwistAdapter.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(ros_data)\n</code></pre> <p>Recursively parses the ROS data dictionary to extract a <code>Velocity</code> (Twist).</p> <p>Strategy: -  Recurse: If a 'twist' key is found, dive deeper into the structure. -  Leaf Node: At the base level, map 'linear' and 'angular' to    <code>Vector3</code>. -  Metadata Binding: Headers and covariances are attached during    recursion unwinding.</p> Example <pre><code>ros_data=\n{\n    \"header\": {\"frame_id\": \"map\", \"stamp\": {\"sec\": 17000, \"nanosec\": 0}},\n    \"twist\": {\n        \"linear\": {\"x\": 5.0, \"y\": 0.0, \"z\": 0.0},\n        \"angular\": {\"x\": 0.0, \"y\": 0.0, \"z\": 1.0}\n    },\n    \"covariance\": [0.1] * 36\n}\n# Automatically resolves to a flat Mosaico Velocity with attached metadata\nmosaico_velocity = TwistAdapter.from_dict(ros_data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ros_data</code> <code>dict</code> <p>The raw dictionary from the ROS message.</p> required <p>Returns:</p> Name Type Description <code>Velocity</code> <code>Velocity</code> <p>The constructed Mosaico Velocity object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the recursive 'twist' key exists but is not a dict, or if required keys are missing.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.TwistAdapter.ros_msg_type","title":"ros_msg_type  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>ros_msg_type()\n</code></pre> <p>Returns the specific ROS message type handled by this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.TwistAdapter.ontology_data_type","title":"ontology_data_type  <code>classmethod</code>","text":"<pre><code>ontology_data_type()\n</code></pre> <p>Returns the Ontology class type associated with this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.AccelAdapter","title":"AccelAdapter","text":"<p>               Bases: <code>ROSAdapterBase[Acceleration]</code></p> <p>Adapter for translating ROS Accel-related messages to Mosaico <code>Acceleration</code>.</p> <p>Supported ROS Types:</p> <ul> <li><code>geometry_msgs/msg/Accel</code></li> <li><code>geometry_msgs/msg/AccelStamped</code></li> <li><code>geometry_msgs/msg/AccelWithCovariance</code></li> <li><code>geometry_msgs/msg/AccelWithCovarianceStamped</code></li> </ul> <p>Recursive Unwrapping Strategy: The adapter checks for nested <code>'accel'</code> keys. If found (as in <code>AccelStamped</code>), it recurses to the leaf node while collecting metadata like headers and covariance matrices along the way.</p> Example <pre><code>ros_msg = ROSMessage(\n    topic=\"/accel\",\n    timestamp=17000,\n    msg_type=\"geometry_msgs/msg/AccelStamped\",\n    data=\n    {\n        \"header\": {\"frame_id\": \"map\", \"stamp\": {\"sec\": 17000, \"nanosec\": 0}},\n        \"accel\": {\n            \"linear\": {\"x\": 5.0, \"y\": 0.0, \"z\": 0.0},\n            \"angular\": {\"x\": 0.0, \"y\": 0.0, \"z\": 1.0}\n        },\n        \"covariance\": [0.1] * 36\n    }\n# Automatically resolves to a flat Mosaico Acceleration with attached metadata\nmosaico_acceleration = AccelAdapter.translate(ros_msg)\n</code></pre>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.AccelAdapter.translate","title":"translate  <code>classmethod</code>","text":"<pre><code>translate(ros_msg, **kwargs)\n</code></pre> <p>Translates a ROS message into a Mosaico Message.</p> <p>Returns:</p> Name Type Description <code>Message</code> <code>Message</code> <p>The translated message containing a <code>Acceleration</code> object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Wraps any translation error with context (topic name, timestamp).</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.AccelAdapter.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(ros_data)\n</code></pre> <p>Recursively parses the ROS data dictionary to extract an <code>Acceleration</code>.</p> <p>Strategy: -  Recurse: If a 'accel' key is found, dive deeper into the structure. -  Leaf Node: At the base level, map 'linear' and 'angular' to    <code>Vector3</code>. -  Metadata Binding: Headers and covariances are attached during    recursion unwinding.</p> Example <pre><code>ros_data=\n{\n    \"header\": {\"frame_id\": \"map\", \"stamp\": {\"sec\": 17000, \"nanosec\": 0}},\n    \"accel\": {\n        \"linear\": {\"x\": 5.0, \"y\": 0.0, \"z\": 0.0},\n        \"angular\": {\"x\": 0.0, \"y\": 0.0, \"z\": 1.0}\n    },\n    \"covariance\": [0.1] * 36\n}\n# Automatically resolves to a flat Mosaico Acceleration with attached metadata\nmosaico_acceleration = AccelAdapter.from_dict(ros_data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ros_data</code> <code>dict</code> <p>The raw dictionary from the ROS message.</p> required <p>Returns:</p> Name Type Description <code>Acceleration</code> <code>Acceleration</code> <p>The constructed Mosaico Acceleration object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the recursive 'accel' key exists but is not a dict, or if required keys are missing.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.AccelAdapter.ros_msg_type","title":"ros_msg_type  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>ros_msg_type()\n</code></pre> <p>Returns the specific ROS message type handled by this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.AccelAdapter.ontology_data_type","title":"ontology_data_type  <code>classmethod</code>","text":"<pre><code>ontology_data_type()\n</code></pre> <p>Returns the Ontology class type associated with this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.Vector3Adapter","title":"Vector3Adapter","text":"<p>               Bases: <code>ROSAdapterBase[Vector3d]</code></p> <p>Adapter for translating ROS Vector3 messages to Mosaico <code>Vector3d</code>.</p> <p>Supported ROS Types:</p> <ul> <li><code>geometry_msgs/msg/Vector3</code></li> <li><code>geometry_msgs/msg/Vector3Stamped</code></li> </ul> <p>Recursive Unwrapping Strategy: The adapter checks for nested <code>'vector'</code> keys. If found (as in <code>Vector3Stamped</code>), it recurses to the leaf node while collecting metadata like headers and covariance matrices along the way.</p> Example <pre><code>ros_msg = ROSMessage(\n    topic=\"/vector3\",\n    timestamp=17000,\n    msg_type=\"geometry_msgs/msg/Vector3Stamped\",\n    data=\n    {\n        \"header\": {\"frame_id\": \"map\", \"stamp\": {\"sec\": 17000, \"nanosec\": 0}},\n        \"vector\": {\"x\": 5.0, \"y\": 0.0, \"z\": 0.0},\n    }\n# Automatically resolves to a flat Mosaico Vector3 with attached metadata\nmosaico_vector3 = Vector3Adapter.translate(ros_msg)\n</code></pre>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.Vector3Adapter.translate","title":"translate  <code>classmethod</code>","text":"<pre><code>translate(ros_msg, **kwargs)\n</code></pre> <p>Translates a ROS message into a Mosaico Message.</p> <p>Returns:</p> Name Type Description <code>Message</code> <code>Message</code> <p>The translated message containing a <code>Vector3d</code> object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Wraps any translation error with context (topic name, timestamp).</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.Vector3Adapter.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(ros_data)\n</code></pre> <p>Recursively parses the ROS data to extract a <code>Vector3d</code>.</p> <p>Strategy: -  Recurse: If a 'vector' key is found, dive deeper into the structure. -  Leaf Node: At the base level, map 'x', 'y' and 'z' to    <code>Vector3d</code>. -  Metadata Binding: Headers and covariances are attached during    recursion unwinding.</p> Example <pre><code>ros_data=\n{\n    \"header\": {\"frame_id\": \"map\", \"stamp\": {\"sec\": 17000, \"nanosec\": 0}},\n    \"vector\": {\"x\": 5.0, \"y\": 0.0, \"z\": 0.0},\n}\n# Automatically resolves to a flat Mosaico Vector3d with attached metadata\nmosaico_vector3d = Vector3Adapter.from_dict(ros_data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ros_data</code> <code>dict</code> <p>The raw dictionary from the ROS message.</p> required <p>Returns:</p> Name Type Description <code>Vector3d</code> <code>Vector3d</code> <p>The constructed Mosaico Vector3d object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the recursive 'vector' key exists but is not a dict, or if required keys are missing.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.Vector3Adapter.ros_msg_type","title":"ros_msg_type  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>ros_msg_type()\n</code></pre> <p>Returns the specific ROS message type handled by this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.Vector3Adapter.ontology_data_type","title":"ontology_data_type  <code>classmethod</code>","text":"<pre><code>ontology_data_type()\n</code></pre> <p>Returns the Ontology class type associated with this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.PointAdapter","title":"PointAdapter","text":"<p>               Bases: <code>ROSAdapterBase[Point3d]</code></p> <p>Adapter for translating ROS Point messages to Mosaico <code>Point3d</code>.</p> <p>Supported ROS Types:</p> <ul> <li><code>geometry_msgs/msg/Point</code></li> <li><code>geometry_msgs/msg/PointStamped</code></li> </ul> <p>Recursive Unwrapping Strategy: The adapter checks for nested <code>'point'</code> keys. If found (as in <code>PointStamped</code>), it recurses to the leaf node while collecting metadata like headers and covariance matrices along the way.</p> Example <pre><code>ros_msg = ROSMessage(\n    topic=\"/point\",\n    timestamp=17000,\n    msg_type=\"geometry_msgs/msg/PointStamped\",\n    data=\n    {\n        \"header\": {\"frame_id\": \"map\", \"stamp\": {\"sec\": 17000, \"nanosec\": 0}},\n        \"point\": {\"x\": 5.0, \"y\": 0.0, \"z\": 0.0},\n    }\n# Automatically resolves to a flat Mosaico Point3d with attached metadata\nmosaico_point3d = PointAdapter.translate(ros_msg)\n</code></pre>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.PointAdapter.translate","title":"translate  <code>classmethod</code>","text":"<pre><code>translate(ros_msg, **kwargs)\n</code></pre> <p>Translates a ROS message into a Mosaico Message.</p> <p>Returns:</p> Name Type Description <code>Message</code> <code>Message</code> <p>The translated message containing a <code>Point3d</code> object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Wraps any translation error with context (topic name, timestamp).</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.PointAdapter.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(ros_data)\n</code></pre> <p>Recursively parses the ROS data to extract a <code>Point3d</code>.</p> Strategy <ul> <li>Recurse: If a 'point' key is found, dive deeper into the structure.</li> <li>Leaf Node: At the base level, map 'x', 'y' and 'z' to    <code>Point3d</code>.</li> <li>Metadata Binding: Headers and covariances are attached during    recursion unwinding.</li> </ul> Example <pre><code>ros_data=\n{\n    \"header\": {\"frame_id\": \"map\", \"stamp\": {\"sec\": 17000, \"nanosec\": 0}},\n    \"point\": {\"x\": 5.0, \"y\": 0.0, \"z\": 0.0},\n}\n# Automatically resolves to a flat Mosaico Point3d with attached metadata\nmosaico_point3d = PointAdapter.from_dict(ros_data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ros_data</code> <code>dict</code> <p>The raw dictionary from the ROS message.</p> required <p>Returns:</p> Name Type Description <code>Point3d</code> <code>Point3d</code> <p>The constructed Mosaico Point3d object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the recursive 'point' key exists but is not a dict, or if required keys are missing.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.PointAdapter.ros_msg_type","title":"ros_msg_type  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>ros_msg_type()\n</code></pre> <p>Returns the specific ROS message type handled by this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.PointAdapter.ontology_data_type","title":"ontology_data_type  <code>classmethod</code>","text":"<pre><code>ontology_data_type()\n</code></pre> <p>Returns the Ontology class type associated with this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.QuaternionAdapter","title":"QuaternionAdapter","text":"<p>               Bases: <code>ROSAdapterBase[Quaternion]</code></p> <p>Adapter for translating ROS Quaternion messages to Mosaico <code>Quaternion</code>.</p> <p>Supported ROS Types:</p> <ul> <li><code>geometry_msgs/msg/Quaternion</code></li> <li><code>geometry_msgs/msg/QuaternionStamped</code></li> </ul> <p>Recursive Unwrapping Strategy: The adapter checks for nested <code>'quaternion'</code> keys. If found (as in <code>QuaternionStamped</code>), it recurses to the leaf node while collecting metadata like headers and covariance matrices along the way.</p> Example <pre><code>ros_msg = ROSMessage(\n    topic=\"/quaternion\",\n    timestamp=17000,\n    msg_type=\"geometry_msgs/msg/QuaternionStamped\",\n    data=\n    {\n        \"header\": {\"frame_id\": \"map\", \"stamp\": {\"sec\": 17000, \"nanosec\": 0}},\n        \"quaternion\": {\"x\": 5.0, \"y\": 0.0, \"z\": 0.0, \"w\": 1.0},\n    }\n# Automatically resolves to a flat Mosaico Quaternion with attached metadata\nmosaico_quaternion = QuaternionAdapter.translate(ros_msg)\n</code></pre>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.QuaternionAdapter.translate","title":"translate  <code>classmethod</code>","text":"<pre><code>translate(ros_msg, **kwargs)\n</code></pre> <p>Translates a ROS message into a Mosaico Message.</p> <p>Returns:</p> Name Type Description <code>Message</code> <code>Message</code> <p>The translated message containing a <code>Quaternion</code> object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Wraps any translation error with context (topic name, timestamp).</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.QuaternionAdapter.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(ros_data)\n</code></pre> <p>Recursively parses the ROS data to extract a <code>Quaternion</code>.</p> Strategy <ul> <li>Recurse: If a 'quaternion' key is found, dive deeper into the structure.</li> <li>Leaf Node: At the base level, map 'x', 'y', 'z' and 'w' to    <code>Quaternion</code>.</li> <li>Metadata Binding: Headers and covariances are attached during    recursion unwinding.</li> </ul> Example <pre><code>ros_data=\n{\n    \"header\": {\"frame_id\": \"map\", \"stamp\": {\"sec\": 17000, \"nanosec\": 0}},\n    \"quaternion\": {\"x\": 5.0, \"y\": 0.0, \"z\": 0.0, \"w\": 1.0},\n}\n# Automatically resolves to a flat Mosaico Quaternion with attached metadata\nmosaico_quaternion = QuaternionAdapter.from_dict(ros_data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ros_data</code> <code>dict</code> <p>The raw dictionary from the ROS message.</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>The constructed Mosaico Quaternion object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the recursive 'quaternion' key exists but is not a dict, or if required keys are missing.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.QuaternionAdapter.ros_msg_type","title":"ros_msg_type  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>ros_msg_type()\n</code></pre> <p>Returns the specific ROS message type handled by this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.QuaternionAdapter.ontology_data_type","title":"ontology_data_type  <code>classmethod</code>","text":"<pre><code>ontology_data_type()\n</code></pre> <p>Returns the Ontology class type associated with this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.TransformAdapter","title":"TransformAdapter","text":"<p>               Bases: <code>ROSAdapterBase[Transform]</code></p> <p>Adapter for translating ROS Transform messages to Mosaico <code>Transform</code>.</p> <p>Supported ROS Types:</p> <ul> <li><code>geometry_msgs/msg/TransformStamped</code></li> <li><code>geometry_msgs/msg/Transform</code></li> </ul> <p>Recursive Unwrapping Strategy: The adapter checks for nested <code>'transform'</code> keys. If found (as in <code>TransformStamped</code>), it recurses to the leaf node while collecting metadata like headers and covariance matrices along the way.</p> Example <pre><code>ros_msg = ROSMessage(\n    topic=\"/transform\",\n    timestamp=17000,\n    msg_type=\"geometry_msgs/msg/TransformStamped\",\n    data=\n    {\n        \"header\": {\"frame_id\": \"map\", \"stamp\": {\"sec\": 17000, \"nanosec\": 0}},\n        \"transform\": {\"translation\": {\"x\": 5.0, \"y\": 0.0, \"z\": 0.0}, \"rotation\": {\"x\": 0.0, \"y\": 0.0, \"z\": 0.0, \"w\": 1.0}},\n    }\n# Automatically resolves to a flat Mosaico Transform with attached metadata\nmosaico_transform = TransformAdapter.translate(ros_msg)\n</code></pre>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.TransformAdapter.translate","title":"translate  <code>classmethod</code>","text":"<pre><code>translate(ros_msg, **kwargs)\n</code></pre> <p>Translates a ROS message into a Mosaico Message.</p> <p>Returns:</p> Name Type Description <code>Message</code> <code>Message</code> <p>The translated message containing a <code>Transform</code> object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Wraps any translation error with context (topic name, timestamp).</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.TransformAdapter.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(ros_data)\n</code></pre> <p>Parses ROS Transform data. Handles both nested 'transform' field (from Stamped) and flat structure.</p> Strategy <ul> <li>Recurse: If a 'transform' key is found, dive deeper into the structure.</li> <li>Leaf Node: At the base level, map 'translation' and 'rotation' to    <code>Transform</code>.</li> <li>Metadata Binding: Headers and covariances are attached during    recursion unwinding.</li> </ul> Example <pre><code>ros_data=\n{\n    \"header\": {\"frame_id\": \"map\", \"stamp\": {\"sec\": 17000, \"nanosec\": 0}},\n    \"transform\": {\"translation\": {\"x\": 5.0, \"y\": 0.0, \"z\": 0.0}, \"rotation\": {\"x\": 0.0, \"y\": 0.0, \"z\": 0.0, \"w\": 1.0}},\n}\n# Automatically resolves to a flat Mosaico Transform with attached metadata\nmosaico_transform = TransformAdapter.from_dict(ros_data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ros_data</code> <code>dict</code> <p>The raw dictionary from the ROS message.</p> required <p>Returns:</p> Name Type Description <code>Transform</code> <code>Transform</code> <p>The constructed Mosaico Transform object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the recursive 'transform' key exists but is not a dict, or if required keys are missing.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.TransformAdapter.ros_msg_type","title":"ros_msg_type  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>ros_msg_type()\n</code></pre> <p>Returns the specific ROS message type handled by this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.TransformAdapter.ontology_data_type","title":"ontology_data_type  <code>classmethod</code>","text":"<pre><code>ontology_data_type()\n</code></pre> <p>Returns the Ontology class type associated with this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.WrenchAdapter","title":"WrenchAdapter","text":"<p>               Bases: <code>ROSAdapterBase[ForceTorque]</code></p> <p>Adapter for translating ROS Wrench messages to Mosaico <code>ForceTorque</code>.</p> <p>Supported ROS Types:</p> <ul> <li><code>geometry_msgs/msg/Wrench</code></li> <li><code>geometry_msgs/msg/WrenchStamped</code></li> </ul> <p>Recursive Unwrapping Strategy: The adapter checks for nested <code>'wrench'</code> keys. If found (as in <code>WrenchStamped</code>), it recurses to the leaf node while collecting metadata like headers and covariance matrices along the way.</p> Example <pre><code>ros_msg = ROSMessage(\n    topic=\"/wrench\",\n    timestamp=17000,\n    msg_type=\"geometry_msgs/msg/WrenchStamped\",\n    data=\n    {\n        \"header\": {\"frame_id\": \"map\", \"stamp\": {\"sec\": 17000, \"nanosec\": 0}},\n        \"wrench\": {\"force\": {\"x\": 5.0, \"y\": 0.0, \"z\": 0.0}, \"torque\": {\"x\": 0.0, \"y\": 0.0, \"z\": 0.0}},\n    }\n# Automatically resolves to a flat Mosaico ForceTorque with attached metadata\nmosaico_wrench = WrenchAdapter.translate(ros_msg)\n</code></pre>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.WrenchAdapter.translate","title":"translate  <code>classmethod</code>","text":"<pre><code>translate(ros_msg, **kwargs)\n</code></pre> <p>Translates a ROS message into a Mosaico Message.</p> <p>Returns:</p> Name Type Description <code>Message</code> <code>Message</code> <p>The translated message containing a <code>ForceTorque</code> object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Wraps any translation error with context (topic name, timestamp).</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.WrenchAdapter.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(ros_data)\n</code></pre> <p>Parses ROS ForceTorque data. Handles both nested 'wrench' field (from Stamped) and flat structure.</p> Strategy <ul> <li>Recurse: If a 'wrench' key is found, dive deeper into the structure.</li> <li>Leaf Node: At the base level, map 'force' and 'torque' to    <code>ForceTorque</code>.</li> <li>Metadata Binding: Headers and covariances are attached during    recursion unwinding.</li> </ul> Example <pre><code>ros_data=\n{\n    \"header\": {\"frame_id\": \"map\", \"stamp\": {\"sec\": 17000, \"nanosec\": 0}},\n    \"wrench\": {\"force\": {\"x\": 5.0, \"y\": 0.0, \"z\": 0.0}, \"torque\": {\"x\": 0.0, \"y\": 0.0, \"z\": 0.0}},\n}\n# Automatically resolves to a flat Mosaico ForceTorque with attached metadata\nmosaico_wrench = WrenchAdapter.from_dict(ros_data)\n</code></pre>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.WrenchAdapter.ros_msg_type","title":"ros_msg_type  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>ros_msg_type()\n</code></pre> <p>Returns the specific ROS message type handled by this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/geometry_msgs/#mosaicolabs.ros_bridge.adapters.geometry_msgs.WrenchAdapter.ontology_data_type","title":"ontology_data_type  <code>classmethod</code>","text":"<pre><code>ontology_data_type()\n</code></pre> <p>Returns the Ontology class type associated with this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/nav_msgs/","title":"nav_msgs","text":""},{"location":"SDK/API_reference/bridges/ros/adapters/nav_msgs/#mosaicolabs.ros_bridge.adapters.nav_msgs","title":"mosaicolabs.ros_bridge.adapters.nav_msgs","text":""},{"location":"SDK/API_reference/bridges/ros/adapters/nav_msgs/#mosaicolabs.ros_bridge.adapters.nav_msgs.OdometryAdapter","title":"OdometryAdapter","text":"<p>               Bases: <code>ROSAdapterBase[MotionState]</code></p> <p>Adapter for translating ROS Odometry messages to Mosaico <code>MotionState</code>.</p> <p>Supported ROS Types:</p> <ul> <li><code>nav_msgs/msg/Odometry</code></li> </ul> Example <pre><code>ros_msg = ROSMessage(\n    timestamp=17000,\n    topic=\"/odometry\",\n    msg_type=\"nav_msgs/msg/Odometry\",\n    data=\n    {\n        \"header\": {\"frame_id\": \"map\", \"stamp\": {\"sec\": 17000, \"nanosec\": 0}},\n        \"pose\": {\n            \"position\": {\"x\": 1.0, \"y\": 2.0, \"z\": 0.0},\n            \"orientation\": {\"x\": 0, \"y\": 0, \"z\": 0, \"w\": 1}\n        },\n        \"twist\": {\n            \"linear\": {\"x\": 0.0, \"y\": 0.0, \"z\": 0.0},\n            \"angular\": {\"x\": 0.0, \"y\": 0.0, \"z\": 0.0}\n        },\n        \"child_frame_id\": \"base_link\"\n    }\n)\n# Automatically resolves to a flat Mosaico MotionState with attached metadata\nmosaico_odometry = OdometryAdapter.translate(ros_msg)\n</code></pre>"},{"location":"SDK/API_reference/bridges/ros/adapters/nav_msgs/#mosaicolabs.ros_bridge.adapters.nav_msgs.OdometryAdapter.translate","title":"translate  <code>classmethod</code>","text":"<pre><code>translate(ros_msg, **kwargs)\n</code></pre> <p>Translates a ROS message into a Mosaico Message.</p> <p>Returns:</p> Name Type Description <code>Message</code> <code>Message</code> <p>The translated message containing a <code>MotionState</code> object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Wraps any translation error with context (topic name, timestamp).</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/nav_msgs/#mosaicolabs.ros_bridge.adapters.nav_msgs.OdometryAdapter.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(ros_data)\n</code></pre> <p>Parses a dictionary to extract a <code>MotionState</code> object.</p> Example <pre><code>ros_data=\n{\n    \"header\": {\"frame_id\": \"map\", \"stamp\": {\"sec\": 17000, \"nanosec\": 0}},\n    \"pose\": {\n        \"position\": {\"x\": 1.0, \"y\": 2.0, \"z\": 0.0},\n        \"orientation\": {\"x\": 0, \"y\": 0, \"z\": 0, \"w\": 1}\n    },\n    \"twist\": {\n        \"linear\": {\"x\": 0.0, \"y\": 0.0, \"z\": 0.0},\n        \"angular\": {\"x\": 0.0, \"y\": 0.0, \"z\": 0.0}\n    },\n    \"child_frame_id\": \"base_link\"\n}\n# Automatically resolves to a flat Mosaico MotionState with attached metadata\nmosaico_odometry = OdometryAdapter.from_dict(ros_data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ros_data</code> <code>dict</code> <p>The raw dictionary from the ROS message.</p> required <p>Returns:</p> Name Type Description <code>MotionState</code> <code>MotionState</code> <p>The constructed Mosaico MotionState object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the recursive 'pose' key exists but is not a dict, or if required keys are missing.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/nav_msgs/#mosaicolabs.ros_bridge.adapters.nav_msgs.OdometryAdapter.schema_metadata","title":"schema_metadata  <code>classmethod</code>","text":"<pre><code>schema_metadata(ros_data, **kwargs)\n</code></pre> <p>Extract the ROS message specific schema metadata, if any.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/nav_msgs/#mosaicolabs.ros_bridge.adapters.nav_msgs.OdometryAdapter.ros_msg_type","title":"ros_msg_type  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>ros_msg_type()\n</code></pre> <p>Returns the specific ROS message type handled by this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/nav_msgs/#mosaicolabs.ros_bridge.adapters.nav_msgs.OdometryAdapter.ontology_data_type","title":"ontology_data_type  <code>classmethod</code>","text":"<pre><code>ontology_data_type()\n</code></pre> <p>Returns the Ontology class type associated with this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/","title":"sensor_msgs","text":""},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs","title":"mosaicolabs.ros_bridge.adapters.sensor_msgs","text":""},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.CameraInfoAdapter","title":"CameraInfoAdapter","text":"<p>               Bases: <code>ROSAdapterBase[CameraInfo]</code></p> <p>Adapter for translating ROS CameraInfo messages to Mosaico <code>CameraInfo</code>.</p> <p>Supported ROS Types:</p> <ul> <li><code>sensor_msgs/msg/CameraInfo</code></li> </ul> Example <pre><code>ros_msg = ROSMessage(\n    timestamp=17000,\n    topic=\"/camera_info\",\n    msg_type=\"sensor_msgs/msg/CameraInfo\",\n    data=\n    {\n        \"height\": 480,\n        \"width\": 640,\n        \"binning_x\": 1,\n        \"binning_y\": 1,\n        \"roi\": {\n            \"x_offset\": 0,\n            \"y_offset\": 0,\n            \"height\": 480,\n            \"width\": 640,\n            \"do_rectify\": False,\n        },\n        \"distortion_model\": \"plumb_bob\",\n        \"d\": [0.0, 0.0, 0.0, 0.0, 0.0],\n        \"k\": [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0],\n        \"p\": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n        \"r\": [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0],\n    }\n)\n# Automatically resolves to a flat Mosaico CameraInfo with attached metadata\nmosaico_camera_info = CameraInfoAdapter.translate(ros_msg)\n</code></pre>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.CameraInfoAdapter.translate","title":"translate  <code>classmethod</code>","text":"<pre><code>translate(ros_msg, **kwargs)\n</code></pre> <p>Translates a ROS message into a Mosaico Message.</p> <p>Returns:</p> Name Type Description <code>Message</code> <code>Message</code> <p>The translated message containing a <code>CameraInfo</code> object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Wraps any translation error with context (topic name, timestamp).</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.CameraInfoAdapter.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(ros_data)\n</code></pre> <p>Converts the raw dictionary data into the specific Mosaico type.</p> Example <pre><code>ros_data=\n{\n    \"height\": 480,\n    \"width\": 640,\n    \"binning_x\": 1,\n    \"binning_y\": 1,\n    \"roi\": {\n        \"x_offset\": 0,\n        \"y_offset\": 0,\n        \"height\": 480,\n        \"width\": 640,\n        \"do_rectify\": False,\n    },\n    \"distortion_model\": \"plumb_bob\",\n    \"d\": [0.0, 0.0, 0.0, 0.0, 0.0],\n    \"k\": [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0],\n    \"p\": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n    \"r\": [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0],\n}\n# Automatically resolves to a flat Mosaico CameraInfo with attached metadata\nmosaico_camera_info = CameraInfoAdapter.from_dict(ros_data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ros_data</code> <code>dict</code> <p>The raw dictionary from the ROS message.</p> required <p>Returns:</p> Name Type Description <code>CameraInfo</code> <code>CameraInfo</code> <p>The constructed Mosaico CameraInfo object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the recursive 'roi' key exists but is not a dict, or if required keys are missing.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.CameraInfoAdapter.schema_metadata","title":"schema_metadata  <code>classmethod</code>","text":"<pre><code>schema_metadata(ros_data, **kwargs)\n</code></pre> <p>Extract the ROS message specific schema metadata, if any.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.CameraInfoAdapter.ros_msg_type","title":"ros_msg_type  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>ros_msg_type()\n</code></pre> <p>Returns the specific ROS message type handled by this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.CameraInfoAdapter.ontology_data_type","title":"ontology_data_type  <code>classmethod</code>","text":"<pre><code>ontology_data_type()\n</code></pre> <p>Returns the Ontology class type associated with this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.NavSatStatusAdapter","title":"NavSatStatusAdapter","text":"<p>               Bases: <code>ROSAdapterBase[GPSStatus]</code></p> <p>Adapter for translating ROS NavSatStatus messages to Mosaico <code>GPSStatus</code>.</p> <p>Supported ROS Types:</p> <ul> <li><code>sensor_msgs/msg/NavSatFix</code></li> </ul> Example <pre><code>ros_msg = ROSMessage(\n    timestamp=17000,\n    topic=\"/gps_status\",\n    msg_type=\"sensor_msgs/msg/NavSatFix\",\n    data=\n    {\n        \"status\": 0,\n        \"service\": 1,\n    }\n)\n# Automatically resolves to a flat Mosaico GPSStatus with attached metadata\nmosaico_gps_status = NavSatStatusAdapter.translate(ros_msg)\n</code></pre>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.NavSatStatusAdapter.translate","title":"translate  <code>classmethod</code>","text":"<pre><code>translate(ros_msg, **kwargs)\n</code></pre> <p>Translates a ROS message into a Mosaico Message.</p> <p>Returns:</p> Name Type Description <code>Message</code> <code>Message</code> <p>The translated message containing a <code>GPSStatus</code> object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Wraps any translation error with context (topic name, timestamp).</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.NavSatStatusAdapter.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(ros_data)\n</code></pre> <p>Converts the raw dictionary data into the specific Mosaico type.</p> Example <pre><code>ros_data=\n{\n    \"status\": 0,\n    \"service\": 1,\n}\n# Automatically resolves to a flat Mosaico GPSStatus with attached metadata\nmosaico_gps_status = NavSatStatusAdapter.from_dict(ros_data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ros_data</code> <code>dict</code> <p>The raw dictionary from the ROS message.</p> required <p>Returns:</p> Name Type Description <code>GPSStatus</code> <code>GPSStatus</code> <p>The constructed Mosaico GPSStatus object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the recursive 'roi' key exists but is not a dict, or if required keys are missing.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.NavSatStatusAdapter.schema_metadata","title":"schema_metadata  <code>classmethod</code>","text":"<pre><code>schema_metadata(ros_data, **kwargs)\n</code></pre> <p>Extract the ROS message specific schema metadata, if any.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.NavSatStatusAdapter.ros_msg_type","title":"ros_msg_type  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>ros_msg_type()\n</code></pre> <p>Returns the specific ROS message type handled by this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.NavSatStatusAdapter.ontology_data_type","title":"ontology_data_type  <code>classmethod</code>","text":"<pre><code>ontology_data_type()\n</code></pre> <p>Returns the Ontology class type associated with this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.GPSAdapter","title":"GPSAdapter","text":"<p>               Bases: <code>ROSAdapterBase[GPS]</code></p> <p>Adapter for translating ROS NavSatFix messages to Mosaico <code>GPS</code>.</p> <p>Supported ROS Types:</p> <ul> <li><code>sensor_msgs/msg/NavSatFix</code></li> </ul> Example <pre><code>ros_msg = ROSMessage(\n    timestamp=17000,\n    topic=\"/gps\",\n    msg_type=\"sensor_msgs/msg/NavSatFix\",\n    data=\n    {\n        \"latitude\": 45.5,\n        \"longitude\": -122.5,\n        \"altitude\": 100.0,\n        \"status\": {\n            \"status\": 0,\n            \"service\": 1,\n        },\n    }\n)\n# Automatically resolves to a flat Mosaico GPS with attached metadata\nmosaico_gps = GPSAdapter.translate(ros_msg)\n</code></pre>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.GPSAdapter.translate","title":"translate  <code>classmethod</code>","text":"<pre><code>translate(ros_msg, **kwargs)\n</code></pre> <p>Translates a ROS message into a Mosaico Message.</p> <p>Returns:</p> Name Type Description <code>Message</code> <code>Message</code> <p>The translated message containing a <code>GPS</code> object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Wraps any translation error with context (topic name, timestamp).</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.GPSAdapter.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(ros_data)\n</code></pre> <p>Converts the raw dictionary data into the specific Mosaico type.</p> Example <pre><code>ros_data=\n{\n    \"latitude\": 45.5,\n    \"longitude\": -122.5,\n    \"altitude\": 100.0,\n    \"status\": {\n        \"status\": 0,\n        \"service\": 1,\n    },\n}\n# Automatically resolves to a flat Mosaico GPS with attached metadata\nmosaico_gps = GPSAdapter.from_dict(ros_data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ros_data</code> <code>dict</code> <p>The raw dictionary from the ROS message.</p> required <p>Returns:</p> Name Type Description <code>GPS</code> <code>GPS</code> <p>The constructed Mosaico GPS object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the recursive 'roi' key exists but is not a dict, or if required keys are missing.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.GPSAdapter.schema_metadata","title":"schema_metadata  <code>classmethod</code>","text":"<pre><code>schema_metadata(ros_data, **kwargs)\n</code></pre> <p>Extract the ROS message specific schema metadata, if any.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.GPSAdapter.ros_msg_type","title":"ros_msg_type  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>ros_msg_type()\n</code></pre> <p>Returns the specific ROS message type handled by this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.GPSAdapter.ontology_data_type","title":"ontology_data_type  <code>classmethod</code>","text":"<pre><code>ontology_data_type()\n</code></pre> <p>Returns the Ontology class type associated with this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.IMUAdapter","title":"IMUAdapter","text":"<p>               Bases: <code>ROSAdapterBase[IMU]</code></p> <p>Adapter for translating ROS Imu messages to Mosaico <code>IMU</code>.</p> <p>Supported ROS Types:</p> <ul> <li><code>sensor_msgs/msg/Imu</code></li> </ul> Example <pre><code>ros_msg = ROSMessage(\n    timestamp=17000,\n    topic=\"/imu\",\n    msg_type=\"sensor_msgs/msg/Imu\",\n    data=\n    {\n        \"linear_acceleration\": {\"x\": 0.0, \"y\": 0.0, \"z\": 0.0},\n        \"angular_velocity\": {\"x\": 0.0, \"y\": 0.0, \"z\": 0.0},\n        \"orientation\": {\"x\": 0.0, \"y\": 0.0, \"z\": 0.0, \"w\": 1.0},\n        \"orientation_covariance\": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n        \"linear_acceleration_covariance\": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n        \"angular_velocity_covariance\": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n        \"header\": {\"seq\": 0, \"stamp\": {\"sec\": 0, \"nanosec\": 0}, \"frame_id\": \"robot_link\"},\n    }\n)\n# Automatically resolves to a flat Mosaico IMU with attached metadata\nmosaico_imu = IMUAdapter.translate(ros_msg)\n</code></pre>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.IMUAdapter.translate","title":"translate  <code>classmethod</code>","text":"<pre><code>translate(ros_msg, **kwargs)\n</code></pre> <p>Translates a ROS message into a Mosaico Message.</p> <p>Returns:</p> Name Type Description <code>Message</code> <code>Message</code> <p>The translated message containing a <code>IMU</code> object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Wraps any translation error with context (topic name, timestamp).</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.IMUAdapter.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(ros_data)\n</code></pre> <p>Converts the raw dictionary data into the specific Mosaico type.</p> Example <pre><code>ros_data=\n{\n    \"linear_acceleration\": {\"x\": 0.0, \"y\": 0.0, \"z\": 0.0},\n    \"angular_velocity\": {\"x\": 0.0, \"y\": 0.0, \"z\": 0.0},\n    \"orientation\": {\"x\": 0.0, \"y\": 0.0, \"z\": 0.0, \"w\": 1.0},\n    \"orientation_covariance\": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n    \"linear_acceleration_covariance\": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n    \"angular_velocity_covariance\": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n    \"header\": {\"seq\": 0, \"stamp\": {\"sec\": 0, \"nanosec\": 0}, \"frame_id\": \"robot_link\"},\n}\n# Automatically resolves to a flat Mosaico IMU with attached metadata\nmosaico_imu = IMUAdapter.from_dict(ros_data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ros_data</code> <code>dict</code> <p>The raw dictionary from the ROS message.</p> required <p>Returns:</p> Name Type Description <code>IMU</code> <code>IMU</code> <p>The constructed Mosaico IMU object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the recursive 'roi' key exists but is not a dict, or if required keys are missing.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.IMUAdapter.schema_metadata","title":"schema_metadata  <code>classmethod</code>","text":"<pre><code>schema_metadata(ros_data, **kwargs)\n</code></pre> <p>Extract the ROS message specific schema metadata, if any.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.IMUAdapter.ros_msg_type","title":"ros_msg_type  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>ros_msg_type()\n</code></pre> <p>Returns the specific ROS message type handled by this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.IMUAdapter.ontology_data_type","title":"ontology_data_type  <code>classmethod</code>","text":"<pre><code>ontology_data_type()\n</code></pre> <p>Returns the Ontology class type associated with this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.NMEASentenceAdapter","title":"NMEASentenceAdapter","text":"<p>               Bases: <code>ROSAdapterBase[NMEASentence]</code></p> <p>Adapter for translating ROS NMEASentence messages to Mosaico <code>NMEASentence</code>.</p> <p>Supported ROS Types:</p> <ul> <li><code>nmea_msgs/msg/Sentence</code></li> </ul> Example <pre><code>ros_msg = ROSMessage(\n    timestamp=17000,\n    topic=\"/gps/fix\",\n    msg_type=\"sensor_msgs/msg/GPSFix\",\n    data=\n    {\n        \"sentence\": \"GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*47\",\n    }\n)\n# Automatically resolves to a flat Mosaico GPS with attached metadata\nmosaico_gps = NMEASentenceAdapter.translate(ros_msg)\n</code></pre>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.NMEASentenceAdapter.translate","title":"translate  <code>classmethod</code>","text":"<pre><code>translate(ros_msg, **kwargs)\n</code></pre> <p>Translates a ROS message into a Mosaico Message.</p> <p>Returns:</p> Name Type Description <code>Message</code> <code>Message</code> <p>The translated message containing a <code>NMEASenetence</code> object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Wraps any translation error with context (topic name, timestamp).</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.NMEASentenceAdapter.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(ros_data)\n</code></pre> <p>Converts the raw dictionary data into the specific Mosaico type.</p> Example <pre><code>ros_data=\n{\n    \"sentence\": \"GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*47\",\n}\n# Automatically resolves to a flat Mosaico NMEASentence with attached metadata\nmosaico_nmea_sentence = NMEASentenceAdapter.from_dict(ros_data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ros_data</code> <code>dict</code> <p>The raw dictionary from the ROS message.</p> required <p>Returns:</p> Name Type Description <code>NMEASentence</code> <code>NMEASentence</code> <p>The constructed Mosaico NMEASentence object.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.NMEASentenceAdapter.schema_metadata","title":"schema_metadata  <code>classmethod</code>","text":"<pre><code>schema_metadata(ros_data, **kwargs)\n</code></pre> <p>Extract the ROS message specific schema metadata, if any.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.NMEASentenceAdapter.ros_msg_type","title":"ros_msg_type  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>ros_msg_type()\n</code></pre> <p>Returns the specific ROS message type handled by this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.NMEASentenceAdapter.ontology_data_type","title":"ontology_data_type  <code>classmethod</code>","text":"<pre><code>ontology_data_type()\n</code></pre> <p>Returns the Ontology class type associated with this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.ImageAdapter","title":"ImageAdapter","text":"<p>               Bases: <code>ROSAdapterBase[Image]</code></p> <p>Adapter for translating ROS Image messages to Mosaico <code>Image</code>.</p> <p>Supported ROS Types:</p> <ul> <li><code>sensor_msgs/msg/Image</code></li> </ul> Example <pre><code>ros_msg = ROSMessage(\n    timestamp=17000,\n    topic=\"/image\",\n    msg_type=\"sensor_msgs/msg/Image\",\n    data=\n    {\n        \"data\": [...],\n        \"width\": 1,\n        \"height\": 1,\n        \"step\": 4,\n        \"encoding\": \"bgr8\",\n    }\n)\n# Automatically resolves to a flat Mosaico Image with attached metadata\nmosaico_image = ImageAdapter.translate(ros_msg)\n</code></pre>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.ImageAdapter.translate","title":"translate  <code>classmethod</code>","text":"<pre><code>translate(ros_msg, **kwargs)\n</code></pre> <p>Translates a ROS message into a Mosaico Message.</p> <p>Returns:</p> Name Type Description <code>Message</code> <code>Message</code> <p>The translated message containing a <code>Image</code> object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Wraps any translation error with context (topic name, timestamp).</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.ImageAdapter.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(ros_data, **kwargs)\n</code></pre> <p>Converts the raw dictionary data into the specific Mosaico type.</p> Example <pre><code>ros_data=\n{\n    \"data\": [...],\n    \"width\": 1,\n    \"height\": 1,\n    \"step\": 4,\n    \"encoding\": \"bgr8\",\n}\n# Automatically resolves to a flat Mosaico Image with attached metadata\nmosaico_image = ImageAdapter.from_dict(ros_data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ros_data</code> <code>dict</code> <p>The raw dictionary from the ROS message.</p> required <p>Returns:</p> Name Type Description <code>Image</code> <code>Image</code> <p>The constructed Mosaico Image object.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.ImageAdapter.schema_metadata","title":"schema_metadata  <code>classmethod</code>","text":"<pre><code>schema_metadata(ros_data, **kwargs)\n</code></pre> <p>Extract the ROS message specific schema metadata, if any.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.ImageAdapter.ros_msg_type","title":"ros_msg_type  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>ros_msg_type()\n</code></pre> <p>Returns the specific ROS message type handled by this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.ImageAdapter.ontology_data_type","title":"ontology_data_type  <code>classmethod</code>","text":"<pre><code>ontology_data_type()\n</code></pre> <p>Returns the Ontology class type associated with this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.CompressedImageAdapter","title":"CompressedImageAdapter","text":"<p>               Bases: <code>ROSAdapterBase[CompressedImage]</code></p> <p>Adapter for translating ROS CompressedImage messages to Mosaico <code>CompressedImage</code>.</p> <p>Supported ROS Types:</p> <ul> <li><code>sensor_msgs/msg/CompressedImage</code></li> </ul> Example <pre><code>ros_msg = ROSMessage(\n    timestamp=17000,\n    topic=\"/compressed_image\",\n    msg_type=\"sensor_msgs/msg/CompressedImage\",\n    data=\n    {\n        \"data\": [...],\n        \"format\": \"jpeg\",\n    }\n)\n# Automatically resolves to a flat Mosaico CompressedImage with attached metadata\nmosaico_compressed_image = CompressedImageAdapter.translate(ros_msg)\n</code></pre>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.CompressedImageAdapter.translate","title":"translate  <code>classmethod</code>","text":"<pre><code>translate(ros_msg, **kwargs)\n</code></pre> <p>Translates a ROS message into a Mosaico Message.</p> <p>Returns:</p> Name Type Description <code>Message</code> <code>Message</code> <p>The translated message containing a <code>CompressedImage</code> object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Wraps any translation error with context (topic name, timestamp).</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.CompressedImageAdapter.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(ros_data)\n</code></pre> <p>Converts the raw dictionary data into the specific Mosaico type.</p> Example <pre><code>ros_data=\n{\n    \"data\": [...],\n    \"format\": \"jpeg\",\n}\n# Automatically resolves to a flat Mosaico CompressedImage with attached metadata\nmosaico_compressed_image = CompressedImageAdapter.from_dict(ros_data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ros_data</code> <code>dict</code> <p>The raw dictionary from the ROS message.</p> required <p>Returns:</p> Name Type Description <code>CompressedImage</code> <code>CompressedImage</code> <p>The constructed Mosaico CompressedImage object.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.CompressedImageAdapter.schema_metadata","title":"schema_metadata  <code>classmethod</code>","text":"<pre><code>schema_metadata(ros_data, **kwargs)\n</code></pre> <p>Extract the ROS message specific schema metadata, if any.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.CompressedImageAdapter.ros_msg_type","title":"ros_msg_type  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>ros_msg_type()\n</code></pre> <p>Returns the specific ROS message type handled by this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.CompressedImageAdapter.ontology_data_type","title":"ontology_data_type  <code>classmethod</code>","text":"<pre><code>ontology_data_type()\n</code></pre> <p>Returns the Ontology class type associated with this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.ROIAdapter","title":"ROIAdapter","text":"<p>               Bases: <code>ROSAdapterBase[ROI]</code></p> <p>Adapter for translating ROS RegionOfInterest messages to Mosaico <code>ROI</code>.</p> <p>Supported ROS Types:</p> <ul> <li><code>sensor_msgs/RegionOfInterest</code></li> </ul> Example <pre><code>ros_msg = ROSMessage(\n    timestamp=17000,\n    topic=\"/roi\",\n    msg_type=\"sensor_msgs/RegionOfInterest\",\n    data=\n    {\n        \"height\": 1,\n        \"width\": 1,\n        \"x_offset\": 0,\n        \"y_offset\": 0,\n    }\n)\n# Automatically resolves to a flat Mosaico ROI with attached metadata\nmosaico_roi = ROIAdapter.translate(ros_msg)\n</code></pre>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.ROIAdapter.translate","title":"translate  <code>classmethod</code>","text":"<pre><code>translate(ros_msg, **kwargs)\n</code></pre> <p>Translates a ROS message into a Mosaico Message.</p> <p>Returns:</p> Name Type Description <code>Message</code> <code>Message</code> <p>The translated message containing a <code>ROI</code> object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Wraps any translation error with context (topic name, timestamp).</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.ROIAdapter.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(ros_data)\n</code></pre> <p>Converts the raw dictionary data into the specific Mosaico type.</p> Example <pre><code>ros_data=\n{\n    \"height\": 1,\n    \"width\": 1,\n    \"x_offset\": 0,\n    \"y_offset\": 0,\n}\n# Automatically resolves to a flat Mosaico ROI with attached metadata\nmosaico_roi = ROIAdapter.from_dict(ros_data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ros_data</code> <code>dict</code> <p>The raw dictionary from the ROS message.</p> required <p>Returns:</p> Name Type Description <code>ROI</code> <code>ROI</code> <p>The constructed Mosaico ROI object.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.ROIAdapter.schema_metadata","title":"schema_metadata  <code>classmethod</code>","text":"<pre><code>schema_metadata(ros_data, **kwargs)\n</code></pre> <p>Extract the ROS message specific schema metadata, if any.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.ROIAdapter.ros_msg_type","title":"ros_msg_type  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>ros_msg_type()\n</code></pre> <p>Returns the specific ROS message type handled by this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.ROIAdapter.ontology_data_type","title":"ontology_data_type  <code>classmethod</code>","text":"<pre><code>ontology_data_type()\n</code></pre> <p>Returns the Ontology class type associated with this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.BatteryStateAdapter","title":"BatteryStateAdapter","text":"<p>               Bases: <code>ROSAdapterBase[BatteryState]</code></p> <p>Adapter for translating ROS BatteryState messages to Mosaico <code>BatteryState</code>.</p> <p>Supported ROS Types:</p> <ul> <li><code>sensor_msgs/msg/BatteryState</code></li> </ul> Example <pre><code>ros_msg = ROSMessage(\n    timestamp=17000,\n    topic=\"/battery_state\",\n    msg_type=\"sensor_msgs/msg/BatteryState\",\n    data=\n    {\n        \"voltage\": 12.6,\n        \"capacity\": 100,\n        \"cell_temperature\": 25,\n        \"cell_voltage\": [12.6],\n        \"location\": \"battery\",\n        \"charge\": 100,\n        \"current\": 0,\n        \"design_capacity\": 100,\n        \"location\": \"battery\",\n        \"percentage\": 100,\n        \"power_supply_health\": \"good\",\n        \"power_supply_status\": \"charging\",\n        \"power_supply_technology\": \"li-ion\",\n        \"present\": True,\n        \"serial_number\": \"1234567890\",\n        \"temperature\": 25,\n    }\n)\n# Automatically resolves to a flat Mosaico BatteryState with attached metadata\nmosaico_battery_state = BatteryStateAdapter.translate(ros_msg)\n</code></pre>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.BatteryStateAdapter.translate","title":"translate  <code>classmethod</code>","text":"<pre><code>translate(ros_msg, **kwargs)\n</code></pre> <p>Translates a ROS message into a Mosaico Message.</p> <p>Returns:</p> Name Type Description <code>Message</code> <code>Message</code> <p>The translated message containing a <code>BatteryState</code> object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Wraps any translation error with context (topic name, timestamp).</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.BatteryStateAdapter.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(ros_data)\n</code></pre> <p>Converts the raw dictionary data into the specific Mosaico type.</p> Example <pre><code>ros_data=\n{\n    \"voltage\": 12.6,\n    \"capacity\": 100,\n    \"cell_temperature\": 25,\n    \"cell_voltage\": [12.6],\n    \"location\": \"battery\",\n    \"charge\": 100,\n    \"current\": 0,\n    \"design_capacity\": 100,\n    \"location\": \"battery\",\n    \"percentage\": 100,\n    \"power_supply_health\": \"good\",\n    \"power_supply_status\": \"charging\",\n    \"power_supply_technology\": \"li-ion\",\n    \"present\": True,\n    \"serial_number\": \"1234567890\",\n    \"temperature\": 25,\n}\n# Automatically resolves to a flat Mosaico BatteryState with attached metadata\nmosaico_battery_state = BatteryStateAdapter.from_dict(ros_data)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ros_data</code> <code>dict</code> <p>The raw dictionary from the ROS message.</p> required <p>Returns:</p> Name Type Description <code>BatteryState</code> <code>BatteryState</code> <p>The constructed Mosaico BatteryState object.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.BatteryStateAdapter.schema_metadata","title":"schema_metadata  <code>classmethod</code>","text":"<pre><code>schema_metadata(ros_data, **kwargs)\n</code></pre> <p>Extract the ROS message specific schema metadata, if any.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.BatteryStateAdapter.ros_msg_type","title":"ros_msg_type  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>ros_msg_type()\n</code></pre> <p>Returns the specific ROS message type handled by this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.BatteryStateAdapter.ontology_data_type","title":"ontology_data_type  <code>classmethod</code>","text":"<pre><code>ontology_data_type()\n</code></pre> <p>Returns the Ontology class type associated with this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.RobotJointAdapter","title":"RobotJointAdapter","text":"<p>               Bases: <code>ROSAdapterBase[RobotJoint]</code></p> <p>Adapter for translating ROS JointState messages to Mosaico <code>RobotJoint</code>.</p> <p>Supported ROS Types:</p> <ul> <li><code>sensor_msgs/msg/JointState</code></li> </ul> Example <pre><code>ros_msg = ROSMessage(\n    timestamp=17000,\n    topic=\"/joint_states\",\n    msg_type=\"sensor_msgs/msg/JointState\",\n    data={\n        \"header\": {\n            \"stamp\": {\n                \"sec\": 17000,\n                \"nanosec\": 0,\n            },\n            \"frame_id\": \"\",\n        },\n        \"name\": [\"joint1\", \"joint2\"],\n        \"position\": [0.0, 0.0],\n        \"velocity\": [0.0, 0.0],\n        \"effort\": [0.0, 0.0],\n    },\n)\n# Automatically resolves to a flat Mosaico RobotJoint with attached metadata\nmosaico_robot_joint = RobotJointAdapter.translate(ros_msg)\n</code></pre>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.RobotJointAdapter.translate","title":"translate  <code>classmethod</code>","text":"<pre><code>translate(ros_msg, **kwargs)\n</code></pre> <p>Translates a ROS message into a Mosaico Message.</p> <p>Returns:</p> Name Type Description <code>Message</code> <code>Message</code> <p>The translated message containing a <code>RobotJoint</code> object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Wraps any translation error with context (topic name, timestamp).</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.RobotJointAdapter.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(ros_data)\n</code></pre> <p>Converts the raw dictionary data into the specific Mosaico type.</p> Example <pre><code>ros_data={\n    \"header\": {\n        \"stamp\": {\n            \"sec\": 17000,\n            \"nanosec\": 0,\n        },\n        \"frame_id\": \"\",\n    },\n    \"name\": [\"joint1\", \"joint2\"],\n    \"position\": [0.0, 0.0],\n    \"velocity\": [0.0, 0.0],\n    \"effort\": [0.0, 0.0],\n}\n# Automatically resolves to a flat Mosaico RobotJoint with attached metadata\nmosaico_robot_joint = RobotJointAdapter.from_dict(ros_data)\n</code></pre>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.RobotJointAdapter.schema_metadata","title":"schema_metadata  <code>classmethod</code>","text":"<pre><code>schema_metadata(ros_data, **kwargs)\n</code></pre> <p>Extract the ROS message specific schema metadata, if any.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.RobotJointAdapter.ros_msg_type","title":"ros_msg_type  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>ros_msg_type()\n</code></pre> <p>Returns the specific ROS message type handled by this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/sensor_msgs/#mosaicolabs.ros_bridge.adapters.sensor_msgs.RobotJointAdapter.ontology_data_type","title":"ontology_data_type  <code>classmethod</code>","text":"<pre><code>ontology_data_type()\n</code></pre> <p>Returns the Ontology class type associated with this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/std_msgs/","title":"std_msgs","text":""},{"location":"SDK/API_reference/bridges/ros/adapters/std_msgs/#mosaicolabs.ros_bridge.adapters.std_msgs","title":"mosaicolabs.ros_bridge.adapters.std_msgs","text":"<p>Standard ROS Message Adapters.</p> <p>This module provides adapters for translating standard ROS messages (std_msgs) into Mosaico ontology types. Instead of manually defining a class for every single primitive type (Int8, String, Bool, etc.), we use a dynamic factory pattern.</p> Architecture <ul> <li><code>_ROS_MSGTYPE_MSCO_BASE_TYPE_MAP</code> defines the relationship between a ROS    message type string (e.g., \"std_msgs/msg/String\") and the corresponding    Mosaico Serializable class (e.g., <code>String</code>).</li> <li><code>GenericStdAdapter</code> implements the common <code>translate</code> and <code>from_dict</code> logics    shared by all standard types (wrapping the 'data' field).</li> <li>At module load time, we iterate through the mapping, dynamically create    a unique subclass of <code>GenericStdAdapter</code> for each type and register it    in the ROSBridge.</li> </ul>"},{"location":"SDK/API_reference/bridges/ros/adapters/std_msgs/#mosaicolabs.ros_bridge.adapters.std_msgs.GenericStdAdapter","title":"GenericStdAdapter","text":"<p>               Bases: <code>ROSAdapterBase[Serializable]</code></p> <p>Template for dynamic factory-based adaptation of standard ROS primitive messages.</p> <p>This class provides the core translation logic for the <code>std_msgs</code> family. To avoid manual definition of dozens of repetitive classes (e.g., <code>Int8Adapter</code>, <code>StringAdapter</code>), the ROS Bridge employs a Dynamic Factory Pattern.</p> <p>Supported ROS Types:</p> <ul> <li><code>std_msgs/msg/String</code></li> <li><code>std_msgs/msg/Int8</code></li> <li><code>std_msgs/msg/Int16</code></li> <li><code>std_msgs/msg/Int32</code></li> <li><code>std_msgs/msg/Int64</code></li> <li><code>std_msgs/msg/UInt8</code></li> <li><code>std_msgs/msg/UInt16</code></li> <li><code>std_msgs/msg/UInt32</code></li> <li><code>std_msgs/msg/UInt64</code></li> <li><code>std_msgs/msg/Float32</code></li> <li><code>std_msgs/msg/Float64</code></li> <li><code>std_msgs/msg/Bool</code></li> </ul>"},{"location":"SDK/API_reference/bridges/ros/adapters/std_msgs/#mosaicolabs.ros_bridge.adapters.std_msgs.GenericStdAdapter--architecture-dynamic-generation","title":"Architecture &amp; Dynamic Generation","text":"<p>At module load time, the SDK iterates through a configuration mapping (<code>_ROS_MSGTYPE_MSCO_BASE_TYPE_MAP</code>) and programmatically generates concrete subclasses of <code>GenericStdAdapter</code>.</p> <p>Each generated subclass is:</p> <ol> <li>Injected with a specific <code>ros_msgtype</code> (e.g., <code>\"std_msgs/msg/String\"</code>).</li> <li>Injected with a specific target <code>__mosaico_ontology_type__</code> (e.g., <code>String</code>).</li> <li>Registered automatically in the <code>ROSBridge</code>     using the <code>@register_adapter</code> mechanism.</li> </ol>"},{"location":"SDK/API_reference/bridges/ros/adapters/std_msgs/#mosaicolabs.ros_bridge.adapters.std_msgs.GenericStdAdapter--adaptation-strategy","title":"\"Adaptation\" Strategy","text":"<p>Following the philosophy of \"Adaptation, Not Just Parsing,\" these adapters do not simply extract raw values. They perform:</p> <ul> <li>Schema Enforcement: Validating that the ROS message contains the mandatory   <code>'data'</code> field.</li> <li>Strong Typing: Wrapping the primitive value into a Mosaico <code>Serializable</code>   object with its own metadata and queryable headers.</li> <li>Temporal Alignment: Preserving nanosecond-precise timestamps and optional   frame information from the source bag file.</li> </ul> Example <pre><code># Logic effectively generated by the factory:\nclass StringStdAdapter(GenericStdAdapter):\n    ros_msgtype = \"std_msgs/msg/String\"\n    __mosaico_ontology_type__ = String\n\n# Usage within the Bridge:\nros_msg = ROSMessage(\n    timestamp=1707760800.123456789,\n    topic=\"/log\",\n    msg_type=\"std_msgs/msg/String\",\n    data={\"data\": \"System OK\"}\n)\nmosaico_string = StringStdAdapter.translate(ros_msg)\n</code></pre>"},{"location":"SDK/API_reference/bridges/ros/adapters/std_msgs/#mosaicolabs.ros_bridge.adapters.std_msgs.GenericStdAdapter.translate","title":"translate  <code>classmethod</code>","text":"<pre><code>translate(ros_msg, **kwargs)\n</code></pre> <p>Translates a standard ROS message to a Mosaico Message.</p> <p>Standard messages typically contain a 'data' field and metadata. This method extracts the header/timestamp and wraps the payload using the specific ontology type defined for this adapter class.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/std_msgs/#mosaicolabs.ros_bridge.adapters.std_msgs.GenericStdAdapter.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(ros_data)\n</code></pre> <p>Converts the raw dictionary data into the specific Mosaico type.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/std_msgs/#mosaicolabs.ros_bridge.adapters.std_msgs.GenericStdAdapter.schema_metadata","title":"schema_metadata  <code>classmethod</code>","text":"<pre><code>schema_metadata(ros_data, **kwargs)\n</code></pre> <p>Standard types do not carry additional schema metadata.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/std_msgs/#mosaicolabs.ros_bridge.adapters.std_msgs.GenericStdAdapter.ros_msg_type","title":"ros_msg_type  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>ros_msg_type()\n</code></pre> <p>Returns the specific ROS message type handled by this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/std_msgs/#mosaicolabs.ros_bridge.adapters.std_msgs.GenericStdAdapter.ontology_data_type","title":"ontology_data_type  <code>classmethod</code>","text":"<pre><code>ontology_data_type()\n</code></pre> <p>Returns the Ontology class type associated with this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/tf2_msgs/","title":"tf2_msgs","text":""},{"location":"SDK/API_reference/bridges/ros/adapters/tf2_msgs/#mosaicolabs.ros_bridge.adapters.tf2_msgs","title":"mosaicolabs.ros_bridge.adapters.tf2_msgs","text":""},{"location":"SDK/API_reference/bridges/ros/adapters/tf2_msgs/#mosaicolabs.ros_bridge.adapters.tf2_msgs.FrameTransformAdapter","title":"FrameTransformAdapter","text":"<p>               Bases: <code>ROSAdapterBase</code></p> <p>Adapter for translating ROS TF2 messages to Mosaico <code>FrameTransform</code>.</p> <p>Supported ROS Types:</p> <ul> <li><code>tf2_msgs/msg/TFMessage</code></li> </ul> Example <pre><code>ros_msg = ROSMessage(\n    timestamp=17000,\n    topic=\"/tf\",\n    msg_type=\"tf2_msgs/msg/TFMessage\",\n    data={\n        \"transforms\": [\n            {\n                \"header\": {\n                    \"stamp\": {\n                        \"sec\": 17000,\n                        \"nanosec\": 0,\n                    },\n                    \"frame_id\": \"map\",\n                    \"child_frame_id\": \"base_link\",\n                },\n                \"transform\": {\n                    \"translation\": {\n                        \"x\": 0.0,\n                        \"y\": 0.0,\n                        \"z\": 0.0,\n                    },\n                    \"rotation\": {\n                        \"x\": 0.0,\n                        \"y\": 0.0,\n                        \"z\": 0.0,\n                        \"w\": 1.0,\n                    },\n                },\n            }\n        ]\n    },\n)\n# Automatically resolves to a flat Mosaico FrameTransform with attached metadata\nmosaico_frame_transform = FrameTransformAdapter.translate(ros_msg)\n</code></pre>"},{"location":"SDK/API_reference/bridges/ros/adapters/tf2_msgs/#mosaicolabs.ros_bridge.adapters.tf2_msgs.FrameTransformAdapter.translate","title":"translate  <code>classmethod</code>","text":"<pre><code>translate(ros_msg, **kwargs)\n</code></pre> <p>Translates a ROS message into a Mosaico Message.</p> <p>Returns:</p> Name Type Description <code>Message</code> <code>Message</code> <p>The translated message containing a <code>FrameTransform</code> object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Wraps any translation error with context (topic name, timestamp).</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/tf2_msgs/#mosaicolabs.ros_bridge.adapters.tf2_msgs.FrameTransformAdapter.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(ros_data)\n</code></pre> <p>Converts the raw dictionary data into the specific Mosaico type.</p> Example <pre><code>ros_data={\n    \"transforms\": [\n        {\n            \"header\": {\n                \"stamp\": {\n                    \"sec\": 17000,\n                    \"nanosec\": 0,\n                },\n                \"frame_id\": \"map\",\n                \"child_frame_id\": \"base_link\",\n            },\n            \"transform\": {\n                \"translation\": {\n                    \"x\": 0.0,\n                    \"y\": 0.0,\n                    \"z\": 0.0,\n                },\n                \"rotation\": {\n                    \"x\": 0.0,\n                    \"y\": 0.0,\n                    \"z\": 0.0,\n                    \"w\": 1.0,\n                },\n            },\n        }\n    ]\n}\n# Automatically resolves to a flat Mosaico FrameTransform with attached metadata\nmosaico_frame_transform = FrameTransformAdapter.from_dict(ros_data)\n</code></pre>"},{"location":"SDK/API_reference/bridges/ros/adapters/tf2_msgs/#mosaicolabs.ros_bridge.adapters.tf2_msgs.FrameTransformAdapter.schema_metadata","title":"schema_metadata  <code>classmethod</code>","text":"<pre><code>schema_metadata(ros_data, **kwargs)\n</code></pre> <p>Extract the ROS message specific schema metadata, if any.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/tf2_msgs/#mosaicolabs.ros_bridge.adapters.tf2_msgs.FrameTransformAdapter.ros_msg_type","title":"ros_msg_type  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>ros_msg_type()\n</code></pre> <p>Returns the specific ROS message type handled by this adapter.</p>"},{"location":"SDK/API_reference/bridges/ros/adapters/tf2_msgs/#mosaicolabs.ros_bridge.adapters.tf2_msgs.FrameTransformAdapter.ontology_data_type","title":"ontology_data_type  <code>classmethod</code>","text":"<pre><code>ontology_data_type()\n</code></pre> <p>Returns the Ontology class type associated with this adapter.</p>"},{"location":"SDK/API_reference/handlers/reading/","title":"Data Retrieval","text":""},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.system_info.SystemInfo","title":"mosaicolabs.handlers.system_info.SystemInfo  <code>dataclass</code>","text":"<pre><code>SystemInfo(\n    total_size_bytes,\n    created_datetime,\n    is_locked,\n    chunks_number=None,\n)\n</code></pre> <p>Metadata and structural information for a Mosaico <code>Sequence</code> or <code>Topic</code> resource.</p> <p>This Data Transfer Object summarizes the physical and logical state of a sequence or topic on the server, typically retrieved via a system-info action.</p> <p>Attributes:</p> Name Type Description <code>total_size_bytes</code> <code>int</code> <p>The aggregate size of all data chunks in bytes.</p> <code>created_datetime</code> <code>datetime</code> <p>The UTC timestamp of when the resource was first initialized.</p> <code>is_locked</code> <code>bool</code> <p>Indicates if the resource is currently read-only. Usually true if an upload is finalized or a retention policy is active.</p> <code>chunks_number</code> <code>Optional[int]</code> <p>The total count of data partitions (chunks) stored on the server. Defaults to None if not applicable.</p>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.SequenceHandler","title":"mosaicolabs.handlers.SequenceHandler","text":"<pre><code>SequenceHandler(\n    *,\n    sequence_model,\n    client,\n    timestamp_ns_min,\n    timestamp_ns_max,\n)\n</code></pre> <p>Represents a client-side handle for an existing Sequence on the Mosaico platform.</p> <p>The <code>SequenceHandler</code> acts as a primary container for inspecting sequence-level metadata, listing available topics, and accessing data reading interfaces like the <code>SequenceDataStreamer</code>.</p> Obtaining a Handler <p>Users should not instantiate this class directly. The recommended way to obtain a handler is via the <code>MosaicoClient.sequence_handler()</code> factory method.</p> <p>Internal constructor for SequenceHandler.</p> <p>Do not call this directly. Users should retrieve instances via <code>MosaicoClient.sequence_handler()</code>, while internal modules should use the <code>SequenceHandler._connect()</code> factory.</p> <p>Parameters:</p> Name Type Description Default <code>sequence_model</code> <code>Sequence</code> <p>The underlying metadata and system info model for the sequence.</p> required <code>client</code> <code>FlightClient</code> <p>The active FlightClient for remote operations.</p> required <code>timestamp_ns_min</code> <code>Optional[int]</code> <p>The lowest timestamp (in ns) available in this sequence.</p> required <code>timestamp_ns_max</code> <code>Optional[int]</code> <p>The highest timestamp (in ns) available in this sequence.</p> required"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.SequenceHandler.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre> <p>The unique name of the sequence.</p> <p>Returns:</p> Type Description <code>str</code> <p>The unique name of the sequence.</p>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.SequenceHandler.topics","title":"topics  <code>property</code>","text":"<pre><code>topics\n</code></pre> <p>The list of topic names (data channels) available within this sequence.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>The list of topic names (data channels) available within this sequence.</p>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.SequenceHandler.user_metadata","title":"user_metadata  <code>property</code>","text":"<pre><code>user_metadata\n</code></pre> <p>The user-defined metadata dictionary associated with this sequence.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The user-defined metadata dictionary associated with this sequence.</p>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.SequenceHandler.created_datetime","title":"created_datetime  <code>property</code>","text":"<pre><code>created_datetime\n</code></pre> <p>The UTC timestamp indicating when the entity was created on the server.</p> <p>Returns:</p> Type Description <code>datetime</code> <p>The UTC timestamp indicating when the entity was created on the server.</p>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.SequenceHandler.is_locked","title":"is_locked  <code>property</code>","text":"<pre><code>is_locked\n</code></pre> <p>Indicates if the resource is currently locked.</p> <p>A locked state typically occurs during active writing or maintenance operations, preventing deletion or structural modifications.</p> <p>Returns:</p> Type Description <code>bool</code> <p>The lock status of the sequence.</p>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.SequenceHandler.total_size_bytes","title":"total_size_bytes  <code>property</code>","text":"<pre><code>total_size_bytes\n</code></pre> <p>The total physical storage footprint of the entity on the server in bytes.</p> <p>Returns:</p> Type Description <code>int</code> <p>The total physical storage footprint of the entity on the server in bytes.</p>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.SequenceHandler.timestamp_ns_min","title":"timestamp_ns_min  <code>property</code>","text":"<pre><code>timestamp_ns_min\n</code></pre> <p>The lowest timestamp (nanoseconds) recorded in the sequence across all topics.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>The lowest timestamp (nanoseconds) recorded in the sequence across all topics, or <code>None</code> if the sequence contains no data or the timestamps could not be derived.</p>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.SequenceHandler.timestamp_ns_max","title":"timestamp_ns_max  <code>property</code>","text":"<pre><code>timestamp_ns_max\n</code></pre> <p>The highest timestamp (nanoseconds) recorded in the sequence across all topics.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>The highest timestamp (nanoseconds) recorded in the sequence across all topics, or <code>None</code> if the sequence contains no data or the timestamps could not be derived.</p>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.SequenceHandler.get_data_streamer","title":"get_data_streamer","text":"<pre><code>get_data_streamer(\n    topics=[],\n    start_timestamp_ns=None,\n    end_timestamp_ns=None,\n)\n</code></pre> <p>Opens a reading channel for iterating over the sequence data.</p> <p>The returned <code>SequenceDataStreamer</code> performs a K-way merge sort to provide a single, time-synchronized chronological stream of messages from multiple topics.</p> <p>Parameters:</p> Name Type Description Default <code>topics</code> <code>List[str]</code> <p>A subset of topic names to stream. If empty, all topics in the sequence are streamed.</p> <code>[]</code> <code>start_timestamp_ns</code> <code>Optional[int]</code> <p>The inclusive lower bound (t &gt;= start) for the time window in nanoseconds. The stream starts at the first message with a timestamp greater than or equal to this value.</p> <code>None</code> <code>end_timestamp_ns</code> <code>Optional[int]</code> <p>The exclusive upper bound (t &lt; end) for the time window in nanoseconds. The stream stops at the first message with a timestamp strictly less than this value.</p> <code>None</code> <p>Returns:</p> Type Description <code>SequenceDataStreamer</code> <p>A <code>SequenceDataStreamer</code> iterator yielding <code>(topic_name, message)</code> tuples.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided topic names do not exist or if the sequence contains no data.</p> Example <pre><code>from mosaicolabs import MosaicoClient\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Use a Handler to inspect the catalog\n    seq_handler = client.sequence_handler(\"mission_alpha\")\n    if seq_handler:\n        # Start a Unified Stream (K-Way Merge) for multi-sensor replay\n        streamer = seq_handler.get_data_streamer(\n            topics=[\"/gps\", \"/imu\"], # Optionally filter topics\n            # Optionally set the time window to extract\n            start_timestamp_ns=1738508778000000000,\n            end_timestamp_ns=1738509618000000000\n        )\n\n        # Peek at the start time (without consuming data)\n        print(f\"Recording starts at: {streamer.next_timestamp()}\")\n\n        # Start timed data-stream\n        for topic, msg in streamer:\n            print(f\"[{topic}] at {msg.timestamp_ns}: {type(msg.data).__name__}\")\n\n        # Once done, close the resources, topic handler and related reading channels (recommended).\n        seq_handler.close()\n</code></pre> Important <p>Every call to <code>get_data_streamer()</code> will automatically invoke <code>close()</code> on any previously spawned <code>SequenceDataStreamer</code> instance and its associated Apache Arrow Flight channels before initializing the new stream.</p> <p>Example:     <pre><code>seq_handler = client.sequence_handler(\"mission_alpha\")\n\n# Opens first stream\nstreamer_v1 = seq_handler.get_data_streamer(start_timestamp_ns=T1)\n\n# Calling this again automatically CLOSES streamer_v1 and opens a new channel\nstreamer_v2 = seq_handler.get_data_streamer(start_timestamp_ns=T2)\n\n# Using `streamer_v1` will raise a ValueError\nfor topic, msg in streamer_v1 # raises here!\n    pass\n</code></pre></p>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.SequenceHandler.get_topic_handler","title":"get_topic_handler","text":"<pre><code>get_topic_handler(topic_name, force_new_instance=False)\n</code></pre> <p>Get a specific <code>TopicHandler</code> for a child topic.</p> <p>Parameters:</p> Name Type Description Default <code>topic_name</code> <code>str</code> <p>The relative name of the topic (e.g., \"/camera/front\").</p> required <code>force_new_instance</code> <code>bool</code> <p>If <code>True</code>, bypasses the internal cache and recreates the handler.</p> <code>False</code> <p>Returns:</p> Type Description <code>TopicHandler</code> <p>A <code>TopicHandler</code> dedicated to the specified topic.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the topic is not available in this sequence or an internal connection error occurs.</p> Example <pre><code>import sys\nfrom mosaicolabs import MosaicoClient\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    seq_handler = client.sequence_handler(\"mission_alpha\")\n    if seq_handler:\n        # Use a Handler to inspect the catalog\n        top_handler = seq_handler.get_topic_handler(\"/front/imu\")\n        if top_handler:\n            print(f\"Sequence: {top_handler.sequence_name}\")\n            print(f\"        |Topic: {top_handler.sequence_name}:{top_handler.name}\")\n            print(f\"        |User metadata: {top_handler.user_metadata}\")\n            print(f\"        |Timestamp span: {top_handler.timestamp_ns_min} - {top_handler.timestamp_ns_max}\")\n            print(f\"        |Created {top_handler.created_datetime}\")\n            print(f\"        |Size (MB) {top_handler.total_size_bytes/(1024*1024)}\")\n\n        # Once done, close the resources, topic handler and related reading channels (recommended).\n        seq_handler.close()\n</code></pre>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.SequenceHandler.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Gracefully closes all cached topic handlers and active data streamers.</p> <p>This method should be called to release network and memory resources when the handler is no longer needed.</p> Example <pre><code>from mosaicolabs import MosaicoClient\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Use a Handler to inspect the catalog\n    seq_handler = client.sequence_handler(\"mission_alpha\")\n    if seq_handler:\n        # Perform operations\n        # ...\n\n        # Once done, close the resources, topic handler and related reading channels (recommended).\n        seq_handler.close()\n</code></pre>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.TopicHandler","title":"mosaicolabs.handlers.TopicHandler","text":"<pre><code>TopicHandler(\n    *,\n    client,\n    topic_model,\n    ticket,\n    timestamp_ns_min,\n    timestamp_ns_max,\n)\n</code></pre> <p>Represents an existing topic on the Mosaico platform.</p> <p>The <code>TopicHandler</code> provides a client-side interface for interacting with an individual data stream (topic). It allows users to inspect static metadata and system diagnostics (via the <code>Topic</code> model), and access the raw message stream through a dedicated <code>TopicDataStreamer</code>.</p> Obtaining a Handler <p>Direct instantiation of this class is discouraged. Use the <code>MosaicoClient.topic_handler()</code> factory method to retrieve an initialized handler.</p> <p>Internal constructor for TopicHandler.</p> <p>Do not call this directly. Users should retrieve instances via <code>MosaicoClient.topic_handler()</code>, or by using the <code>get_topic_handler()</code> method from the <code>SequenceHandler</code> instance of the parent senquence. Internal modules should use the <code>TopicHandler._connect()</code> factory.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>FlightClient</code> <p>The active FlightClient for remote operations.</p> required <code>topic_model</code> <code>Topic</code> <p>The underlying metadata and system info model for the topic.</p> required <code>ticket</code> <code>Ticket</code> <p>The remote resource ticket used for data retrieval.</p> required <code>timestamp_ns_min</code> <code>Optional[int]</code> <p>The lowest timestamp (in ns) available in this topic.</p> required <code>timestamp_ns_max</code> <code>Optional[int]</code> <p>The highest timestamp (in ns) available in this topic.</p> required"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.TopicHandler.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre> <p>The relative name of the topic (e.g., \"/front_cam/image_raw\").</p> <p>Returns:</p> Type Description <code>str</code> <p>The relative name of the topic.</p>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.TopicHandler.sequence_name","title":"sequence_name  <code>property</code>","text":"<pre><code>sequence_name\n</code></pre> <p>The name of the parent sequence containing this topic.</p> <p>Returns:</p> Type Description <code>str</code> <p>The name of the parent sequence.</p>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.TopicHandler.user_metadata","title":"user_metadata  <code>property</code>","text":"<pre><code>user_metadata\n</code></pre> <p>The user-defined metadata dictionary associated with this topic.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The user-defined metadata dictionary.</p>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.TopicHandler.created_datetime","title":"created_datetime  <code>property</code>","text":"<pre><code>created_datetime\n</code></pre> <p>The UTC timestamp indicating when the entity was created on the server.</p> <p>Returns:</p> Type Description <code>datetime</code> <p>The UTC timestamp indicating when the entity was created on the server.</p>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.TopicHandler.is_locked","title":"is_locked  <code>property</code>","text":"<pre><code>is_locked\n</code></pre> <p>Indicates if the resource is currently locked.</p> <p>A locked state typically occurs during active writing or maintenance operations, preventing deletion or structural modifications.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the resource is currently locked, False otherwise.</p>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.TopicHandler.chunks_number","title":"chunks_number  <code>property</code>","text":"<pre><code>chunks_number\n</code></pre> <p>The number of physical data chunks stored for this topic.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>The number of physical data chunks stored for this topic, or <code>None</code> if the server did not provide detailed storage statistics.</p>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.TopicHandler.ontology_tag","title":"ontology_tag  <code>property</code>","text":"<pre><code>ontology_tag\n</code></pre> <p>The ontology type identifier (e.g., 'imu', 'gnss').</p> <p>This corresponds to the <code>__ontology_tag__</code> defined in the <code>Serializable</code> class registry.</p> <p>Returns:</p> Type Description <code>str</code> <p>The ontology type identifier.</p>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.TopicHandler.serialization_format","title":"serialization_format  <code>property</code>","text":"<pre><code>serialization_format\n</code></pre> <p>The format used to serialize the topic data (e.g., 'arrow', 'image').</p> <p>This corresponds to the <code>SerializationFormat</code> enum.</p> <p>Returns:</p> Type Description <code>str</code> <p>The serialization format.</p>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.TopicHandler.total_size_bytes","title":"total_size_bytes  <code>property</code>","text":"<pre><code>total_size_bytes\n</code></pre> <p>The total physical storage footprint of the entity on the server in bytes.</p> <p>Returns:</p> Type Description <code>int</code> <p>The total physical storage footprint of the entity on the server in bytes.</p>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.TopicHandler.timestamp_ns_min","title":"timestamp_ns_min  <code>property</code>","text":"<pre><code>timestamp_ns_min\n</code></pre> <p>The lowest timestamp (nanoseconds) recorded in this topic.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>The lowest timestamp (nanoseconds) recorded in this topic, or <code>None</code> if the topic is empty or timestamps are unavailable.</p>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.TopicHandler.timestamp_ns_max","title":"timestamp_ns_max  <code>property</code>","text":"<pre><code>timestamp_ns_max\n</code></pre> <p>The highest timestamp (nanoseconds) recorded in this topic.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>The highest timestamp (nanoseconds) recorded in this topic, or <code>None</code> if the topic is empty or timestamps are unavailable.</p>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.TopicHandler.get_data_streamer","title":"get_data_streamer","text":"<pre><code>get_data_streamer(\n    start_timestamp_ns=None, end_timestamp_ns=None\n)\n</code></pre> <p>Opens a high-performance reading channel for iterating over this topic's data.</p>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.TopicHandler.get_data_streamer--stream-lifecycle-policy-single-active-streamer","title":"Stream Lifecycle Policy: Single-Active-Streamer","text":"<p>To optimize resource utilization and prevent backend socket exhaustion, this handler maintains at most one active stream at a time.</p> <p>Parameters:</p> Name Type Description Default <code>start_timestamp_ns</code> <code>Optional[int]</code> <p>The inclusive lower bound (t &gt;= start) in nanoseconds. The stream begins at the first message with a timestamp &gt;= this value.</p> <code>None</code> <code>end_timestamp_ns</code> <code>Optional[int]</code> <p>The exclusive upper bound (t &lt; end) in nanoseconds. The stream terminates before reaching any message with a timestamp &gt;= this value.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TopicDataStreamer</code> <code>TopicDataStreamer</code> <p>A chronological iterator for the requested data window.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the topic contains no data or the handler is in an invalid state.</p> Example <pre><code>from mosaicolabs import MosaicoClient, IMU\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Retrieve the topic handler using (e.g.) MosaicoClient\n    top_handler = client.topic_handler(\"mission_alpha\", \"/front/imu\")\n    if top_handler:\n        imu_stream = top_handler.get_data_streamer(\n            # Optionally set the time window to extract\n            start_timestamp_ns=1738508778000000000,\n            end_timestamp_ns=1738509618000000000\n        )\n\n        # Peek at the start time (without consuming data)\n        print(f\"Recording starts at: {streamer.next_timestamp()}\")\n\n        # Direct, low-overhead loop\n        for imu_msg in imu_stream:\n            process_sample(imu_msg.get_data(IMU)) # Some custom process function\n\n        # Once done, close the reading channel (recommended)\n        top_handler.close()\n</code></pre> Important <p>Every call to <code>get_data_streamer()</code> will automatically invoke <code>close()</code> on any previously spawned <code>TopicDataStreamer</code> instance and its associated Apache Arrow Flight channel before initializing the new stream.</p> <p>Example:     <pre><code>top_handler = client.topic_handler(\"mission_alpha\", \"/front/imu\")\n\n# Opens first stream\nstreamer_v1 = top_handler.get_data_streamer(start_timestamp_ns=T1)\n\n# Calling this again automatically CLOSES streamer_v1 and opens a new channel\nstreamer_v2 = top_handler.get_data_streamer(start_timestamp_ns=T2)\n\n# Using `streamer_v1` will raise a ValueError\nfor msg in streamer_v1 # raises here!\n    pass\n</code></pre></p>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.TopicHandler.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Terminates the active data streamer associated with this topic and releases allocated system resources.</p> <p>In the Mosaico architecture, a <code>TopicHandler</code> acts as a factory for <code>TopicDataStreamers</code>. Calling <code>close()</code> ensures that any background data fetching, buffering, or network sockets held by an active streamer are immediately shut down.</p> Note <ul> <li>If no streamer has been spawned (via <code>get_data_streamer</code>), this   method performs no operation and returns safely.</li> <li>Explicitly closing handlers is a best practice when iterating through   large datasets to prevent resource accumulation.</li> </ul> Example <pre><code>from mosaicolabs import MosaicoClient\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Access a specific sensor topic (e.g., IMU)\n    top_handler = client.topic_handler(\"mission_alpha\", \"/front/imu\")\n\n    if top_handler:\n        # Initialize a high-performance data stream\n        imu_stream = top_handler.get_data_streamer(\n            start_timestamp_ns=1738508778000000000,\n            end_timestamp_ns=1738509618000000000\n        )\n\n        # Consume data for ML training or analysis\n        # for msg in imu_stream: ...\n\n        # Release the streaming channel and backend resources\n        top_handler.close()\n</code></pre>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.SequenceDataStreamer","title":"mosaicolabs.handlers.SequenceDataStreamer","text":"<pre><code>SequenceDataStreamer(\n    *, sequence_name, client, topic_readers\n)\n</code></pre> <p>A unified, time-ordered iterator for reading multi-topic sequences.</p> <p>The <code>SequenceDataStreamer</code> performs a K-Way Merge across multiple topic streams to provide a single, coherent chronological view of an entire sequence. This is essential when topics have different recording rates or asynchronous sampling times.</p>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.SequenceDataStreamer--key-capabilities","title":"Key Capabilities","text":"<ul> <li>Temporal Slicing: Supports server-side filtering to stream data within specific     time windows (t &gt;= start and t &lt; end).</li> <li>Peek-Ahead: Provides the <code>next_timestamp()</code> method, allowing the system     to inspect chronological order without consuming the record\u2014a core requirement     for the K-way merge sorting algorithm.</li> </ul>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.SequenceDataStreamer--the-merge-algorithm","title":"The Merge Algorithm","text":"<p>This class manages multiple internal <code>TopicDataStreamer</code> instances. On every iteration, it:</p> <ol> <li>Peeks at the next available timestamp from every active topic stream.</li> <li>Selects the topic currently holding the lowest absolute timestamp.</li> <li>Yields that specific record and advances only the \"winning\" topic stream.</li> </ol> Obtaining a Streamer <p>Do not instantiate this class directly. Use the <code>SequenceHandler.get_data_streamer()</code> method to obtain a configured instance.</p> <p>Internal constructor for SequenceDataStreamer.</p> <p>Do not call this directly. Internal library modules should use the <code>SequenceDataStreamer._connect()</code> factory.</p> Example <pre><code>from mosaicolabs import MosaicoClient\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Use a Handler to inspect the catalog\n    seq_handler = client.sequence_handler(\"mission_alpha\")\n    if seq_handler:\n        # Start a Unified Stream (K-Way Merge) for multi-sensor replay\n        streamer = seq_handler.get_data_streamer(\n            topics=[\"/gps\", \"/imu\"], # Optionally filter topics\n            # Optionally set the time window to extract\n            start_timestamp_ns=1738508778000000000,\n            end_timestamp_ns=1738509618000000000\n        )\n\n        # Start timed data-stream\n        for topic, msg in streamer:\n            # Do some processing...\n\n        # Once done, close the resources, topic handler and related reading channels (recommended).\n        seq_handler.close()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sequence_name</code> <code>str</code> <p>The name of the sequence being streamed.</p> required <code>client</code> <code>FlightClient</code> <p>The active FlightClient for remote operations.</p> required <code>topic_readers</code> <code>Dict[str, TopicDataStreamer]</code> <p>A dictionary mapping topic names to their respective <code>TopicDataStreamer</code> instances.</p> required"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.SequenceDataStreamer.next_timestamp","title":"next_timestamp","text":"<pre><code>next_timestamp()\n</code></pre> <p>Peeks at the timestamp of the next chronological measurement without consuming the record.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>The minimum timestamp (nanoseconds) found across all active topics, or <code>None</code> if all streams are exhausted.</p> Example <pre><code>from mosaicolabs import MosaicoClient\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Use a Handler to inspect the catalog\n    seq_handler = client.sequence_handler(\"mission_alpha\")\n    if seq_handler:\n        # Start a Unified Stream (K-Way Merge) for multi-sensor replay\n        streamer = seq_handler.get_data_streamer(\n            topics=[\"/gps\", \"/imu\"], # Optionally filter topics\n            # Optionally set the time window to extract\n            start_timestamp_ns=1738508778000000000,\n            end_timestamp_ns=1738509618000000000\n        )\n\n        # Peek at the start time (without consuming data)\n        print(f\"Recording starts at: {streamer.next_timestamp()}\")\n\n        # Do some processing...\n\n        # Once done, close the resources, topic handler and related reading channels (recommended).\n        seq_handler.close()\n</code></pre>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.SequenceDataStreamer.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Gracefully terminates all underlying topic streams and releases allocated resources.</p> <p>This method iterates through all active <code>TopicDataStreamer</code> instances, ensuring that each remote connection is closed and local memory buffers are cleared.</p> Automatic Cleanup <p>In standard workflows, you do not need to call this manually. This function is automatically invoked by the <code>SequenceHandler.close()</code> method, which in turn is triggered by the <code>__exit__</code> logic of the parent <code>SequenceHandler</code> when used within a <code>with</code> context.</p>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.TopicDataStreamer","title":"mosaicolabs.handlers.TopicDataStreamer","text":"<pre><code>TopicDataStreamer(*, client, state)\n</code></pre> <p>An iterator that streams ontology records from a single topic.</p> <p>The <code>TopicDataStreamer</code> wraps a PyArrow Flight <code>DoGet</code> stream to fetch <code>RecordBatches</code> from the server and reconstruct individual <code>Message</code> objects. It is designed for efficient row-by-row iteration while providing peek-ahead capabilities for time-synchronized merging.</p>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.TopicDataStreamer--key-capabilities","title":"Key Capabilities","text":"<ul> <li>Temporal Slicing: Supports server-side filtering to stream data within specific     time windows (t &gt;= start and t &lt; end).</li> <li>Peek-Ahead: Provides the <code>next_timestamp()</code> method, allowing the system     to inspect chronological order without consuming the record\u2014a core requirement     for the K-way merge sorting performed by the <code>SequenceDataStreamer</code>.</li> </ul> Obtaining a Streamer <p>Users should typically not instantiate this class directly. The recommended way to obtain a streamer is via the <code>TopicHandler.get_data_streamer()</code> method.</p> <p>Internal constructor for TopicDataStreamer.</p> <p>Do not call this directly. Internal library modules should use the <code>TopicDataStreamer._connect()</code> or <code>TopicDataStreamer._connect_from_ticket()</code> factory methods instead.</p> Example <pre><code>from mosaicolabs import MosaicoClient, IMU\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Retrieve the topic handler using (e.g.) MosaicoClient\n    top_handler = client.topic_handler(\"mission_alpha\", \"/front/imu\")\n    if top_handler:\n        imu_stream = top_handler.get_data_streamer(\n            # Optionally set the time window to extract\n            start_timestamp_ns=1738508778000000000,\n            end_timestamp_ns=1738509618000000000\n        )\n\n        # Peek at the start time (without consuming data)\n        print(f\"Recording starts at: {streamer.next_timestamp()}\")\n\n        # Direct, low-overhead loop\n        for imu_msg in imu_stream:\n            # Do some processing...\n\n        # Once done, close the reading channel (recommended)\n        top_handler.close()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>FlightClient</code> <p>The active FlightClient used for remote operations.</p> required <code>state</code> <code>_TopicReadState</code> <p>The internal state object managing the Arrow reader and peek buffers.</p> required"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.TopicDataStreamer.ontology_tag","title":"ontology_tag  <code>property</code>","text":"<pre><code>ontology_tag\n</code></pre> <p>The ontology tag associated with this streamer.</p> <p>Returns:</p> Type Description <code>str</code> <p>The ontology tag.</p>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.TopicDataStreamer.name","title":"name","text":"<pre><code>name()\n</code></pre> <p>The name of the topic associated with this streamer.</p> <p>Returns:</p> Type Description <code>str</code> <p>The name of the topic.</p>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.TopicDataStreamer.next_timestamp","title":"next_timestamp","text":"<pre><code>next_timestamp()\n</code></pre> <p>Peeks at the timestamp of the next record without consuming it.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>The next timestamp in nanoseconds, or <code>None</code> if the stream is empty.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the data streamer instance has been closed.</p> Example <pre><code>from mosaicolabs import MosaicoClient, IMU\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Retrieve the topic handler using (e.g.) MosaicoClient\n    top_handler = client.topic_handler(\"mission_alpha\", \"/front/imu\")\n    if top_handler:\n        imu_stream = top_handler.get_data_streamer(\n            # Optionally set the time window to extract\n            start_timestamp_ns=1738508778000000000,\n            end_timestamp_ns=1738509618000000000\n        )\n\n        # Peek at the start time (without consuming data)\n        print(f\"Recording starts at: {streamer.next_timestamp()}\")\n\n        # Do some processing...\n\n        # Once done, close the reading channel (recommended)\n        top_handler.close()\n</code></pre>"},{"location":"SDK/API_reference/handlers/reading/#mosaicolabs.handlers.TopicDataStreamer.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Gracefully terminates the underlying Apache Arrow Flight stream and releases buffers.</p> Automatic Lifecycle Management <p>In most production workflows, manual invocation is not required. This method is automatically called by the parent <code>TopicHandler.close()</code>. If the handler is managed within a <code>with</code> context, the SDK ensures a top-down cleanup of the handler and its associated streamers upon exit.</p> Example <pre><code># Manual resource management (if not using 'with' block)\nstreamer = topic_handler.get_data_streamer()\ntry:\n    for meas in streamer:\n        process_robot_data(meas)\nfinally:\n    streamer.close()\n</code></pre>"},{"location":"SDK/API_reference/handlers/writing/","title":"Writing Data","text":""},{"location":"SDK/API_reference/handlers/writing/#mosaicolabs.handlers.config.WriterConfig","title":"mosaicolabs.handlers.config.WriterConfig  <code>dataclass</code>","text":"<pre><code>WriterConfig(\n    on_error, max_batch_size_bytes, max_batch_size_records\n)\n</code></pre> <p>Configuration settings for Sequence and Topic writers.</p> Internal Usage <p>This is currently not a user-facing class. It is automatically instantiated by the <code>MosaicoClient</code> when allocating new <code>SequenceWriter</code> instances via <code>sequence_create()</code>.</p> <p>This dataclass defines the operational parameters for data ingestion, controlling both the error recovery strategy and the performance-critical buffering logic used by the <code>SequenceWriter</code> and <code>TopicWriter</code>.</p>"},{"location":"SDK/API_reference/handlers/writing/#mosaicolabs.handlers.config.WriterConfig.on_error","title":"on_error  <code>instance-attribute</code>","text":"<pre><code>on_error\n</code></pre> <p>Determines the terminal behavior when an exception occurs during the ingestion  lifecycle.</p> <ul> <li>If set to <code>OnErrorPolicy.Delete</code>, the      system purges all data from the failed sequence.</li> <li>If set to <code>OnErrorPolicy.Report</code>, the      system retains the partial data in an unlocked state for debugging.</li> </ul>"},{"location":"SDK/API_reference/handlers/writing/#mosaicolabs.handlers.config.WriterConfig.max_batch_size_bytes","title":"max_batch_size_bytes  <code>instance-attribute</code>","text":"<pre><code>max_batch_size_bytes\n</code></pre> <p>The memory threshold in bytes before a data batch is flushed to the server.</p> <p>When the internal buffer of a <code>TopicWriter</code>  exceeds this value, it triggers a serialization and transmission event.  Larger values increase throughput by reducing network overhead but require more  client-side memory.</p>"},{"location":"SDK/API_reference/handlers/writing/#mosaicolabs.handlers.config.WriterConfig.max_batch_size_records","title":"max_batch_size_records  <code>instance-attribute</code>","text":"<pre><code>max_batch_size_records\n</code></pre> <p>The threshold in row (record) count before a data batch is flushed to the server.</p> <p>A flush is triggered whenever either this record limit or the  <code>max_batch_size_bytes</code> limit is reached, ensuring that data is transmitted  regularly even for topics with very small individual records.</p>"},{"location":"SDK/API_reference/handlers/writing/#mosaicolabs.handlers.SequenceWriter","title":"mosaicolabs.handlers.SequenceWriter","text":"<pre><code>SequenceWriter(\n    *,\n    sequence_name,\n    client,\n    connection_pool,\n    executor_pool,\n    metadata,\n    config,\n)\n</code></pre> <p>               Bases: <code>BaseSequenceWriter</code></p> <p>Orchestrates the creation and data ingestion lifecycle of a Mosaico Sequence.</p> <p>The <code>SequenceWriter</code> is the central controller for high-performance data writing. It manages the transition of a sequence through its lifecycle states: Create -&gt; Write -&gt; Finalize.</p>"},{"location":"SDK/API_reference/handlers/writing/#mosaicolabs.handlers.SequenceWriter--key-responsibilities","title":"Key Responsibilities","text":"<ul> <li>Lifecycle Management: Coordinates creation, finalization, or abort signals with the server.</li> <li>Resource Distribution: Implements a \"Multi-Lane\" architecture by distributing network connections     from a Connection Pool and thread executors from an Executor Pool to individual     <code>TopicWriter</code>     instances. This ensures strict isolation and maximum parallelism between     diverse data streams.</li> </ul> Usage Pattern <p>This class must be used within a <code>with</code> statement (Context Manager). The context entry triggers sequence registration on the server, while the exit handles automatic finalization or error cleanup based on the configured <code>OnErrorPolicy</code>.</p> Obtaining a Writer <p>Do not instantiate this class directly. Use the <code>MosaicoClient.sequence_create()</code> factory method.</p> <p>Internal constructor for SequenceWriter.</p> <p>Do not call this directly. Users must call <code>MosaicoClient.sequence_create()</code> to obtain an initialized writer.</p> Example <pre><code>from mosaicolabs import MosaicoClient, OnErrorPolicy\n\n# Open the connection with the Mosaico Client\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Start the Sequence Orchestrator\n    with client.sequence_create( # (1)!\n        sequence_name=\"mission_log_042\",\n        # Custom metadata for this data sequence.\n        metadata={\n            \"driver\": {\n                \"driver_id\": \"drv_sim_017\",\n                \"role\": \"validation\",\n                \"experience_level\": \"senior\",\n            },\n            \"location\": {\n                \"city\": \"Milan\",\n                \"country\": \"IT\",\n                \"facility\": \"Downtown\",\n                \"gps\": {\n                    \"lat\": 45.46481,\n                    \"lon\": 9.19201,\n                },\n            },\n        }\n        on_error = OnErrorPolicy.Delete # Default\n        ) as seq_writer:\n            # Start creating topics and pushing data\n            # (2)!\n\n    # Exiting the block automatically flushes all topic buffers, finalizes the sequence on the server\n    # and closes all connections and pools\n</code></pre> <ol> <li>See also: <code>MosaicoClient.sequence_create()</code></li> <li>See also:<ul> <li><code>SequenceWriter.topic_create()</code></li> <li><code>TopicWriter.push()</code></li> </ul> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>sequence_name</code> <code>str</code> <p>Unique name for the new sequence.</p> required <code>client</code> <code>FlightClient</code> <p>The primary control FlightClient.</p> required <code>connection_pool</code> <code>Optional[_ConnectionPool]</code> <p>Shared pool of data connections for parallel writing.</p> required <code>executor_pool</code> <code>Optional[_ExecutorPool]</code> <p>Shared pool of thread executors for asynchronous I/O.</p> required <code>metadata</code> <code>dict[str, Any]</code> <p>User-defined metadata dictionary.</p> required <code>config</code> <code>WriterConfig</code> <p>Operational configuration (e.g., error policies, batch sizes).</p> required"},{"location":"SDK/API_reference/handlers/writing/#mosaicolabs.handlers.SequenceWriter.sequence_status","title":"sequence_status  <code>property</code>","text":"<pre><code>sequence_status\n</code></pre> <p>Returns the current operational status of the sequence.</p> <p>Returns:</p> Type Description <code>SequenceStatus</code> <p>The <code>SequenceStatus</code>.</p>"},{"location":"SDK/API_reference/handlers/writing/#mosaicolabs.handlers.SequenceWriter.topic_writer_exists","title":"topic_writer_exists","text":"<pre><code>topic_writer_exists(topic_name)\n</code></pre> <p>Checks if a <code>TopicWriter</code> has already been initialized for the given name.</p> <p>Parameters:</p> Name Type Description Default <code>topic_name</code> <code>str</code> <p>The name of the topic to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the topic writer exists locally, False otherwise.</p>"},{"location":"SDK/API_reference/handlers/writing/#mosaicolabs.handlers.SequenceWriter.list_topic_writers","title":"list_topic_writers","text":"<pre><code>list_topic_writers()\n</code></pre> <p>Returns the list of all topic names currently managed by this writer.</p>"},{"location":"SDK/API_reference/handlers/writing/#mosaicolabs.handlers.SequenceWriter.get_topic_writer","title":"get_topic_writer","text":"<pre><code>get_topic_writer(topic_name)\n</code></pre> <p>Retrieves an existing <code>TopicWriter</code> instance from the internal cache.</p> <p>This method is particularly useful when ingesting data from unified recording formats where different sensor types (e.g., Vision, IMU, Odometry) are stored chronologically in a single stream or file.</p> <p>In these scenarios, messages for various topics appear in an interleaved fashion. Using <code>get_topic_writer</code> allows the developer to:</p> <ul> <li>Reuse Buffers: Efficiently switch between writers for different sensor streams.</li> <li>Ensure Data Ordering: Maintain a consistent batching logic for each topic as   you iterate through a mixed-content log.</li> <li>Optimize Throughput: Leverage Mosaico's background I/O by routing all data   for a specific identifier through a single, persistent writer instance.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>topic_name</code> <code>str</code> <p>The unique name or identifier of the topic writer to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[TopicWriter]</code> <p>The <code>TopicWriter</code> instance if it has been previously initialized within this <code>SequenceWriter</code> context, otherwise <code>None</code>.</p> Example <p>Processing a generic interleaved sensor log (like a ROS bag or a custom JSON log):</p> <pre><code>from mosaicolabs import SequenceWriter, IMU, Image\n\n# Topic to Ontology Mapping: Defines the schema for each sensor stream\n# Example: {\"/camera\": Image, \"/imu\": IMU}\ntopic_to_ontology = { ... }\n\n# Adapter Factory: Maps raw sensor payloads to Mosaico Ontology instances\n# Example: {\"/imu\": lambda p: IMU(acceleration=Vector3d.from_list(p['acc']), ...)}\nadapter = { ... }\n\nwith client.sequence_create(\"physical_ai_trial_01\") as seq_writer:\n    # log_iterator represents an interleaved stream (e.g., ROSbags, MCAP, or custom logs).\n    for ts, topic, payload in log_iterator:\n\n        # Access the topic-specific buffer.\n        # get_topic_writer retrieves a persistent writer from the internal cache\n        twriter = seq_writer.get_topic_writer(topic)\n\n        if twriter is None:\n            # Dynamic Topic Registration.\n            # If the topic is encountered for the first time, register it using the\n            # pre-defined Ontology type to ensure data integrity.\n            twriter = seq_writer.topic_create(\n                topic_name=topic,\n                ontology_type=topic_to_ontology[topic]\n            )\n\n        # Data Transformation &amp; Ingestion.\n        # The adapter converts the raw payload into a validated Mosaico object.\n        # push() handles high-performance batching and asynchronous I/O to the rust backend.\n        twriter.push( # (1)!\n            message=Message(\n                timestamp_ns=ts,\n                data=adapter[topic](payload),\n            )\n        )\n\n# SequenceWriter automatically calls _finalize() on all internal TopicWriters,\n# guaranteeing that every sensor measurement is safely committed to the platform.\n</code></pre> <ol> <li>See also: <code>TopicWriter.push()</code></li> </ol>"},{"location":"SDK/API_reference/handlers/writing/#mosaicolabs.handlers.SequenceWriter.topic_create","title":"topic_create","text":"<pre><code>topic_create(topic_name, metadata, ontology_type)\n</code></pre> <p>Creates a new topic within the active sequence.</p> <p>This method performs a \"Multi-Lane\" resource assignment, granting the new <code>TopicWriter</code>, its own connection from the pool and a dedicated executor for background serialization and I/O.</p> <p>Parameters:</p> Name Type Description Default <code>topic_name</code> <code>str</code> <p>The relative name of the new topic.</p> required <code>metadata</code> <code>dict[str, Any]</code> <p>Topic-specific user metadata.</p> required <code>ontology_type</code> <code>Type[Serializable]</code> <p>The <code>Serializable</code> data model class defining the topic's schema.</p> required <p>Returns:</p> Type Description <code>Optional[TopicWriter]</code> <p>A <code>TopicWriter</code> instance configured for parallel ingestion, or <code>None</code> if creation fails.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If called outside of a <code>with</code> block.</p> Example <pre><code>with MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Start the Sequence Orchestrator\n    with client.sequence_create(...) as seq_writer: # (1)!\n        # Create individual Topic Writers\n        # Each writer gets its own assigned resources from the pools\n        imu_writer = seq_writer.topic_create(\n            topic_name=\"sensors/imu\", # The univocal topic name\n            metadata={ # The topic/sensor custom metadata\n                \"vendor\": \"inertix-dynamics\",\n                \"model\": \"ixd-f100\",\n                \"firmware_version\": \"1.2.0\",\n                \"serial_number\": \"IMUF-9A31D72X\",\n                \"calibrated\":\"false\",\n            },\n            ontology_type=IMU, # The ontology type stored in this topic\n        )\n\n        # Another individual topic writer for the GPS device\n        gps_writer = seq_writer.topic_create(\n            topic_name=\"sensors/gps\", # The univocal topic name\n            metadata={ # The topic/sensor custom metadata\n                \"role\": \"primary_gps\",\n                \"vendor\": \"satnavics\",\n                \"model\": \"snx-g500\",\n                \"firmware_version\": \"3.2.0\",\n                \"serial_number\": \"GPS-7C1F4A9B\",\n                \"interface\": { # (2)!\n                    \"type\": \"UART\",\n                    \"baudrate\": 115200,\n                    \"protocol\": \"NMEA\",\n                },\n            }, # The topic/sensor custom metadata\n            ontology_type=GPS, # The ontology type stored in this topic\n        )\n\n        # Push data\n        imu_writer.push( # (3)!\n            message=Message(\n                timestamp_ns=1700000000000,\n                data=IMU(acceleration=Vector3d(x=0, y=0, z=9.81), ...),\n            )\n        )\n        # ...\n\n    # Exiting the block automatically flushes all topic buffers, finalizes the sequence on the server\n    # and closes all connections and pools\n</code></pre> <ol> <li>See also: <code>MosaicoClient.sequence_create()</code></li> <li>The metadata fields will be queryable via the <code>Query</code> mechanism. The mechanism allows creating query expressions like: <code>Topic.Q.user_metadata[\"interface.type\"].eq(\"UART\")</code>.     See also:<ul> <li><code>mosaicolabs.models.platform.Topic</code></li> <li><code>mosaicolabs.models.query.builders.QueryTopic</code>.</li> </ul> </li> <li>See also: <code>TopicWriter.push()</code></li> </ol>"},{"location":"SDK/API_reference/handlers/writing/#mosaicolabs.handlers.TopicWriter","title":"mosaicolabs.handlers.TopicWriter","text":"<pre><code>TopicWriter(\n    *, topic_name, sequence_name, client, state, config\n)\n</code></pre> <p>Manages a high-performance data stream for a single Mosaico topic.</p> <p>The <code>TopicWriter</code> abstracts the complexity of the PyArrow Flight <code>DoPut</code> protocol, handling internal buffering, serialization, and network transmission. It accumulates records in memory and automatically flushes them to the server when configured batch limits\u2014defined by either byte size or record count\u2014are exceeded.</p>"},{"location":"SDK/API_reference/handlers/writing/#mosaicolabs.handlers.TopicWriter--performance-parallelism","title":"Performance &amp; Parallelism","text":"<p>If an executor pool is provided by the parent client, the <code>TopicWriter</code> performs data serialization on background threads, preventing I/O operations from blocking the main application logic.</p> Obtaining a Writer <p>End-users should not instantiate this class directly. Use the <code>SequenceWriter.topic_create()</code> factory method to obtain an active writer.</p> <p>Internal constructor for TopicWriter.</p> <p>Do not call this directly. Internal library modules should use the <code>_create()</code> factory. Users must call <code>SequenceWriter.topic_create()</code> to obtain an initialized writer.</p> Example <pre><code>with MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Start the Sequence Orchestrator\n    with client.sequence_create(...) as seq_writer: # (1)!\n        # Create individual Topic Writers\n        # Each writer gets its own assigned resources from the pools\n        imu_writer = seq_writer.topic_create( # (2)!\n            topic_name=\"sensors/imu\", # The univocal topic name\n            metadata={ # The topic/sensor custom metadata\n                \"vendor\": \"inertix-dynamics\",\n                \"model\": \"ixd-f100\",\n                \"firmware_version\": \"1.2.0\",\n                \"serial_number\": \"IMUF-9A31D72X\",\n                \"calibrated\":\"false\",\n            },\n            ontology_type=IMU, # The ontology type stored in this topic\n        )\n\n        # Push data...\n        imu_writer.push( # (3)!\n            message=Message(\n                data=IMU(acceleration=Vector3d(x=0, y=0, z=9.81), ...),\n                timestamp_ns=1700000000000,\n            )\n        )\n    # Exiting the seq_writer `with` block, the `_finalize()` method of all topic writers is called.\n</code></pre> <ol> <li>See also: <code>MosaicoClient.sequence_create()</code></li> <li>See also: <code>SequenceWriter.topic_create()</code></li> <li>See also: <code>TopicWriter.push()</code></li> </ol> <p>Parameters:</p> Name Type Description Default <code>topic_name</code> <code>str</code> <p>The name of the specific topic.</p> required <code>sequence_name</code> <code>str</code> <p>The name of the parent sequence.</p> required <code>client</code> <code>FlightClient</code> <p>The FlightClient used for data transmission.</p> required <code>state</code> <code>_TopicWriteState</code> <p>The internal state object managing buffers and streams.</p> required <code>config</code> <code>WriterConfig</code> <p>Operational configuration for batching and error handling.</p> required"},{"location":"SDK/API_reference/handlers/writing/#mosaicolabs.handlers.TopicWriter.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre> <p>Returns the name of the topic</p>"},{"location":"SDK/API_reference/handlers/writing/#mosaicolabs.handlers.TopicWriter.push","title":"push","text":"<pre><code>push(message)\n</code></pre> <p>Adds a new record to the internal write buffer.</p> <p>Records are accumulated in memory. If a push triggers a batch limit, the buffer is automatically serialized and transmitted to the server.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>A pre-constructed Message object.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If a buffer flush fails during the operation.</p> Example <pre><code>with MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Start the Sequence Orchestrator\n    with client.sequence_create(...) as seq_writer: # (1)!\n        # Create individual Topic Writers\n        # Each writer gets its own assigned resources from the pools\n        imu_writer = seq_writer.topic_create( # (2)!\n            topic_name=\"sensors/imu\", # The univocal topic name\n            metadata={ # The topic/sensor custom metadata\n                \"vendor\": \"inertix-dynamics\",\n                \"model\": \"ixd-f100\",\n                \"firmware_version\": \"1.2.0\",\n                \"serial_number\": \"IMUF-9A31D72X\",\n                \"calibrated\":\"false\",\n            },\n            ontology_type=IMU, # The ontology type stored in this topic\n        )\n\n        # Another individual topic writer for the GPS device\n        gps_writer = seq_writer.topic_create(\n            topic_name=\"sensors/gps\", # The univocal topic name\n            metadata={ # The topic/sensor custom metadata\n                \"role\": \"primary_gps\",\n                \"vendor\": \"satnavics\",\n                \"model\": \"snx-g500\",\n                \"firmware_version\": \"3.2.0\",\n                \"serial_number\": \"GPS-7C1F4A9B\",\n                \"interface\": {\n                    \"type\": \"UART\",\n                    \"baudrate\": 115200,\n                    \"protocol\": \"NMEA\",\n                },\n            }, # The topic/sensor custom metadata\n            ontology_type=GPS, # The ontology type stored in this topic\n        )\n\n        gps_msg = Message(timestamp_ns=1700000000100, data=GPS(...))\n        gps_writer.push(message=gps_msg)\n    # Exiting the seq_writer `with` block, the `_finalize()` method of all topic writers is called.\n</code></pre> <ol> <li>See also: <code>MosaicoClient.sequence_create()</code></li> <li>See also: <code>SequenceWriter.topic_create()</code></li> </ol>"},{"location":"SDK/API_reference/handlers/writing/#mosaicolabs.handlers.TopicWriter.is_active","title":"is_active","text":"<pre><code>is_active()\n</code></pre> <p>Returns <code>True</code> if the writing stream is open and the writer accepts new messages.</p>"},{"location":"SDK/API_reference/models/base/","title":"Base Models and Mixins","text":""},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.BaseModel","title":"mosaicolabs.models.BaseModel","text":"<p>               Bases: <code>BaseModel</code></p> <p>The root base class for SDK data models.</p> <p>It inherits from <code>pydantic.BaseModel</code> to provide runtime type checking and initialization logic. It adds a hook for defining the corresponding PyArrow structure (<code>__msco_pyarrow_struct__</code>), enabling the SDK to auto-generate Flight schemas.</p> Note <p>This class has been added mainly for wrapping pydantic, toward future implementation where other fields mapping and checks are implemented</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Serializable","title":"mosaicolabs.models.Serializable","text":"<p>               Bases: <code>BaseModel</code>, <code>_QueryProxyMixin</code></p> <p>The base class for all Mosaico ontology data payloads.</p> <p>This class serves as the root for every sensor and data type in the Mosaico ecosystem. By inheriting from <code>Serializable</code>, data models are automatically compatible with the platform's storage, querying, and serialization engines.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Serializable--dynamic-attributes-injection","title":"Dynamic Attributes Injection","text":"<p>When you define a subclass, several key attributes are automatically managed or required. Understanding these is essential for customizing how your data is treated by the platform:</p> <ul> <li> <p><code>__serialization_format__</code>:     Determines the batching strategy and storage optimization.</p> <ul> <li>Role: It tells the <code>SequenceWriter</code> whether to flush data based on byte size (optimal for heavy data like <code>Images</code>) or record count (optimal for light telemetry like <code>IMU</code>).</li> <li>Default: <code>SerializationFormat.Default</code>.</li> </ul> </li> <li> <p><code>__ontology_tag__</code>:     The unique string identifier for the class (e.g., <code>\"imu\"</code>, <code>\"gps_raw\"</code>).</p> <ul> <li>Role: This tag is used in the global registry to reconstruct objects from raw platform data.</li> <li>Generation: If not explicitly provided, it is auto-generated by converting the class name from <code>CamelCase</code> to <code>snake_case</code>.</li> </ul> </li> <li> <p><code>__class_type__</code>:     A reference to the concrete class itself.</p> <ul> <li>Role: Injected during initialization to facilitate polymorphic instantiation and safe type-checking when extracting data from a <code>Message</code>.</li> </ul> </li> </ul>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Serializable--requirements-for-custom-ontologies","title":"Requirements for Custom Ontologies","text":"<p>To create a valid custom ontology, your subclass must:</p> <ol> <li>Inherit from <code>Serializable</code>.</li> <li>Define a <code>__msco_pyarrow_struct__</code> attribute using <code>pa.StructType</code> to specify the physical schema.</li> <li>Define the class fields (using Pydantic syntax) matching the Arrow structure.</li> </ol> Automatic Registration <p>Any subclass of <code>Serializable</code> is automatically registered in the global Mosaico registry upon definition. This enables the use of the factory methods and the <code>.Q</code> query proxy immediately.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Serializable.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Serializable.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Message","title":"mosaicolabs.models.Message","text":"<p>               Bases: <code>BaseModel</code></p> <p>The universal transport envelope for Mosaico data.</p> <p>The <code>Message</code> class wraps a polymorphic <code>Serializable</code> payload with middleware metadata, such as recording timestamps and headers.</p> <p>Attributes:</p> Name Type Description <code>timestamp_ns</code> <code>Optional[int]</code> <p>Message/Sensor acquisition timestamp in nanoseconds (resambles the data ontology high precision time header).</p> <code>data</code> <code>Serializable</code> <p>The actual ontology data payload (e.g., an IMU or GPS instance).</p> <code>recording_timestamp_ns</code> <code>Optional[int]</code> <p>Recording timestamp in nanoseconds. This is the timestamp in which the message was recorded in the receiving store file (like rosbags, parquet files, etc.), different from sensor acquisition time.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Message.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data\n</code></pre> <p>The actual ontology data payload (e.g., an IMU or GPS instance).</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Message.timestamp_ns","title":"timestamp_ns  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timestamp_ns = None\n</code></pre> <p>Message/Sensor acquisition timestamp in nanoseconds (resambles the data ontology high precision time header).</p> <p>Can be omitted if the data ontology already contains the timestamp (e.g. <code>data.header.stamp</code>) or the <code>recording_timestamp_ns</code> is set. If all timestamps data are None, the message will be rejected and a <code>ValueError</code> is raised.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Message.recording_timestamp_ns","title":"recording_timestamp_ns  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>recording_timestamp_ns = None\n</code></pre> <p>Recording timestamp in nanoseconds (different from sensor acquisition time).</p> <p>This is the timestamp in which the message was recorded in the receiving store file (like rosbags, parquet files, etc.)</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Message.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(context)\n</code></pre> <p>Validates the message structure after initialization.</p> <p>Ensures that there are no field name collisions between the envelope (e.g., <code>timestamp_ns</code>) and the data payload.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Message.ontology_type","title":"ontology_type","text":"<pre><code>ontology_type()\n</code></pre> <p>Retrieves the class type of the ontology object stored in the <code>data</code> field.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Message.ontology_tag","title":"ontology_tag","text":"<pre><code>ontology_tag()\n</code></pre> <p>Returns the unique ontology tag name associated with the object in the data field.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Message.get_data","title":"get_data","text":"<pre><code>get_data(target_type)\n</code></pre> <p>Safe, type-hinted accessor for the data payload.</p> <p>Parameters:</p> Name Type Description Default <code>target_type</code> <code>Type[TSerializable]</code> <p>The expected <code>Serializable</code> subclass type.</p> required <p>Returns:</p> Type Description <code>TSerializable</code> <p>The data object cast to the requested type.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the actual data type does not match the requested <code>target_type</code>.</p> Example <pre><code># Get the IMU data from the message\nimage_data = message.get_data(Image)\nprint(f\"Message time: {message.timestamp_ns}: Sensor time: {image_data.header.stamp.to_nanoseconds()}\")\nprint(f\"Message time: {message.timestamp_ns}: Image size: {image_data.height}x{image_data.width}\")\n# Show the image\nimage_data.to_pillow().show()\n\n# Get the Floating64 data from the message\nfloating64_data = message.get_data(Floating64)\nprint(f\"Message time: {message.timestamp_ns}: Data time: {floating64_data.header.stamp.to_nanoseconds()}\")\nprint(f\"Message time: {message.timestamp_ns}: Data value: {floating64_data.data}\")\n</code></pre>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Message.from_dataframe_row","title":"from_dataframe_row  <code>staticmethod</code>","text":"<pre><code>from_dataframe_row(\n    row, topic_name, timestamp_column_name=\"timestamp_ns\"\n)\n</code></pre> <p>Reconstructs a <code>Message</code> object from a flattened DataFrame row.</p> <p>In the Mosaico Data Platform, DataFrames represent topics using a nested naming convention: <code>{topic}.{tag}.{field}</code>. This method performs Smart Reconstruction by:</p> <ol> <li>Topic Validation: Verifying if any columns associated with the <code>topic_name</code>    exist in the row.</li> <li>Tag Inference: Inspecting the column headers to automatically determine    the original ontology tag (e.g., <code>\"imu\"</code>).</li> <li>Data Extraction: Stripping prefixes and re-nesting the flat columns    into their original dictionary structures.</li> <li>Type Casting: Re-instantiating the specific <code>Serializable</code>    subclass and wrapping it in a <code>Message</code> envelope.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>row</code> <code>Series</code> <p>A single row from a Pandas DataFrame, representing a point in time across one or more topics.</p> required <code>topic_name</code> <code>str</code> <p>The name of the specific topic to extract from the row.</p> required <code>timestamp_column_name</code> <code>str</code> <p>The name of the column containing the timestamp.</p> <code>'timestamp_ns'</code> <p>Returns:</p> Type Description <code>Optional[Message]</code> <p>A reconstructed <code>Message</code> instance containing the typed ontology data, or <code>None</code> if the topic is not present or the data is incomplete.</p> Example <pre><code># Obtain a dataframe with DataFrameExtractor\nfrom mosaicolabs import MosaicoClient, IMU, Image\nfrom mosaicolabs.ml import DataFrameExtractor, SyncTransformer\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    sequence_handler = client.get_sequence_handler(\"example_sequence\")\n    for df in DataFrameExtractor(sequence_handler).to_pandas_chunks(\n        topics = [\"/front/imu\", \"/front/camera/image_raw\"]\n    ):\n        # Do something with the dataframe.\n        # For example, you can sync the data using the `SyncTransformer`:\n        sync_transformer = SyncTransformer(\n            target_fps = 30, # resample at 30 Hz and fill the Nans with a Hold policy\n        )\n        synced_df = sync_transformer.transform(df)\n\n        # Reconstruct the image message from a dataframe row\n        image_msg = Message.from_dataframe_row(synced_df, \"/front/camera/image_raw\")\n        image_data = image_msg.get_data(Image)\n        # Show the image\n        image_data.to_pillow().show()\n        # ...\n</code></pre>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Time","title":"mosaicolabs.models.Time","text":"<p>               Bases: <code>BaseModel</code></p> <p>A high-precision time representation designed to prevent precision loss.</p> <p>The <code>Time</code> class splits a timestamp into a 64-bit integer for seconds and a 32-bit unsigned integer for nanoseconds. This dual-integer structure follows robotics standards (like ROS) to ensure temporal accuracy that standard 64-bit floating-point timestamps cannot maintain over long durations.</p> <p>Attributes:</p> Name Type Description <code>sec</code> <code>int</code> <p>Seconds since the epoch (Unix time).</p> <code>nanosec</code> <code>int</code> <p>Nanoseconds component within the current second, ranging from 0 to 999,999,999.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Time.sec","title":"sec  <code>instance-attribute</code>","text":"<pre><code>sec\n</code></pre> <p>Seconds since the epoch (Unix time).</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Time.nanosec","title":"nanosec  <code>instance-attribute</code>","text":"<pre><code>nanosec\n</code></pre> <p>Nanoseconds component within the current second, ranging from 0 to 999,999,999.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Time.validate_nanosec","title":"validate_nanosec  <code>classmethod</code>","text":"<pre><code>validate_nanosec(v)\n</code></pre> <p>Ensures nanoseconds are within the valid [0, 1e9) range.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Time.from_float","title":"from_float  <code>classmethod</code>","text":"<pre><code>from_float(ftime)\n</code></pre> <p>Factory method to create a Time object from a float (seconds since epoch).</p> <p>This method carefully handles floating-point artifacts by using rounding for the fractional part to ensure stable nanosecond conversion.</p> <p>Parameters:</p> Name Type Description Default <code>ftime</code> <code>float</code> <p>Total seconds since epoch (e.g., from <code>time.time()</code>).</p> required <p>Returns:</p> Type Description <code>Time</code> <p>A normalized <code>Time</code> instance.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Time.from_milliseconds","title":"from_milliseconds  <code>classmethod</code>","text":"<pre><code>from_milliseconds(total_milliseconds)\n</code></pre> <p>Factory method to create a Time object from a total count of milliseconds.</p> <p>Parameters:</p> Name Type Description Default <code>total_milliseconds</code> <code>int</code> <p>Total time elapsed in milliseconds.</p> required <p>Returns:</p> Type Description <code>Time</code> <p>A <code>Time</code> instance with split sec/nanosec components.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Time.from_nanoseconds","title":"from_nanoseconds  <code>classmethod</code>","text":"<pre><code>from_nanoseconds(total_nanoseconds)\n</code></pre> <p>Factory method to create a Time object from a total count of nanoseconds.</p> <p>Parameters:</p> Name Type Description Default <code>total_nanoseconds</code> <code>int</code> <p>Total time elapsed in nanoseconds.</p> required <p>Returns:</p> Type Description <code>Time</code> <p>A <code>Time</code> instance with split sec/nanosec components.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Time.from_datetime","title":"from_datetime  <code>classmethod</code>","text":"<pre><code>from_datetime(dt)\n</code></pre> <p>Factory method to create a Time object from a Python <code>datetime</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>datetime</code> <p>A standard Python <code>datetime</code> object.</p> required <p>Returns:</p> Type Description <code>Time</code> <p>A <code>Time</code> instance reflecting the datetime's timestamp.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Time.now","title":"now  <code>classmethod</code>","text":"<pre><code>now()\n</code></pre> <p>Factory method that returns the current system UTC time in high precision.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Time.to_float","title":"to_float","text":"<pre><code>to_float()\n</code></pre> <p>Converts the high-precision time to a float.</p> Precision Loss <p>Converting to a 64-bit float may result in the loss of nanosecond precision due to mantissa limitations.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Time.to_nanoseconds","title":"to_nanoseconds","text":"<pre><code>to_nanoseconds()\n</code></pre> <p>Converts the time to a total integer of nanoseconds.</p> <p>This conversion preserves full precision.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Time.to_milliseconds","title":"to_milliseconds","text":"<pre><code>to_milliseconds()\n</code></pre> <p>Converts the time to a total integer of milliseconds.</p> <p>This conversion preserves full precision.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Time.to_datetime","title":"to_datetime","text":"<pre><code>to_datetime()\n</code></pre> <p>Converts the time to a Python UTC <code>datetime</code> object.</p> Microsecond Limitation <p>Python's <code>datetime</code> objects typically support microsecond precision; nanosecond data below that threshold will be truncated.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Header","title":"mosaicolabs.models.Header","text":"<p>               Bases: <code>BaseModel</code></p> <p>Standard metadata header used to provide context to ontology data.</p> <p>The <code>Header</code> structure provides spatial and temporal context, matching common industry standards for sensor data. It is typically injected into sensor models via the <code>HeaderMixin</code>.</p> <p>Attributes:</p> Name Type Description <code>stamp</code> <code>Time</code> <p>The high-precision <code>Time</code> of data acquisition.</p> <code>frame_id</code> <code>Optional[str]</code> <p>A string identifier for the coordinate frame (spatial context).</p> <code>seq</code> <code>Optional[int]</code> <p>An optional sequence ID, primarily used for legacy tracking.</p> Nullable Fields <p>In the underlying PyArrow schema, all header fields are explicitly marked as <code>nullable=True</code>. This ensures that empty headers are correctly deserialized as <code>None</code> rather than default-initialized objects.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Header.stamp","title":"stamp  <code>instance-attribute</code>","text":"<pre><code>stamp\n</code></pre> <p>The high-precision <code>Time</code> of data acquisition.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Header.frame_id","title":"frame_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>frame_id = None\n</code></pre> <p>A string identifier for the coordinate frame (spatial context).</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.Header.seq","title":"seq  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>seq = None\n</code></pre> <p>An optional sequence ID, primarily used for legacy tracking.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.HeaderMixin","title":"mosaicolabs.models.HeaderMixin","text":"<p>               Bases: <code>BaseModel</code></p> <p>A mixin that injects a standard <code>header</code> field into any inheriting ontology model.</p> <p>The <code>HeaderMixin</code> is used to add standard metadata (such as acquisition timestamps or frame IDs) to a sensor model through composition. It ensures that the underlying PyArrow schema remains synchronized with the Pydantic data model.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.HeaderMixin--dynamic-schema-injection","title":"Dynamic Schema Injection","text":"<p>This mixin uses the <code>__init_subclass__</code> hook to perform a Schema Append operation:</p> <ol> <li>It inspects the child class's existing <code>__msco_pyarrow_struct__</code>.</li> <li>It appends a <code>header</code> field of type <code>Header</code>.</li> <li>It reconstructs the final <code>pa.struct</code> for the class.</li> </ol> Collision Safety <p>The mixin performs a collision check during class definition. If the child class already defines a <code>header</code> field in its PyArrow struct, a <code>ValueError</code> will be raised to prevent schema corruption.</p> <p>Attributes:</p> Name Type Description <code>header</code> <code>Optional[Header]</code> <p>An optional <code>Header</code> object containing standard metadata.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.HeaderMixin--queryability","title":"Querying with the <code>.Q</code> Proxy","text":"<p>When constructing a <code>QueryOntologyCatalog</code>, the <code>header</code> component is fully queryable across any model inheriting from this mixin.</p> Field Access Path Queryable Type Supported Operators <code>&lt;Model&gt;.Q.header.seq</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>&lt;Model&gt;.Q.header.stamp.sec</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>&lt;Model&gt;.Q.header.stamp.nanosec</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>&lt;Model&gt;.Q.header.frame_id</code> <code>String</code> <code>.eq()</code>, <code>.neq()</code>, <code>.match()</code>, <code>.in_()</code> Universal Compatibility <p>The <code>&lt;Model&gt;</code> placeholder represents any Mosaico ontology class (e.g., <code>IMU</code>, <code>GPS</code>, <code>Floating64</code>) or any custom user-defined <code>Serializable</code> class that inherits from <code>HeaderMixin</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, IMU, Floating64, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter IMU data by a specific acquisition second\n    qresponse = client.query(\n        QueryOntologyCatalog(IMU.Q.header.stamp.sec.lt(1770282868))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter primitive Floating64 telemetry by frame identifier\n    qresponse = client.query(\n        QueryOntologyCatalog(Floating64.Q.header.frame_id.eq(\"robot_base\"))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.HeaderMixin.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.HeaderMixin.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.CovarianceMixin","title":"mosaicolabs.models.CovarianceMixin","text":"<p>               Bases: <code>BaseModel</code></p> <p>A mixin that adds uncertainty fields (<code>covariance</code> and <code>covariance_type</code>) to data models.</p> <p>This is particularly useful for complex sensors like IMUs, Odometry, or GNSS receivers that provide multidimensional uncertainty matrices along with their primary measurements.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.CovarianceMixin--dynamic-schema-injection","title":"Dynamic Schema Injection","text":"<p>This mixin uses the <code>__init_subclass__</code> hook to perform a Schema Append operation:</p> <ol> <li>It inspects the child class's existing <code>__msco_pyarrow_struct__</code>.</li> <li>It appends a <code>covariance</code> and <code>covariance_type</code> fields.</li> <li>It reconstructs the final <code>pa.struct</code> for the class.</li> </ol> Collision Safety <p>The mixin performs a collision check during class definition. If the child class already defines a <code>covariance</code> or <code>covariance_type</code> field in its PyArrow struct, a <code>ValueError</code> will be raised to prevent schema corruption.</p> <p>Attributes:</p> Name Type Description <code>covariance</code> <code>Optional[List[float]]</code> <p>Optional list of 64-bit floats representing the flattened matrix.</p> <code>covariance_type</code> <code>Optional[int]</code> <p>Optional 16-bit integer representing the covariance enum.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.CovarianceMixin--queryability","title":"Querying with the <code>.Q</code> Proxy","text":"<p>When constructing a <code>QueryOntologyCatalog</code>, the class fields are queryable across any model inheriting from this mixin, according to the following table:</p> Field Access Path Queryable Type Supported Operators <code>&lt;Model&gt;.Q.covariance_type</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>&lt;Model&gt;.Q.covariance</code> Non-Queryable None Universal Compatibility <p>The <code>&lt;Model&gt;</code> placeholder represents any Mosaico ontology class (e.g., <code>IMU</code>, <code>GPS</code>, <code>Floating64</code>) or any custom user-defined <code>Serializable</code> class that inherits from <code>HeaderMixin</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, IMU, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter IMU data by a specific acquisition second\n    # `FROM_CALIBRATED_PROCEDURE` is some enum value defined by the user\n    qresponse = client.query(\n        QueryOntologyCatalog(IMU.Q.covariance_type.eq(FROM_CALIBRATED_PROCEDURE))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.CovarianceMixin.covariance","title":"covariance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>covariance = None\n</code></pre> <p>Optional list of 64-bit floats representing the flattened matrix.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.CovarianceMixin.covariance--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"Non-Queryable <p>The field is not queryable with the <code>.Q</code> Proxy.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.CovarianceMixin.covariance_type","title":"covariance_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>covariance_type = None\n</code></pre> <p>Optional 16-bit integer representing the covariance enum.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with the optional covariance type attribute.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.CovarianceMixin.covariance_type--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>CovarianceMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>covariance_type</code> component.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.VarianceMixin","title":"mosaicolabs.models.VarianceMixin","text":"<p>               Bases: <code>BaseModel</code></p> <p>A mixin that adds 1-dimensional uncertainty fields (<code>variance</code> and <code>variance_type</code>).</p> <p>Recommended for sensors with scalar uncertain outputs, such as ultrasonic rangefinders, temperature sensors, or individual encoders.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.VarianceMixin--dynamic-schema-injection","title":"Dynamic Schema Injection","text":"<p>This mixin uses the <code>__init_subclass__</code> hook to perform a Schema Append operation:</p> <ol> <li>It inspects the child class's existing <code>__msco_pyarrow_struct__</code>.</li> <li>It appends a <code>variance</code> and <code>variance_type</code> field.</li> <li>It reconstructs the final <code>pa.struct</code> for the class.</li> </ol> Collision Safety <p>The mixin performs a collision check during class definition. If the child class already defines a <code>variance</code> or <code>variance_type</code> field in its PyArrow struct, a <code>ValueError</code> will be raised to prevent schema corruption.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.VarianceMixin--queryability","title":"Querying with the <code>.Q</code> Proxy","text":"<p>When constructing a <code>QueryOntologyCatalog</code>, the class fields are queryable across any model inheriting from this mixin, according to the following table:</p> Field Access Path Queryable Type Supported Operators <code>&lt;Model&gt;.Q.variance</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>&lt;Model&gt;.Q.variance_type</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Universal Compatibility <p>The <code>&lt;Model&gt;</code> placeholder represents any Mosaico ontology class (e.g., <code>IMU</code>, <code>GPS</code>, <code>Floating64</code>) or any custom user-defined <code>Serializable</code> class that inherits from <code>HeaderMixin</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, IMU, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter IMU data by a specific acquisition second\n    qresponse = client.query(\n        QueryOntologyCatalog(IMU.Q.variance.lt(0.76))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter IMU data by a specific acquisition second\n    # `FROM_CALIBRATED_PROCEDURE` is some enum value defined by the user\n    qresponse = client.query(\n        QueryOntologyCatalog(IMU.Q.variance_type.eq(FROM_CALIBRATED_PROCEDURE))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.VarianceMixin.variance","title":"variance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variance = None\n</code></pre> <p>Optional 64-bit float representing the variance of the data.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with the optional variance attribute.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.VarianceMixin.variance--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>VarianceMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>variance</code> component.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.VarianceMixin.variance_type","title":"variance_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variance_type = None\n</code></pre> <p>Optional 16-bit integer representing the variance parameterization.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with the optional covariance type attribute.</p>"},{"location":"SDK/API_reference/models/base/#mosaicolabs.models.VarianceMixin.variance_type--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>VarianceMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>variance_type</code> component.</p>"},{"location":"SDK/API_reference/models/data_types/","title":"Base Data Models","text":""},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types","title":"mosaicolabs.models.data.base_types","text":"<p>This module provides specialized wrapper classes for standard Python primitive types, including Integers, Floating-point numbers, Booleans, and Strings.</p> <p>In the Mosaico ecosystem, raw primitives cannot be transmitted directly because the platform requires structured metadata and explicit serialization schemas. These wrappers elevate basic data types to \"first-class citizens\" of the messaging system by inheriting from <code>Serializable</code> and <code>HeaderMixin</code>.</p> <p>Key Features: * Standardized Metadata: Every wrapped value includes a standard <code>Header</code>, enabling full traceability and temporal context (timestamps) for even the simplest data points. * Explicit Serialization: Each class defines a precise <code>pyarrow.StructType</code> schema, ensuring consistent bit-width (e.g., 8-bit vs 64-bit) across the entire data platform. * Registry Integration: Wrapped types are automatically registered in the Mosaico ontology, allowing them to be used in platform-side Queries.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer8","title":"Integer8","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code></p> <p>A wrapper for a signed 8-bit integer.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>int</code> <p>The underlying 8-bit integer value.</p> <code>header</code> <code>Optional[Header]</code> <p>An optional metadata header injected by <code>HeaderMixin</code>.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer8--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The fields of this class are queryable when constructing a <code>QueryOntologyCatalog</code> via the <code>.Q</code> proxy. Check the fields documentation for detailed description.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Integer8, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value\n    qresponse = client.query(QueryOntologyCatalog(Integer8.Q.data.gt(123)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Integer8.Q.data.gt(123), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer8.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data\n</code></pre> <p>The underlying integer value.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer8.data--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>Integer8.Q.data</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Integer8, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value\n    qresponse = client.query(QueryOntologyCatalog(Integer8.Q.data.gt(-10)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Integer8.Q.data.gt(123), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer8.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer8.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer8.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer8.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer16","title":"Integer16","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code></p> <p>A wrapper for a signed 16-bit integer.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>int</code> <p>The underlying 16-bit integer value.</p> <code>header</code> <code>Optional[Header]</code> <p>An optional metadata header injected by <code>HeaderMixin</code>.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer16--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The fields of this class are queryable when constructing a <code>QueryOntologyCatalog</code> via the <code>.Q</code> proxy. Check the fields documentation for detailed description.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Integer16, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value\n    qresponse = client.query(QueryOntologyCatalog(Integer16.Q.data.gt(123)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Integer16.Q.data.gt(123), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer16.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data\n</code></pre> <p>The underlying integer value.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer16.data--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>Integer16.Q.data</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Integer16, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value\n    qresponse = client.query(QueryOntologyCatalog(Integer16.Q.data.gt(-10)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Integer16.Q.data.gt(123), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer16.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer16.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer16.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer16.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer32","title":"Integer32","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code></p> <p>A wrapper for a signed 32-bit integer.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>int</code> <p>The underlying 32-bit integer value.</p> <code>header</code> <code>Optional[Header]</code> <p>An optional metadata header injected by <code>HeaderMixin</code>.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer32--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The fields of this class are queryable when constructing a <code>QueryOntologyCatalog</code> via the <code>.Q</code> proxy. Check the fields documentation for detailed description.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Integer32, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value\n    qresponse = client.query(QueryOntologyCatalog(Integer32.Q.data.gt(123)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Integer32.Q.data.gt(123), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer32.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data\n</code></pre> <p>The underlying integer value.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer32.data--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>Integer32.Q.data</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Integer32, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value\n    qresponse = client.query(QueryOntologyCatalog(Integer32.Q.data.gt(-10)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Integer32.Q.data.gt(123), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer32.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer32.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer32.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer32.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer64","title":"Integer64","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code></p> <p>A wrapper for a signed 64-bit integer.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>int</code> <p>The underlying 64-bit integer value.</p> <code>header</code> <code>Optional[Header]</code> <p>An optional metadata header injected by <code>HeaderMixin</code>.\u00f9</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer64--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The fields of this class are queryable when constructing a <code>QueryOntologyCatalog</code> via the <code>.Q</code> proxy. Check the fields documentation for detailed description.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Integer64, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value\n    qresponse = client.query(QueryOntologyCatalog(Integer64.Q.data.gt(123)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Integer64.Q.data.gt(123), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer64.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data\n</code></pre> <p>The underlying integer value.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer64.data--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>Integer64.Q.data</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Integer64, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value\n    qresponse = client.query(QueryOntologyCatalog(Integer64.Q.data.gt(123)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Integer64.Q.data.gt(123), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer64.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer64.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer64.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Integer64.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned8","title":"Unsigned8","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code></p> <p>A wrapper for an unsigned 8-bit integer.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>int</code> <p>The underlying unsigned 8-bit integer value.</p> <code>header</code> <code>Optional[Header]</code> <p>An optional metadata header injected by <code>HeaderMixin</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>data</code> is initialized with a negative value.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned8--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The fields of this class are queryable when constructing a <code>QueryOntologyCatalog</code> via the <code>.Q</code> proxy. Check the fields documentation for detailed description.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Unsigned8, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value\n    qresponse = client.query(QueryOntologyCatalog(Unsigned8.Q.data.gt(123)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Unsigned8.Q.data.gt(123), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned8.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data\n</code></pre> <p>The underlying unsigned integer value.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned8.data--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>Unsigned8.Q.data</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Unsigned8, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value\n    qresponse = client.query(QueryOntologyCatalog(Unsigned8.Q.data.leq(253)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Unsigned8.Q.data.gt(123), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned8.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned8.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned8.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(context)\n</code></pre> <p>Validates that the input data is non-negative.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data &lt; 0.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned8.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned8.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned16","title":"Unsigned16","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code></p> <p>A wrapper for an unsigned 16-bit integer.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>int</code> <p>The underlying unsigned 16-bit integer value.</p> <code>header</code> <code>Optional[Header]</code> <p>An optional metadata header injected by <code>HeaderMixin</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>data</code> is initialized with a negative value.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned16--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The fields of this class are queryable when constructing a <code>QueryOntologyCatalog</code> via the <code>.Q</code> proxy. Check the fields documentation for detailed description.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Unsigned16, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value\n    qresponse = client.query(QueryOntologyCatalog(Unsigned16.Q.data.gt(123)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Unsigned16.Q.data.gt(123), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned16.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data\n</code></pre> <p>The underlying unsigned integer value.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned16.data--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>Unsigned16.Q.data</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Unsigned16, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value\n    qresponse = client.query(QueryOntologyCatalog(Unsigned16.Q.data.eq(2)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Unsigned16.Q.data.gt(123), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned16.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned16.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned16.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(context)\n</code></pre> <p>Validates that the input data is non-negative.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data &lt; 0.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned16.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned16.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned32","title":"Unsigned32","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code></p> <p>A wrapper for an unsigned 32-bit integer.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>int</code> <p>The underlying unsigned 32-bit integer value.</p> <code>header</code> <code>Optional[Header]</code> <p>An optional metadata header injected by <code>HeaderMixin</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>data</code> is initialized with a negative value.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned32--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The fields of this class are queryable when constructing a <code>QueryOntologyCatalog</code> via the <code>.Q</code> proxy. Check the fields documentation for detailed description.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Unsigned32, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value\n    qresponse = client.query(QueryOntologyCatalog(Unsigned32.Q.data.gt(123)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Unsigned32.Q.data.gt(123), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned32.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data\n</code></pre> <p>The underlying unsigned integer value.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned32.data--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>Unsigned32.Q.data</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Unsigned32, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value\n    qresponse = client.query(QueryOntologyCatalog(Unsigned32.Q.data.gt(123)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Unsigned32.Q.data.gt(123), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned32.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned32.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned32.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(context)\n</code></pre> <p>Validates that the input data is non-negative.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data &lt; 0.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned32.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned32.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned64","title":"Unsigned64","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code></p> <p>A wrapper for an unsigned 64-bit integer.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>int</code> <p>The underlying unsigned 64-bit integer value.</p> <code>header</code> <code>Optional[Header]</code> <p>An optional metadata header injected by <code>HeaderMixin</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>data</code> is initialized with a negative value.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned64--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The fields of this class are queryable when constructing a <code>QueryOntologyCatalog</code> via the <code>.Q</code> proxy. Check the fields documentation for detailed description.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Unsigned64, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value\n    qresponse = client.query(QueryOntologyCatalog(Unsigned64.Q.data.gt(123)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Unsigned64.Q.data.gt(123), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned64.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data\n</code></pre> <p>The underlying unsigned integer value.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned64.data--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>Unsigned64.Q.data</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Unsigned64, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value\n    qresponse = client.query(QueryOntologyCatalog(Unsigned64.Q.data.gt(123)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Unsigned64.Q.data.gt(123), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned64.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned64.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned64.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(context)\n</code></pre> <p>Validates that the input data is non-negative.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data &lt; 0.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned64.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Unsigned64.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Floating16","title":"Floating16","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code></p> <p>A wrapper for a 16-bit single-precision floating-point number.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>float</code> <p>The underlying single-precision float.</p> <code>header</code> <code>Optional[Header]</code> <p>An optional metadata header injected by <code>HeaderMixin</code>.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Floating16--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The fields of this class are queryable when constructing a <code>QueryOntologyCatalog</code> via the <code>.Q</code> proxy. Check the fields documentation for detailed description.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Floating16, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value\n    qresponse = client.query(QueryOntologyCatalog(Floating16.Q.data.gt(123.45)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Floating16.Q.data.gt(123.45), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Floating16.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data\n</code></pre> <p>The underlying single-precision float.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Floating16.data--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>Floating16.Q.data</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Floating16, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value\n    qresponse = client.query(QueryOntologyCatalog(Floating16.Q.data.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Floating16.Q.data.gt(123.45), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Floating16.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Floating16.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Floating16.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Floating16.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Floating32","title":"Floating32","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code></p> <p>A wrapper for a 32-bit single-precision floating-point number.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>float</code> <p>The underlying single-precision float.</p> <code>header</code> <code>Optional[Header]</code> <p>An optional metadata header injected by <code>HeaderMixin</code>.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Floating32--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The fields of this class are queryable when constructing a <code>QueryOntologyCatalog</code> via the <code>.Q</code> proxy. Check the fields documentation for detailed description.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Floating32, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value\n    qresponse = client.query(QueryOntologyCatalog(Floating32.Q.data.gt(123.45)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Floating32.Q.data.gt(123.45), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Floating32.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data\n</code></pre> <p>The underlying single-precision float.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Floating32.data--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>Floating32.Q.data</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Floating32, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value\n    qresponse = client.query(QueryOntologyCatalog(Floating32.Q.data.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Floating32.Q.data.gt(123.45), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Floating32.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Floating32.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Floating32.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Floating32.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Floating64","title":"Floating64","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code></p> <p>A wrapper for a 64-bit single-precision floating-point number.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>float</code> <p>The underlying single-precision float.</p> <code>header</code> <code>Optional[Header]</code> <p>An optional metadata header injected by <code>HeaderMixin</code>.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Floating64--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The fields of this class are queryable when constructing a <code>QueryOntologyCatalog</code> via the <code>.Q</code> proxy. Check the fields documentation for detailed description.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Floating64, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value\n    qresponse = client.query(QueryOntologyCatalog(Floating64.Q.data.gt(123.45)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Floating64.Q.data.gt(123.45), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Floating64.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data\n</code></pre> <p>The underlying single-precision float.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Floating64.data--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>Floating64.Q.data</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Floating64, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value\n    qresponse = client.query(QueryOntologyCatalog(Floating64.Q.data.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Floating64.Q.data.gt(123.45), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Floating64.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Floating64.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Floating64.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Floating64.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Boolean","title":"Boolean","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code></p> <p>A wrapper for a standard boolean value.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>bool</code> <p>The underlying boolean value.</p> <code>header</code> <code>Optional[Header]</code> <p>An optional metadata header injected by <code>HeaderMixin</code>.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Boolean--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The fields of this class are queryable when constructing a <code>QueryOntologyCatalog</code> via the <code>.Q</code> proxy. Check the fields documentation for detailed description.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Boolean, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value\n    qresponse = client.query(QueryOntologyCatalog(Boolean.Q.data.eq(True)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Boolean.Q.data.eq(True), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Boolean.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data\n</code></pre> <p>The underlying boolean value.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Boolean.data--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>Boolean.Q.data</code> <code>Bool</code> <code>.eq()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Boolean, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value\n    qresponse = client.query(QueryOntologyCatalog(Boolean.Q.data.eq(True)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Boolean.Q.data.eq(True), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Boolean.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Boolean.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Boolean.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.Boolean.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.String","title":"String","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code></p> <p>A wrapper for a standard UTF-8 encoded string.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>str</code> <p>The underlying string data.</p> <code>header</code> <code>Optional[Header]</code> <p>An optional metadata header injected by <code>HeaderMixin</code>.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.String--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The fields of this class are queryable when constructing a <code>QueryOntologyCatalog</code> via the <code>.Q</code> proxy. Check the fields documentation for detailed description.</p> Example <pre><code>from mosaicolabs import MosaicoClient, String, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value\n    qresponse = client.query(QueryOntologyCatalog(String.Q.data.eq(\"hello\")))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(String.Q.data.eq(\"hello\"), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.String.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data\n</code></pre> <p>The underlying string data.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.String.data--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>String.Q.data</code> <code>String</code> <code>.eq()</code>, <code>.neq()</code>, <code>.match()</code>, <code>.in_()</code> Example <pre><code>from mosaicolabs import MosaicoClient, String, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for strings containing a specific log pattern\n    qresponse = client.query(QueryOntologyCatalog(String.Q.data.match(\"[ERR]\")))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(String.Q.data.eq(\"hello\"), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.String.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.String.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.String.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.String.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.LargeString","title":"LargeString","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code></p> <p>A wrapper for a Large UTF-8 encoded string.</p> <p>Use this class when string data is expected to exceed 2GB in size, necessitating the use of 64-bit offsets in the underlying PyArrow implementation.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>str</code> <p>The underlying large string data.</p> <code>header</code> <code>Optional[Header]</code> <p>An optional metadata header injected by <code>HeaderMixin</code>.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.LargeString--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The fields of this class are queryable when constructing a <code>QueryOntologyCatalog</code> via the <code>.Q</code> proxy. Check the fields documentation for detailed description.</p> Example <pre><code>from mosaicolabs import MosaicoClient, LargeString, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value\n    qresponse = client.query(QueryOntologyCatalog(LargeString.Q.data.eq(\"hello\")))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(LargeString.Q.data.eq(\"hello\"), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.LargeString.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data\n</code></pre> <p>The underlying large string data.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.LargeString.data--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>LargeString.Q.data</code> <code>String</code> <code>.eq()</code>, <code>.neq()</code>, <code>.match()</code>, <code>.in_()</code> Example <pre><code>from mosaicolabs import MosaicoClient, LargeString, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for large strings containing a specific log pattern\n    qresponse = client.query(QueryOntologyCatalog(LargeString.Q.data.match(\"CRITICAL_ERR_\")))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(LargeString.Q.data.eq(\"hello\"), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.LargeString.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.LargeString.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.LargeString.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.base_types.LargeString.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.ROI","title":"mosaicolabs.models.data.ROI","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code></p> <p>Represents a rectangular Region of Interest (ROI) within a 2D coordinate system.</p> <p>This class is primarily used in imaging and computer vision pipelines to define sub-windows for processing or rectification.</p> <p>Attributes:</p> Name Type Description <code>offset</code> <code>Vector2d</code> <p>A <code>Vector2d</code> representing the top-left (leftmost, topmost) pixel coordinates of the ROI.</p> <code>height</code> <code>int</code> <p>The vertical extent of the ROI in pixels.</p> <code>width</code> <code>int</code> <p>The horizontal extent of the ROI in pixels.</p> <code>do_rectify</code> <code>Optional[bool]</code> <p>Optional flag; <code>True</code> if a sub-window is captured and requires rectification.</p> <code>header</code> <code>Optional[Header]</code> <p>Standard metadata header providing temporal and spatial context.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.ROI--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This class fields are queryable when constructing a <code>QueryOntologyCatalog</code> via the <code>.Q</code> proxy. Check the fields documentation for detailed description.</p> Example <pre><code>from mosaicolabs import MosaicoClient, ROI, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter ROIs with offset X-component AND offset Y-component\n    qresponse = client.query(\n        QueryOntologyCatalog(ROI.Q.offset.x.gt(5.0))\n            .with_expression(ROI.Q.offset.y.lt(10))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(ROI.Q.offset.x.gt(5.0), include_timestamp_range=True)\n        .with_expression(ROI.Q.offset.y.lt(10))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.ROI.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.ROI.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.ROI.offset","title":"offset  <code>instance-attribute</code>","text":"<pre><code>offset\n</code></pre> <p>The top-left pixel coordinates of the ROI.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.ROI.offset--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Offset components are queryable through the <code>offset</code> field prefix.</p> Field Access Path Queryable Type Supported Operators <code>ROI.Q.offset.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>ROI.Q.offset.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, ROI, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for ROIs starting between the 10th and 350th pixel vertically\n    qresponse = client.query(\n        QueryOntologyCatalog(ROI.Q.offset.x.gt(100))\n            .with_expression(ROI.Q.offset.y.between(10, 350))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(ROI.Q.offset.x.gt(100), include_timestamp_range=True)\n        .with_expression(ROI.Q.offset.y.between(10, 350))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.ROI.height","title":"height  <code>instance-attribute</code>","text":"<pre><code>height\n</code></pre> <p>Height of the ROI in pixels.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.ROI.height--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"Field Access Path Queryable Type Supported Operators <code>ROI.Q.height</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, ROI, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for ROIs with height beyond 100 pixels\n    qresponse = client.query(\n        QueryOntologyCatalog(ROI.Q.height.gt(100))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(ROI.Q.height.gt(100), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.ROI.width","title":"width  <code>instance-attribute</code>","text":"<pre><code>width\n</code></pre> <p>Width of the ROI in pixels.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.ROI.width--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"Field Access Path Queryable Type Supported Operators <code>ROI.Q.width</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, ROI, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for ROIs with width below (or equal to) 250 pixels\n    qresponse = client.query(\n        QueryOntologyCatalog(ROI.Q.width.leq(250))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(ROI.Q.width.gt(100), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.ROI.do_rectify","title":"do_rectify  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>do_rectify = None\n</code></pre> <p>Flag indicating if the ROI requires rectification.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.ROI.do_rectify--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"Field Access Path Queryable Type Supported Operators <code>ROI.Q.do_rectify</code> <code>Boolean</code> <code>.eq()</code> Example <pre><code>from mosaicolabs import MosaicoClient, ROI, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for explicitly non-rectified ROIs (not None)\n    qresponse = client.query(\n        QueryOntologyCatalog(ROI.Q.do_rectify.eq(False))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.ROI.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/data_types/#mosaicolabs.models.data.ROI.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/geometry/","title":"Geometry Models","text":""},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry","title":"mosaicolabs.models.data.geometry","text":"<p>This module defines the fundamental building blocks for spatial representation, including vectors, points, quaternions, and rigid-body transforms.</p> <p>The module follows a Two-Tier Architecture to optimize both internal efficiency and public usability:</p> <ul> <li>Internal Structs (<code>_Struct</code>): Pure data containers that define the physical memory layout and the PyArrow schema. These are intended for embedding within larger composite objects (like a <code>Pose</code> or <code>Transform</code>) to avoid attaching redundant metadata headers or timestamps to every inner field.</li> <li>Public Classes: High-level models that combine spatial data with Mosaico's transport and serialization logic. These inherit from the internal structs and inject support for auto-registration (<code>Serializable</code>), temporal/spatial context (<code>HeaderMixin</code>), and uncertainty tracking (<code>CovarianceMixin</code>).</li> </ul>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector2d","title":"Vector2d","text":"<p>               Bases: <code>_Vector2dStruct</code>, <code>Serializable</code>, <code>HeaderMixin</code>, <code>CovarianceMixin</code></p> <p>A public 2D Vector for platform-wide transmission.</p> <p>This class combines the [x, y] coordinates with full Mosaico transport logic. It is used to represent quantities such as velocity, acceleration, or directional forces.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>Vector X component.</p> <code>y</code> <code>float</code> <p>Vector Y component.</p> <code>header</code> <code>Optional[Header]</code> <p>Optional metadata header providing temporal and spatial context.</p> <code>covariance</code> <code>Optional[List[float]]</code> <p>Optional flattened 2x2 covariance matrix representing the uncertainty of the vector measurement.</p> <code>covariance_type</code> <code>Optional[int]</code> <p>Enum integer representing the parameterization of the covariance matrix.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector2d--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This class fields are queryable when constructing a <code>QueryOntologyCatalog</code> via the <code>.Q</code> proxy. Check the fields documentation for detailed description.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Vector2d, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific component value.\n    qresponse = client.query(\n        QueryOntologyCatalog(Vector2d.Q.y.leq(123.4))\n        .with_expression(Vector2d.Q.header.stamp.sec.between([1770282868, 1770290127]))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Vector2d.Q.y.leq(123.4), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector2d.covariance","title":"covariance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>covariance = None\n</code></pre> <p>Optional list of 64-bit floats representing the flattened matrix.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector2d.covariance--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"Non-Queryable <p>The field is not queryable with the <code>.Q</code> Proxy.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector2d.covariance_type","title":"covariance_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>covariance_type = None\n</code></pre> <p>Optional 16-bit integer representing the covariance enum.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with the optional covariance type attribute.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector2d.covariance_type--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>CovarianceMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>covariance_type</code> component.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector2d.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector2d.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector2d.x","title":"x  <code>instance-attribute</code>","text":"<pre><code>x\n</code></pre> <p>The Vector X component</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector2d.x--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>&lt;Model&gt;.Q.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Universal Compatibility <p>The <code>&lt;Model&gt;</code> placeholder represents any Mosaico class derived by <code>_Vector2dStruct</code> (i.e. <code>Vector2d</code>, <code>Point2d</code>) or any custom user-defined <code>Serializable</code> class that inherits from <code>HeaderMixin</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Vector2d, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Vector2d.Q.x.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Vector2d.Q.x.leq(123.4), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Point2d.Q.x.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector2d.y","title":"y  <code>instance-attribute</code>","text":"<pre><code>y\n</code></pre> <p>The Vector Y component</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector2d.y--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>&lt;Model&gt;.Q.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Universal Compatibility <p>The <code>&lt;Model&gt;</code> placeholder represents any Mosaico class derived by <code>_Vector2dStruct</code> (i.e. <code>Vector2d</code>, <code>Point2d</code>) or any custom user-defined <code>Serializable</code> class that inherits from <code>HeaderMixin</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Vector2d, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Vector2d.Q.y.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Vector2d.Q.y.leq(123.4), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Point2d.Q.y.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector2d.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector2d.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector2d.from_list","title":"from_list  <code>classmethod</code>","text":"<pre><code>from_list(data)\n</code></pre> <p>Creates a struct instance from a raw list.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list[float]</code> <p>A list containing exactly 2 float values: [x, y].</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input list does not have a length of 2.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector3d","title":"Vector3d","text":"<p>               Bases: <code>_Vector3dStruct</code>, <code>Serializable</code>, <code>HeaderMixin</code>, <code>CovarianceMixin</code></p> <p>A public 3D Vector for platform-wide transmission.</p> <p>This class combines the [x, y, z] coordinates with full Mosaico transport logic. It is used to represent quantities such as velocity, acceleration, or directional forces.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>Vector X component.</p> <code>y</code> <code>float</code> <p>Vector Y component.</p> <code>z</code> <code>float</code> <p>Vector Z component.</p> <code>header</code> <code>Optional[Header]</code> <p>Optional metadata header providing temporal and spatial context.</p> <code>covariance</code> <code>Optional[List[float]]</code> <p>Optional flattened 3x3 covariance matrix representing the uncertainty of the vector measurement.</p> <code>covariance_type</code> <code>Optional[int]</code> <p>Enum integer representing the parameterization of the covariance matrix.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector3d--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This class fields are queryable when constructing a <code>QueryOntologyCatalog</code> via the <code>.Q</code> proxy. Check the fields documentation for detailed description.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Vector3d, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific component value.\n    qresponse = client.query(\n        QueryOntologyCatalog(Vector3d.Q.y.leq(123.4))\n        .with_expression(Vector3d.Q.header.stamp.sec.between([1770282868, 1770290127]))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Vector3d.Q.z.leq(123.4), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector3d.covariance","title":"covariance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>covariance = None\n</code></pre> <p>Optional list of 64-bit floats representing the flattened matrix.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector3d.covariance--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"Non-Queryable <p>The field is not queryable with the <code>.Q</code> Proxy.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector3d.covariance_type","title":"covariance_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>covariance_type = None\n</code></pre> <p>Optional 16-bit integer representing the covariance enum.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with the optional covariance type attribute.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector3d.covariance_type--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>CovarianceMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>covariance_type</code> component.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector3d.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector3d.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector3d.x","title":"x  <code>instance-attribute</code>","text":"<pre><code>x\n</code></pre> <p>The Vector X component</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector3d.x--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>&lt;Model&gt;.Q.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Universal Compatibility <p>The <code>&lt;Model&gt;</code> placeholder represents any Mosaico class derived by <code>_Vector3dStruct</code> (i.e. <code>Vector3d</code>, <code>Point3d</code>) or any custom user-defined <code>Serializable</code> class that inherits from <code>HeaderMixin</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Vector3d, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Vector3d.Q.x.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Vector3d.Q.x.leq(123.4), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Point3d.Q.x.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector3d.y","title":"y  <code>instance-attribute</code>","text":"<pre><code>y\n</code></pre> <p>The Vector Y component</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector3d.y--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>&lt;Model&gt;.Q.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Universal Compatibility <p>The <code>&lt;Model&gt;</code> placeholder represents any Mosaico class derived by <code>_Vector3dStruct</code> (i.e. <code>Vector3d</code>, <code>Point3d</code>) or any custom user-defined <code>Serializable</code> class that inherits from <code>HeaderMixin</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Vector3d, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Vector3d.Q.y.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Vector3d.Q.y.leq(123.4), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Point3d.Q.y.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector3d.z","title":"z  <code>instance-attribute</code>","text":"<pre><code>z\n</code></pre> <p>The Vector Z component</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector3d.z--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>&lt;Model&gt;.Q.z</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Universal Compatibility <p>The <code>&lt;Model&gt;</code> placeholder represents any Mosaico class derived by <code>_Vector3dStruct</code> (i.e. <code>Vector3d</code>, <code>Point3d</code>) or any custom user-defined <code>Serializable</code> class that inherits from <code>HeaderMixin</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Vector3d, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Vector3d.Q.z.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Vector3d.Q.z.leq(123.4), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Point3d.Q.z.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector3d.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector3d.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector3d.from_list","title":"from_list  <code>classmethod</code>","text":"<pre><code>from_list(data)\n</code></pre> <p>Creates a struct instance from a raw list.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list[float]</code> <p>A list containing exactly 3 float values: [x, y, z].</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input list does not have a length of 3.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector4d","title":"Vector4d","text":"<p>               Bases: <code>_Vector4dStruct</code>, <code>Serializable</code>, <code>HeaderMixin</code>, <code>CovarianceMixin</code></p> <p>A public 4D Vector for platform-wide transmission.</p> <p>This class combines the [x, y, z, w] coordinates with full Mosaico transport logic. It is used to represent quantities such as velocity, acceleration, or directional forces.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>Vector X component.</p> <code>y</code> <code>float</code> <p>Vector Y component.</p> <code>z</code> <code>float</code> <p>Vector Z component.</p> <code>w</code> <code>float</code> <p>Vector W component.</p> <code>header</code> <code>Optional[Header]</code> <p>Optional metadata header providing temporal and spatial context.</p> <code>covariance</code> <code>Optional[List[float]]</code> <p>Optional flattened 4x4 covariance matrix representing the uncertainty of the vector measurement.</p> <code>covariance_type</code> <code>Optional[int]</code> <p>Enum integer representing the parameterization of the covariance matrix.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector4d--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This class fields are queryable when constructing a <code>QueryOntologyCatalog</code> via the <code>.Q</code> proxy. Check the fields documentation for detailed description.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Vector4d, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific component value.\n    qresponse = client.query(\n        QueryOntologyCatalog(Vector4d.Q.y.leq(123.4))\n        .with_expression(Vector4d.Q.header.stamp.sec.between([1770282868, 1770290127]))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Vector4d.Q.y.leq(123.4), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector4d.covariance","title":"covariance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>covariance = None\n</code></pre> <p>Optional list of 64-bit floats representing the flattened matrix.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector4d.covariance--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"Non-Queryable <p>The field is not queryable with the <code>.Q</code> Proxy.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector4d.covariance_type","title":"covariance_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>covariance_type = None\n</code></pre> <p>Optional 16-bit integer representing the covariance enum.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with the optional covariance type attribute.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector4d.covariance_type--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>CovarianceMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>covariance_type</code> component.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector4d.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector4d.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector4d.x","title":"x  <code>instance-attribute</code>","text":"<pre><code>x\n</code></pre> <p>The Vector X component</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector4d.x--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>&lt;Model&gt;.Q.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Universal Compatibility <p>The <code>&lt;Model&gt;</code> placeholder represents any Mosaico class derived by <code>_Vector4dStruct</code> (i.e. <code>Vector4d</code>, <code>Quaternion</code>) or any custom user-defined <code>Serializable</code> class that inherits from <code>HeaderMixin</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Vector4d, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Vector4d.Q.x.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Vector4d.Q.x.leq(123.4), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Quaternion.Q.x.leq(0.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector4d.y","title":"y  <code>instance-attribute</code>","text":"<pre><code>y\n</code></pre> <p>The Vector Y component</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector4d.y--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>&lt;Model&gt;.Q.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Universal Compatibility <p>The <code>&lt;Model&gt;</code> placeholder represents any Mosaico class derived by <code>_Vector4dStruct</code> (i.e. <code>Vector4d</code>, <code>Quaternion</code>) or any custom user-defined <code>Serializable</code> class that inherits from <code>HeaderMixin</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Vector4d, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Vector4d.Q.y.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Vector4d.Q.y.leq(123.4), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Quaternion.Q.y.leq(0.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector4d.z","title":"z  <code>instance-attribute</code>","text":"<pre><code>z\n</code></pre> <p>The Vector Z component</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector4d.z--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>&lt;Model&gt;.Q.z</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Universal Compatibility <p>The <code>&lt;Model&gt;</code> placeholder represents any Mosaico class derived by <code>_Vector4dStruct</code> (i.e. <code>Vector4d</code>, <code>Quaternion</code>) or any custom user-defined <code>Serializable</code> class that inherits from <code>HeaderMixin</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Vector4d, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Vector4d.Q.z.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Vector4d.Q.z.leq(123.4), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Quaternion.Q.z.leq(0.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector4d.w","title":"w  <code>instance-attribute</code>","text":"<pre><code>w\n</code></pre> <p>The Vector W component</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector4d.w--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>&lt;Model&gt;.Q.w</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Universal Compatibility <p>The <code>&lt;Model&gt;</code> placeholder represents any Mosaico class derived by <code>_Vector4dStruct</code> (i.e. <code>Vector4d</code>, <code>Quaternion</code>) or any custom user-defined <code>Serializable</code> class that inherits from <code>HeaderMixin</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Vector4d, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Vector4d.Q.w.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Vector4d.Q.w.leq(123.4), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Quaternion.Q.w.leq(0.707)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector4d.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector4d.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Vector4d.from_list","title":"from_list  <code>classmethod</code>","text":"<pre><code>from_list(data)\n</code></pre> <p>Creates a struct instance from a raw list.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list[float]</code> <p>A list containing exactly 4 float values: [x, y, z, w].</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input list does not have a length of 4.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point2d","title":"Point2d","text":"<p>               Bases: <code>_Vector2dStruct</code>, <code>Serializable</code>, <code>HeaderMixin</code>, <code>CovarianceMixin</code></p> <p>Semantically represents a specific location (Point) in 2D space.</p> <p>Structurally identical to a 2D Vector, but distinguished within the Mosaico API to clarify intent in spatial operations. Use this class for 2D coordinate data that requires Mosaico transport logic.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>Point X coordinate.</p> <code>y</code> <code>float</code> <p>Point Y coordinate.</p> <code>header</code> <code>Optional[Header]</code> <p>Optional metadata header providing temporal and spatial context.</p> <code>covariance</code> <code>Optional[List[float]]</code> <p>Optional flattened 2x2 covariance matrix representing the uncertainty of the point measurement.</p> <code>covariance_type</code> <code>Optional[int]</code> <p>Enum integer representing the parameterization of the covariance matrix.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point2d--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This class fields are queryable when constructing a <code>QueryOntologyCatalog</code> via the <code>.Q</code> proxy. Check the fields documentation for detailed description.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Point2d, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific component value.\n    qresponse = client.query(\n        QueryOntologyCatalog(Point2d.Q.y.leq(123.4))\n        .with_expression(Point2d.Q.header.stamp.sec.between([1770282868, 1770290127]))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Point2d.Q.y.leq(123.4), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point2d.covariance","title":"covariance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>covariance = None\n</code></pre> <p>Optional list of 64-bit floats representing the flattened matrix.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point2d.covariance--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"Non-Queryable <p>The field is not queryable with the <code>.Q</code> Proxy.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point2d.covariance_type","title":"covariance_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>covariance_type = None\n</code></pre> <p>Optional 16-bit integer representing the covariance enum.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with the optional covariance type attribute.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point2d.covariance_type--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>CovarianceMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>covariance_type</code> component.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point2d.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point2d.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point2d.x","title":"x  <code>instance-attribute</code>","text":"<pre><code>x\n</code></pre> <p>The Vector X component</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point2d.x--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>&lt;Model&gt;.Q.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Universal Compatibility <p>The <code>&lt;Model&gt;</code> placeholder represents any Mosaico class derived by <code>_Vector2dStruct</code> (i.e. <code>Vector2d</code>, <code>Point2d</code>) or any custom user-defined <code>Serializable</code> class that inherits from <code>HeaderMixin</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Vector2d, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Vector2d.Q.x.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Vector2d.Q.x.leq(123.4), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Point2d.Q.x.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point2d.y","title":"y  <code>instance-attribute</code>","text":"<pre><code>y\n</code></pre> <p>The Vector Y component</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point2d.y--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>&lt;Model&gt;.Q.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Universal Compatibility <p>The <code>&lt;Model&gt;</code> placeholder represents any Mosaico class derived by <code>_Vector2dStruct</code> (i.e. <code>Vector2d</code>, <code>Point2d</code>) or any custom user-defined <code>Serializable</code> class that inherits from <code>HeaderMixin</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Vector2d, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Vector2d.Q.y.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Vector2d.Q.y.leq(123.4), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Point2d.Q.y.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point2d.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point2d.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point2d.from_list","title":"from_list  <code>classmethod</code>","text":"<pre><code>from_list(data)\n</code></pre> <p>Creates a struct instance from a raw list.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list[float]</code> <p>A list containing exactly 2 float values: [x, y].</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input list does not have a length of 2.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point3d","title":"Point3d","text":"<p>               Bases: <code>_Vector3dStruct</code>, <code>Serializable</code>, <code>HeaderMixin</code>, <code>CovarianceMixin</code></p> <p>Semantically represents a specific location (Point) in 3D space.</p> <p>The <code>Point3d</code> class is used to instantiate a 3D coordinate message for transmission over the platform. It is structurally identical to a 3D Vector but is used to denote state rather than direction.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>Point X coordinate.</p> <code>y</code> <code>float</code> <p>Point Y coordinate.</p> <code>z</code> <code>float</code> <p>Point Z coordinate.</p> <code>header</code> <code>Optional[Header]</code> <p>Optional metadata header providing temporal and spatial context.</p> <code>covariance</code> <code>Optional[List[float]]</code> <p>Optional flattened 3x3 covariance matrix representing the uncertainty of the point measurement.</p> <code>covariance_type</code> <code>Optional[int]</code> <p>Enum integer representing the parameterization of the covariance matrix.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point3d--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This class fields are queryable when constructing a <code>QueryOntologyCatalog</code> via the <code>.Q</code> proxy. Check the fields documentation for detailed description.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Point3d, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific component value.\n    qresponse = client.query(\n        QueryOntologyCatalog(Point3d.Q.y.leq(123.4))\n        .with_expression(Point3d.Q.header.stamp.sec.between([1770282868, 1770290127]))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Point3d.Q.z.leq(123.4), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point3d.covariance","title":"covariance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>covariance = None\n</code></pre> <p>Optional list of 64-bit floats representing the flattened matrix.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point3d.covariance--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"Non-Queryable <p>The field is not queryable with the <code>.Q</code> Proxy.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point3d.covariance_type","title":"covariance_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>covariance_type = None\n</code></pre> <p>Optional 16-bit integer representing the covariance enum.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with the optional covariance type attribute.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point3d.covariance_type--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>CovarianceMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>covariance_type</code> component.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point3d.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point3d.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point3d.x","title":"x  <code>instance-attribute</code>","text":"<pre><code>x\n</code></pre> <p>The Vector X component</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point3d.x--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>&lt;Model&gt;.Q.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Universal Compatibility <p>The <code>&lt;Model&gt;</code> placeholder represents any Mosaico class derived by <code>_Vector3dStruct</code> (i.e. <code>Vector3d</code>, <code>Point3d</code>) or any custom user-defined <code>Serializable</code> class that inherits from <code>HeaderMixin</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Vector3d, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Vector3d.Q.x.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Vector3d.Q.x.leq(123.4), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Point3d.Q.x.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point3d.y","title":"y  <code>instance-attribute</code>","text":"<pre><code>y\n</code></pre> <p>The Vector Y component</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point3d.y--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>&lt;Model&gt;.Q.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Universal Compatibility <p>The <code>&lt;Model&gt;</code> placeholder represents any Mosaico class derived by <code>_Vector3dStruct</code> (i.e. <code>Vector3d</code>, <code>Point3d</code>) or any custom user-defined <code>Serializable</code> class that inherits from <code>HeaderMixin</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Vector3d, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Vector3d.Q.y.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Vector3d.Q.y.leq(123.4), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Point3d.Q.y.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point3d.z","title":"z  <code>instance-attribute</code>","text":"<pre><code>z\n</code></pre> <p>The Vector Z component</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point3d.z--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>&lt;Model&gt;.Q.z</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Universal Compatibility <p>The <code>&lt;Model&gt;</code> placeholder represents any Mosaico class derived by <code>_Vector3dStruct</code> (i.e. <code>Vector3d</code>, <code>Point3d</code>) or any custom user-defined <code>Serializable</code> class that inherits from <code>HeaderMixin</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Vector3d, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Vector3d.Q.z.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Vector3d.Q.z.leq(123.4), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Point3d.Q.z.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point3d.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point3d.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Point3d.from_list","title":"from_list  <code>classmethod</code>","text":"<pre><code>from_list(data)\n</code></pre> <p>Creates a struct instance from a raw list.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list[float]</code> <p>A list containing exactly 3 float values: [x, y, z].</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input list does not have a length of 3.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Quaternion","title":"Quaternion","text":"<p>               Bases: <code>_Vector4dStruct</code>, <code>Serializable</code>, <code>HeaderMixin</code>, <code>CovarianceMixin</code></p> <p>Represents a rotation in 3D space using normalized quaternions.</p> <p>Structurally identical to a 4D vector [x, y, z, w], but semantically denotes an orientation. This representation avoids the gimbal lock issues associated with Euler angles.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>Vector X component.</p> <code>y</code> <code>float</code> <p>Vector Y component.</p> <code>z</code> <code>float</code> <p>Vector Z component.</p> <code>w</code> <code>float</code> <p>Vector W component.</p> <code>header</code> <code>Optional[Header]</code> <p>Optional metadata header providing temporal and spatial context.</p> <code>covariance</code> <code>Optional[List[float]]</code> <p>Optional flattened 4x4 covariance matrix representing the uncertainty of the quaternion measurement.</p> <code>covariance_type</code> <code>Optional[int]</code> <p>Enum integer representing the parameterization of the covariance matrix.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Quaternion--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This class fields are queryable when constructing a <code>QueryOntologyCatalog</code> via the <code>.Q</code> proxy. Check the fields documentation for detailed description.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Quaternion, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific component value.\n    qresponse = client.query(\n        QueryOntologyCatalog(Quaternion.Q.w.leq(0.707))\n        .with_expression(Quaternion.Q.header.stamp.sec.between([1770282868, 1770290127]))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Quaternion.Q.w.leq(0.707), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Quaternion.covariance","title":"covariance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>covariance = None\n</code></pre> <p>Optional list of 64-bit floats representing the flattened matrix.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Quaternion.covariance--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"Non-Queryable <p>The field is not queryable with the <code>.Q</code> Proxy.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Quaternion.covariance_type","title":"covariance_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>covariance_type = None\n</code></pre> <p>Optional 16-bit integer representing the covariance enum.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with the optional covariance type attribute.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Quaternion.covariance_type--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>CovarianceMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>covariance_type</code> component.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Quaternion.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Quaternion.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Quaternion.x","title":"x  <code>instance-attribute</code>","text":"<pre><code>x\n</code></pre> <p>The Vector X component</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Quaternion.x--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>&lt;Model&gt;.Q.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Universal Compatibility <p>The <code>&lt;Model&gt;</code> placeholder represents any Mosaico class derived by <code>_Vector4dStruct</code> (i.e. <code>Vector4d</code>, <code>Quaternion</code>) or any custom user-defined <code>Serializable</code> class that inherits from <code>HeaderMixin</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Vector4d, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Vector4d.Q.x.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Vector4d.Q.x.leq(123.4), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Quaternion.Q.x.leq(0.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Quaternion.y","title":"y  <code>instance-attribute</code>","text":"<pre><code>y\n</code></pre> <p>The Vector Y component</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Quaternion.y--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>&lt;Model&gt;.Q.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Universal Compatibility <p>The <code>&lt;Model&gt;</code> placeholder represents any Mosaico class derived by <code>_Vector4dStruct</code> (i.e. <code>Vector4d</code>, <code>Quaternion</code>) or any custom user-defined <code>Serializable</code> class that inherits from <code>HeaderMixin</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Vector4d, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Vector4d.Q.y.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Vector4d.Q.y.leq(123.4), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Quaternion.Q.y.leq(0.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Quaternion.z","title":"z  <code>instance-attribute</code>","text":"<pre><code>z\n</code></pre> <p>The Vector Z component</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Quaternion.z--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>&lt;Model&gt;.Q.z</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Universal Compatibility <p>The <code>&lt;Model&gt;</code> placeholder represents any Mosaico class derived by <code>_Vector4dStruct</code> (i.e. <code>Vector4d</code>, <code>Quaternion</code>) or any custom user-defined <code>Serializable</code> class that inherits from <code>HeaderMixin</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Vector4d, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Vector4d.Q.z.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Vector4d.Q.z.leq(123.4), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Quaternion.Q.z.leq(0.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Quaternion.w","title":"w  <code>instance-attribute</code>","text":"<pre><code>w\n</code></pre> <p>The Vector W component</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Quaternion.w--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This field is queryable when constructing a <code>QueryOntologyCatalog</code>  via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>&lt;Model&gt;.Q.w</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Universal Compatibility <p>The <code>&lt;Model&gt;</code> placeholder represents any Mosaico class derived by <code>_Vector4dStruct</code> (i.e. <code>Vector4d</code>, <code>Quaternion</code>) or any custom user-defined <code>Serializable</code> class that inherits from <code>HeaderMixin</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Vector4d, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Vector4d.Q.w.leq(123.4)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Vector4d.Q.w.leq(123.4), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n\n    # Filter for a specific component value.\n    qresponse = client.query(QueryOntologyCatalog(Quaternion.Q.w.leq(0.707)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Quaternion.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Quaternion.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Quaternion.from_list","title":"from_list  <code>classmethod</code>","text":"<pre><code>from_list(data)\n</code></pre> <p>Creates a struct instance from a raw list.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list[float]</code> <p>A list containing exactly 4 float values: [x, y, z, w].</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input list does not have a length of 4.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Transform","title":"Transform","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code>, <code>CovarianceMixin</code></p> <p>Represents a rigid-body transformation between two coordinate frames.</p> <p>A transform consists of a translation followed by a rotation. It is typically used to describe the kinematic relationship between components (e.g., \"Camera to Robot Base\").</p> <p>Attributes:</p> Name Type Description <code>translation</code> <code>Vector3d</code> <p>A <code>Vector3d</code> describing the linear shift.</p> <code>rotation</code> <code>Quaternion</code> <p>A <code>Quaternion</code> describing the rotational shift.</p> <code>target_frame_id</code> <code>Optional[str]</code> <p>The identifier of the destination coordinate frame.</p> <code>header</code> <code>Optional[Header]</code> <p>Optional metadata header providing temporal and spatial context.</p> <code>covariance</code> <code>Optional[List[float]]</code> <p>Optional flattened 7x7 composed covariance matrix representing the uncertainty of the Translation+Rotation.</p> <code>covariance_type</code> <code>Optional[int]</code> <p>Enum integer representing the parameterization of the covariance matrix.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Transform--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This class fields are queryable when constructing a <code>QueryOntologyCatalog</code> via the <code>.Q</code> proxy. Check the fields documentation for detailed description.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Transform, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific component value.\n    qresponse = client.query(\n        QueryOntologyCatalog(Transform.Q.translation.x.gt(5.0))\n        .with_expression(Transform.Q.rotation.w.lt(0.707))\n        .with_expression(Transform.Q.header.stamp.sec.between([1770282868, 1770290127]))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Transform.Q.translation.x.gt(5.0), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Transform.translation","title":"translation  <code>instance-attribute</code>","text":"<pre><code>translation\n</code></pre> <p>The 3D translation vector component.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Transform.translation--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Translation components are queryable through the <code>translation</code> field prefix.</p> Field Access Path Queryable Type Supported Operators <code>Transform.Q.translation.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>Transform.Q.translation.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>Transform.Q.translation.z</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Transform, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Find transforms where the linear X-translation exceeds 5 meters\n    qresponse = client.query(\n        QueryOntologyCatalog(Transform.Q.translation.x.gt(5.0))\n        .with_expression(Transform.Q.translation.z.lt(150.3))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Transform.Q.translation.x.gt(5.0), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Transform.rotation","title":"rotation  <code>instance-attribute</code>","text":"<pre><code>rotation\n</code></pre> <p>The rotation quaternion component (x, y, z, w).</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Transform.rotation--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Rotation components are queryable through the <code>rotation</code> field prefix.</p> Field Access Path Queryable Type Supported Operators <code>Transform.Q.rotation.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>Transform.Q.rotation.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>Transform.Q.rotation.z</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>Transform.Q.rotation.w</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Transform, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for specific orientation states\n    qresponse = client.query(\n        QueryOntologyCatalog(Transform.Q.rotation.w.geq(0.707))\n        .with_expression(Transform.Q.rotation.z.lt(0.4))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Transform.Q.rotation.x.gt(5.0), include_timestamp_range=True)\n        .with_expression(Transform.Q.rotation.z.lt(0.4))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Transform.target_frame_id","title":"target_frame_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>target_frame_id = None\n</code></pre> <p>Target coordinate frame identifier.</p> Field Access Path Queryable Type Supported Operators <code>Transform.Q.target_frame_id</code> <code>String</code> <code>.eq()</code>, <code>.neq()</code>, <code>.match()</code>, <code>.in_()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Transform, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for specific target frame id\n    qresponse = client.query(\n        QueryOntologyCatalog(Transform.Q.target_frame_id.eq(\"camera_link\"))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Transform.Q.target_frame_id.eq(\"camera_link\"), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Transform.covariance","title":"covariance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>covariance = None\n</code></pre> <p>Optional list of 64-bit floats representing the flattened matrix.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Transform.covariance--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"Non-Queryable <p>The field is not queryable with the <code>.Q</code> Proxy.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Transform.covariance_type","title":"covariance_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>covariance_type = None\n</code></pre> <p>Optional 16-bit integer representing the covariance enum.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with the optional covariance type attribute.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Transform.covariance_type--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>CovarianceMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>covariance_type</code> component.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Transform.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Transform.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Transform.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Transform.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Pose","title":"Pose","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code>, <code>CovarianceMixin</code></p> <p>Represents the position and orientation of an object in a global or local frame.</p> <p>While similar to a <code>Transform</code>, a <code>Pose</code> semantically denotes the state of an object (its current location and heading) rather than the mathematical shift between two frames.</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>Point3d</code> <p>A <code>Point3d</code> representing the object's coordinates.</p> <code>orientation</code> <code>Quaternion</code> <p>A <code>Quaternion</code> representing the object's heading.</p> <code>header</code> <code>Optional[Header]</code> <p>Optional metadata header providing temporal and spatial context.</p> <code>covariance</code> <code>Optional[List[float]]</code> <p>Optional flattened 7x7 composed covariance matrix representing the uncertainty of the Translation+Rotation.</p> <code>covariance_type</code> <code>Optional[int]</code> <p>Enum integer representing the parameterization of the covariance matrix.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Pose--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This class fields are queryable when constructing a <code>QueryOntologyCatalog</code> via the <code>.Q</code> proxy. Check the fields documentation for detailed description.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Pose, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter Poses with position X-component AND orientation W-component\n    qresponse = client.query(\n        QueryOntologyCatalog(Pose.Q.position.x.gt(5.0))\n        .with_expression(Pose.Q.orientation.w.lt(0.707))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Pose.Q.position.x.gt(5.0), include_timestamp_range=True)\n        .with_expression(Pose.Q.orientation.w.lt(0.707))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Pose.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position\n</code></pre> <p>The 3D position vector component.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Pose.position--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Position components are queryable through the <code>position</code> field prefix.</p> Field Access Path Queryable Type Supported Operators <code>Pose.Q.position.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>Pose.Q.position.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>Pose.Q.position.z</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Pose, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Find poses where the linear X-position exceeds 5 meters\n    qresponse = client.query(\n        QueryOntologyCatalog(Pose.Q.position.x.gt(123450.0))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Pose.Q.position.x.gt(5.0), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Pose.orientation","title":"orientation  <code>instance-attribute</code>","text":"<pre><code>orientation\n</code></pre> <p>The orientation quaternion component (x, y, z, w).</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Pose.orientation--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Rotation components are queryable through the <code>orientation</code> field prefix.</p> Field Access Path Queryable Type Supported Operators <code>Pose.Q.orientation.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>Pose.Q.orientation.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>Pose.Q.orientation.z</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>Pose.Q.orientation.w</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Pose, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for specific orientation states\n    qresponse = client.query(\n        QueryOntologyCatalog(Pose.Q.orientation.w.geq(0.707))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(include_timestamp_range=True)\n        .with_expression(Pose.Q.orientation.w.geq(0.707))\n        .with_expression(Pose.Q.orientation.x.lt(0.1))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Pose.covariance","title":"covariance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>covariance = None\n</code></pre> <p>Optional list of 64-bit floats representing the flattened matrix.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Pose.covariance--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"Non-Queryable <p>The field is not queryable with the <code>.Q</code> Proxy.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Pose.covariance_type","title":"covariance_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>covariance_type = None\n</code></pre> <p>Optional 16-bit integer representing the covariance enum.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with the optional covariance type attribute.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Pose.covariance_type--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>CovarianceMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>covariance_type</code> component.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Pose.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Pose.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Pose.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.geometry.Pose.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics","title":"mosaicolabs.models.data.kinematics","text":"<p>Kinematics Data Structures.</p> <p>This module defines structures for analyzing motion: 1.  Velocity (Twist): Linear and angular speed. 2.  Acceleration: Linear and angular acceleration. 3.  MotionState: A complete snapshot of an object's kinematics (Pose + Velocity + Acceleration).</p> <p>These can be assigned to Message.data field to send data to the platform.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Velocity","title":"Velocity","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code>, <code>CovarianceMixin</code></p> <p>Represents 6-Degree-of-Freedom Velocity, commonly referred to as a Twist.</p> <p>The <code>Velocity</code> class describes the instantaneous motion of an object, split into linear and angular components.</p> <p>Attributes:</p> Name Type Description <code>linear</code> <code>Optional[Vector3d]</code> <p>Optional <code>Vector3d</code> linear velocity vector.</p> <code>angular</code> <code>Optional[Vector3d]</code> <p>Optional <code>Vector3d</code> angular velocity vector.</p> <code>header</code> <code>Optional[Header]</code> <p>Optional metadata header providing temporal and spatial context.</p> <code>covariance</code> <code>Optional[List[float]]</code> <p>Optional flattened 3x3 covariance matrix representing the uncertainty of the point measurement.</p> <code>covariance_type</code> <code>Optional[int]</code> <p>Enum integer representing the parameterization of the covariance matrix.</p> Input Validation <p>A valid <code>Velocity</code> object must contain at least a <code>linear</code> or an <code>angular</code> component; providing neither will raise a <code>ValueError</code>.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Velocity--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This class fields are queryable when constructing a <code>QueryOntologyCatalog</code> via the <code>.Q</code> proxy. Check the fields documentation for detailed description.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Velocity, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter Velocities with linear X-component AND angular Z-component\n    qresponse = client.query(\n        QueryOntologyCatalog(Velocity.Q.linear.x.gt(5.0))\n            .with_expression(Velocity.Q.angular.z.lt(10))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Velocity.Q.linear.x.gt(5.0), include_timestamp_range=True)\n        .with_expression(Velocity.Q.angular.z.lt(10))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Velocity.linear","title":"linear  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>linear = None\n</code></pre> <p>3D linear velocity vector</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Velocity.linear--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Linear components are queryable through the <code>linear</code> field prefix.</p> Field Access Path Queryable Type Supported Operators <code>Velocity.Q.linear.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>Velocity.Q.linear.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>Velocity.Q.linear.z</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Velocity, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Find velocities where the linear X component exceeds 25 m/s\n    qresponse = client.query(\n        QueryOntologyCatalog(Velocity.Q.linear.x.gt(25.0))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Velocity.Q.linear.x.gt(5.0), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Velocity.angular","title":"angular  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>angular = None\n</code></pre> <p>3D angular velocity vector</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Velocity.angular--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Angular components are queryable through the <code>angular</code> field prefix.</p> Field Access Path Queryable Type Supported Operators <code>Velocity.Q.angular.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>Velocity.Q.angular.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>Velocity.Q.angular.z</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Velocity, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Find velocities where the angular X component exceeds 2 rad//s\n    qresponse = client.query(\n        QueryOntologyCatalog(Velocity.Q.angular.x.gt(2.0))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Velocity.Q.angular.x.gt(2.0), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Velocity.covariance","title":"covariance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>covariance = None\n</code></pre> <p>Optional list of 64-bit floats representing the flattened matrix.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Velocity.covariance--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"Non-Queryable <p>The field is not queryable with the <code>.Q</code> Proxy.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Velocity.covariance_type","title":"covariance_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>covariance_type = None\n</code></pre> <p>Optional 16-bit integer representing the covariance enum.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with the optional covariance type attribute.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Velocity.covariance_type--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>CovarianceMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>covariance_type</code> component.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Velocity.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Velocity.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Velocity.check_at_least_one_exists","title":"check_at_least_one_exists","text":"<pre><code>check_at_least_one_exists()\n</code></pre> <p>Ensures the velocity object is not empty.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both <code>linear</code> and <code>angular</code> are None.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Velocity.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Velocity.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Acceleration","title":"Acceleration","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code>, <code>CovarianceMixin</code></p> <p>Represents 6-Degree-of-Freedom Acceleration.</p> <p>This class provides a standardized way to transmit linear and angular acceleration data to the platform.</p> <p>Attributes:</p> Name Type Description <code>linear</code> <code>Optional[Vector3d]</code> <p>Optional 3D linear acceleration vector ($a_x, a_y, a_z$).</p> <code>angular</code> <code>Optional[Vector3d]</code> <p>Optional 3D angular acceleration vector ($\u0007lpha_x, \u0007lpha_y, \u0007lpha_z$).</p> <code>header</code> <code>Optional[Header]</code> <p>Optional metadata header providing acquisition context.</p> <code>covariance</code> <code>Optional[List[float]]</code> <p>Optional flattened 3x3 covariance matrix representing the uncertainty of the point measurement.</p> <code>covariance_type</code> <code>Optional[int]</code> <p>Enum integer representing the parameterization of the covariance matrix.</p> Input Validation <p>Similar to the <code>Velocity</code> class, an <code>Acceleration</code> instance requires at least one non-null component (<code>linear</code> or <code>angular</code>).</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Acceleration--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This class fields are queryable when constructing a <code>QueryOntologyCatalog</code> via the <code>.Q</code> proxy. Check the fields documentation for detailed description.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Acceleration, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter Accelerations with linear X-component AND angular Z-component\n    qresponse = client.query(\n        QueryOntologyCatalog(Acceleration.Q.linear.x.gt(5.0))\n            .with_expression(Acceleration.Q.angular.z.lt(10))\n    )\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Acceleration.Q.linear.x.gt(5.0), include_timestamp_range=True)\n        .with_expression(Acceleration.Q.angular.z.lt(10))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Acceleration.linear","title":"linear  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>linear = None\n</code></pre> <p>3D linear acceleration vector</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Acceleration.linear--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Linear components are queryable through the <code>linear</code> field prefix.</p> Field Access Path Queryable Type Supported Operators <code>Acceleration.Q.linear.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>Acceleration.Q.linear.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>Acceleration.Q.linear.z</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Acceleration, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Find accelerations where the linear X component exceeds 5 m/s^2\n    qresponse = client.query(\n        QueryOntologyCatalog(Acceleration.Q.linear.x.gt(5.0))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Acceleration.Q.linear.x.gt(5.0), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Acceleration.angular","title":"angular  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>angular = None\n</code></pre> <p>3D angular acceleration vector</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Acceleration.angular--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Angular components are queryable through the <code>angular</code> field prefix.</p> Field Access Path Queryable Type Supported Operators <code>Acceleration.Q.angular.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>Acceleration.Q.angular.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>Acceleration.Q.angular.z</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Acceleration, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Find accelerations where the angular X component exceeds 1 rad/s^2\n    qresponse = client.query(\n        QueryOntologyCatalog(Acceleration.Q.angular.x.gt(1.0))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Acceleration.Q.angular.x.gt(1.0), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Acceleration.covariance","title":"covariance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>covariance = None\n</code></pre> <p>Optional list of 64-bit floats representing the flattened matrix.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Acceleration.covariance--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"Non-Queryable <p>The field is not queryable with the <code>.Q</code> Proxy.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Acceleration.covariance_type","title":"covariance_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>covariance_type = None\n</code></pre> <p>Optional 16-bit integer representing the covariance enum.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with the optional covariance type attribute.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Acceleration.covariance_type--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>CovarianceMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>covariance_type</code> component.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Acceleration.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Acceleration.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Acceleration.check_at_least_one_exists","title":"check_at_least_one_exists","text":"<pre><code>check_at_least_one_exists()\n</code></pre> <p>Ensures the acceleration object is not empty.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both <code>linear</code> and <code>angular</code> are None.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Acceleration.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.Acceleration.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.MotionState","title":"MotionState","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code>, <code>CovarianceMixin</code></p> <p>Aggregated Kinematic State.</p> <p><code>MotionState</code> groups <code>Pose</code>, <code>Velocity</code>, and optional <code>Acceleration</code> into a single atomic update.</p> <p>This is the preferred structure for:</p> <ul> <li>Trajectory Tracking: Recording the high-fidelity path of a robot or vehicle.</li> <li>State Estimation: Logging the output of Kalman filters or SLAM algorithms.</li> <li>Ground Truth: Storing reference data from simulation environments.</li> </ul> <p>Attributes:</p> Name Type Description <code>pose</code> <code>Pose</code> <p>The 6D pose representing current position and orientation.</p> <code>velocity</code> <code>Velocity</code> <p>The 6D velocity (Twist).</p> <code>target_frame_id</code> <code>str</code> <p>A string identifier for the target coordinate frame.</p> <code>acceleration</code> <code>Optional[Acceleration]</code> <p>Optional 6D acceleration.</p> <code>header</code> <code>Optional[Header]</code> <p>Standard metadata header for temporal synchronization.</p> <code>covariance</code> <code>Optional[List[float]]</code> <p>Optional flattened NxN composed covariance matrix representing the uncertainty of the Pose+Velocity+[Acceleration] measurement.</p> <code>covariance_type</code> <code>Optional[int]</code> <p>Enum integer representing the parameterization of the covariance matrix.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.MotionState--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This class fields are queryable when constructing a <code>QueryOntologyCatalog</code> via the <code>.Q</code> proxy. Check the fields documentation for detailed description.</p> Example <pre><code>from mosaicolabs import MosaicoClient, MotionState, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter MotionStates with position X-component AND angular velocity Z-component\n    qresponse = client.query(\n        QueryOntologyCatalog(MotionState.Q.pose.position.x.gt(123456.9))\n            .with_expression(MotionState.Q.velocity.angular.z.lt(10))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(MotionState.Q.pose.position.x.gt(123456.9), include_timestamp_range=True)\n        .with_expression(MotionState.Q.velocity.angular.z.lt(10))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.MotionState.pose","title":"pose  <code>instance-attribute</code>","text":"<pre><code>pose\n</code></pre> <p>The 6D pose representing current position and orientation.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.MotionState.pose--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Pose components are queryable through the <code>pose</code> field prefix.</p> Field Access Path Queryable Type Supported Operators <code>MotionState.Q.pose.position.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>MotionState.Q.pose.position.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>MotionState.Q.pose.position.z</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>MotionState.Q.pose.orientation.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>MotionState.Q.pose.orientation.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>MotionState.Q.pose.orientation.z</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>MotionState.Q.pose.orientation.w</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, MotionState, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter snapshots where the object is beyond a specific X-coordinate\n    qresponse = client.query(\n        QueryOntologyCatalog(MotionState.Q.pose.position.x.gt(500.0))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(MotionState.Q.pose.position.x.gt(500.0), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.MotionState.velocity","title":"velocity  <code>instance-attribute</code>","text":"<pre><code>velocity\n</code></pre> <p>The 6D velocity (Twist) describing instantaneous motion.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.MotionState.velocity--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Velocity components are queryable through the <code>velocity</code> field prefix.</p> Field Access Path Queryable Type Supported Operators <code>MotionState.Q.velocity.linear.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>MotionState.Q.velocity.linear.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>MotionState.Q.velocity.linear.z</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>MotionState.Q.velocity.angular.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>MotionState.Q.velocity.angular.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>MotionState.Q.velocity.angular.z</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, MotionState, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Find states where linear velocity in X exceeds 2.5 m/s\n    qresponse = client.query(\n        QueryOntologyCatalog(MotionState.Q.velocity.linear.x.gt(2.5))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(MotionState.Q.velocity.linear.x.gt(5.0), include_timestamp_range=True)\n        .with_expression(MotionState.Q.velocity.angular.z.lt(10))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.MotionState.target_frame_id","title":"target_frame_id  <code>instance-attribute</code>","text":"<pre><code>target_frame_id\n</code></pre> <p>Identifier for the destination coordinate frame.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.MotionState.target_frame_id--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"Field Access Path Queryable Type Supported Operators <code>MotionState.Q.target_frame_id</code> <code>String</code> <code>.eq()</code>, <code>.neq()</code>, <code>.match()</code>, <code>.in_()</code> Example <pre><code>from mosaicolabs import MosaicoClient, MotionState, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Find states where target_frame_id is some link\n    qresponse = client.query(\n        QueryOntologyCatalog(MotionState.Q.target_frame_id.eq(\"moving_base\"))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.MotionState.acceleration","title":"acceleration  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>acceleration = None\n</code></pre> <p>Optional 6D acceleration components.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.MotionState.acceleration--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Acceleration components are queryable through the <code>acceleration</code> field prefix if present.</p> Field Access Path Queryable Type Supported Operators <code>MotionState.Q.acceleration.linear.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>MotionState.Q.acceleration.linear.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>MotionState.Q.acceleration.linear.z</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>MotionState.Q.acceleration.angular.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>MotionState.Q.acceleration.angular.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>MotionState.Q.acceleration.angular.z</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, MotionState, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Find states where centripetal acceleration exceeds 5 m/s^2\n    qresponse = client.query(\n        QueryOntologyCatalog(MotionState.Q.acceleration.linear.y.gt(5.0))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(MotionState.Q.acceleration.linear.y.gt(5.0), include_timestamp_range=True)\n        .with_expression(MotionState.Q.acceleration.angular.z.lt(10))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.MotionState.covariance","title":"covariance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>covariance = None\n</code></pre> <p>Optional list of 64-bit floats representing the flattened matrix.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.MotionState.covariance--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"Non-Queryable <p>The field is not queryable with the <code>.Q</code> Proxy.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.MotionState.covariance_type","title":"covariance_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>covariance_type = None\n</code></pre> <p>Optional 16-bit integer representing the covariance enum.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with the optional covariance type attribute.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.MotionState.covariance_type--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>CovarianceMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>covariance_type</code> component.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.MotionState.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.MotionState.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.MotionState.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.kinematics.MotionState.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.dynamics","title":"mosaicolabs.models.data.dynamics","text":"<p>This module defines specialized ontology structures for representing physical dynamics, specifically linear forces and rotational moments (torques).</p> <p>The primary structure, <code>ForceTorque</code>, implements a standard \"Wrench\" representation. These models are designed to be assigned to the <code>data</code> field of a <code>Message</code> for transmission to the platform.</p> <p>Key Features: * Wrench Representation: Combines 3D linear force and 3D rotational torque into a single, synchronized state. * Uncertainty Quantification: Inherits from <code>CovarianceMixin</code> to support $6    imes 6$ covariance matrices, allowing for the transmission of sensor noise characteristics or estimation confidence.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.dynamics.ForceTorque","title":"ForceTorque","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code>, <code>CovarianceMixin</code></p> <p>Represents a Wrench (Force and Torque) applied to a rigid body.</p> <p>The <code>ForceTorque</code> class is used to describe the total mechanical action (wrench) acting on a body at a specific reference point. By combining linear force and rotational torque, it provides a complete description of dynamics for simulation and telemetry.</p> <p>Attributes:</p> Name Type Description <code>force</code> <code>Vector3d</code> <p>A <code>Vector3d</code> representing the linear force vector in Newtons ($N$).</p> <code>torque</code> <code>Vector3d</code> <p>A <code>Vector3d</code> representing the rotational moment vector in Newton-meters (Nm).</p> <code>header</code> <code>Optional[Header]</code> <p>Optional metadata header providing temporal and spatial context.</p> <code>covariance</code> <code>Optional[List[float]]</code> <p>Optional flattened 6x6 composed covariance matrix representing the uncertainty of the force-torque measurement.</p> <code>covariance_type</code> <code>Optional[int]</code> <p>Enum integer representing the parameterization of the covariance matrix.</p> Unit Standards <p>To ensure platform-wide consistency, all force components should be specified in Newtons and torque in Newton-meters.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.dynamics.ForceTorque--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This class fields are queryable when constructing a <code>QueryOntologyCatalog</code> via the <code>.Q</code> proxy. Check the fields documentation for detailed description.</p> Example <pre><code>from mosaicolabs import MosaicoClient, ForceTorque, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter ForceTorques with force X-component AND torque Z-component\n    qresponse = client.query(\n        QueryOntologyCatalog(ForceTorque.Q.force.x.gt(5.0))\n            .with_expression(ForceTorque.Q.torque.z.lt(10))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(ForceTorque.Q.force.x.gt(5.0), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.dynamics.ForceTorque.force","title":"force  <code>instance-attribute</code>","text":"<pre><code>force\n</code></pre> <p>3D linear force vector</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.dynamics.ForceTorque.force--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Force components are queryable through the <code>force</code> field prefix.</p> Field Access Path Queryable Type Supported Operators <code>ForceTorque.Q.force.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>ForceTorque.Q.force.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>ForceTorque.Q.force.z</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, ForceTorque, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Find where the linear X-force exceeds 50N \n    qresponse = client.query(QueryOntologyCatalog(ForceTorque.Q.force.x.gt(50.0)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(ForceTorque.Q.force.x.gt(5.0), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.dynamics.ForceTorque.torque","title":"torque  <code>instance-attribute</code>","text":"<pre><code>torque\n</code></pre> <p>3D torque vector</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.dynamics.ForceTorque.torque--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Torque components are queryable through the <code>torque</code> field prefix.</p> Field Access Path Queryable Type Supported Operators <code>ForceTorque.Q.torque.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>ForceTorque.Q.torque.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>ForceTorque.Q.torque.z</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, ForceTorque, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Find where the linear Y-torque is small\n    qresponse = client.query(QueryOntologyCatalog(ForceTorque.Q.torque.y.lt(0.02)))\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific data value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(ForceTorque.Q.torque.y.gt(5.0), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.dynamics.ForceTorque.covariance","title":"covariance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>covariance = None\n</code></pre> <p>Optional list of 64-bit floats representing the flattened matrix.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.dynamics.ForceTorque.covariance--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"Non-Queryable <p>The field is not queryable with the <code>.Q</code> Proxy.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.dynamics.ForceTorque.covariance_type","title":"covariance_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>covariance_type = None\n</code></pre> <p>Optional 16-bit integer representing the covariance enum.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with the optional covariance type attribute.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.dynamics.ForceTorque.covariance_type--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>CovarianceMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>covariance_type</code> component.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.dynamics.ForceTorque.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.dynamics.ForceTorque.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.dynamics.ForceTorque.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/geometry/#mosaicolabs.models.data.dynamics.ForceTorque.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/platform/","title":"Platform Models","text":""},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Topic","title":"mosaicolabs.models.platform.Topic","text":"<p>               Bases: <code>PlatformBase</code></p> <p>Represents a read-only view of a server-side Topic platform resource.</p> <p>The <code>Topic</code> class provides access to topic-specific system metadata, such as the ontology tag (e.g., 'imu', 'camera') and the serialization format. It serves as a metadata-rich view of an individual data stream within the platform catalog.</p> Data Retrieval <p>This class provides a metadata-only view of the topic. To retrieve the actual time-series messages contained within the topic, you must use the <code>TopicHandler.get_data_streamer()</code> method from a <code>TopicHandler</code> instance.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Topic--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The <code>user_metadata</code> field of this class is queryable when constructing a <code>QueryTopic</code> via the <code>.Q</code> proxy. Check the documentation of the <code>PlatformBase</code> to construct a a valid expression for the builders involving the <code>user_metadata</code> component.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Topic, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.Q.user_metadata[\"update_rate_hz\"].eq(100), # Access the keys using the [] operator\n            Topic.Q.user_metadata[\"interface.type\"].eq(\"canbus\"), # Navigate the nested dicts using the dot notation\n        )\n    )\n\n    # # The same query using `with_expression`\n    # qresponse = client.query(\n    #     QueryTopic()\n    #     .with_expression(Topic.Q.user_metadata[\"update_rate_hz\"].eq(100))\n    #     .with_expression(\n    #         Topic.Q.user_metadata[\"interface.type\"].match(\"canbus\")\n    #     )\n    # )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Topic.user_metadata","title":"user_metadata  <code>instance-attribute</code>","text":"<pre><code>user_metadata\n</code></pre> <p>Custom user-defined key-value pairs associated with the entity.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Topic.user_metadata--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The <code>user_metadata</code> field is queryable when constructing a <code>QueryTopic</code> or <code>QuerySequence</code> using the <code>.Q</code> proxy</p> Field Access Path Queryable Type Supported Operators <code>Sequence.Q.user_metadata[\"key\"]</code> <code>String</code>, <code>Numeric</code>, <code>Boolean</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code>, <code>.match()</code> <code>Sequence.Q.user_metadata[\"key.subkey.subsubkey...\"]</code> <code>String</code>, <code>Numeric</code>, <code>Boolean</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code>, <code>.match()</code> <code>Topic.Q.user_metadata[\"key\"]</code> <code>String</code>, <code>Numeric</code>, <code>Boolean</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code>, <code>.match()</code> <code>Topic.Q.user_metadata[\"key.subkey.subsubkey...\"]</code> <code>String</code>, <code>Numeric</code>, <code>Boolean</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code>, <code>.match()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Topic, Sequence, QueryTopic, QuerySequence\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific keys in sequence AND topic metadata.\n    qresponse = client.query(\n        QueryTopic(Topic.Q.user_metadata[\"update_rate_hz\"].geq(100)),\n        QuerySequence(Sequence.Q.user_metadata[\"project.version\"].match(\"v1.0\"))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Topic.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre> <p>The unique identifier or resource name of the entity.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Topic.name--querying-with-query-builders","title":"Querying with Query Builders","text":"<p>The <code>name</code> property is queryable when constructing a <code>QueryTopic</code> or a <code>QuerySequence</code> via the convenience methods:</p> <ul> <li><code>QueryTopic.with_name()</code></li> <li><code>QueryTopic.with_name_match()</code></li> <li><code>QuerySequence.with_name()</code></li> <li><code>QuerySequence.with_name_match()</code></li> </ul> Example <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic().with_name(\"/front/imu\"),\n        QuerySequence().with_name_match(\"test_winter_2025_01_\"),\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Topic.created_datetime","title":"created_datetime  <code>property</code>","text":"<pre><code>created_datetime\n</code></pre> <p>The UTC timestamp indicating when the entity was created on the server.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Topic.created_datetime--querying-with-query-builders","title":"Querying with Query Builders","text":"<p>The <code>created_datetime</code> property is queryable when constructing a <code>QueryTopic</code> or a <code>QuerySequence</code> via the convenience methods:</p> <ul> <li><code>QueryTopic.with_created_timestamp()</code></li> <li><code>QuerySequence.with_created_timestamp()</code></li> </ul> Example <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic, Time\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific topic creation time\n    qresponse = client.query(\n        QueryTopic().with_created_timestamp(time_start=Time.from_float(1765432100)),\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific sequence creation time\n    qresponse = client.query(\n        QuerySequence().with_created_timestamp(time_start=Time.from_float(1765432100)),\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Topic.is_locked","title":"is_locked  <code>property</code>","text":"<pre><code>is_locked\n</code></pre> <p>Indicates if the resource is currently locked.</p> <p>A locked state typically occurs during active writing or maintenance operations, preventing deletion or structural modifications.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Topic.is_locked--querying-with-query-builders","title":"Querying with Query Builders","text":"<p>The <code>is_locked</code> property is not queryable.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Topic.total_size_bytes","title":"total_size_bytes  <code>property</code>","text":"<pre><code>total_size_bytes\n</code></pre> <p>The total physical storage footprint of the entity on the server in bytes.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Topic.total_size_bytes--querying-with-query-builders","title":"Querying with Query Builders","text":"<p>The <code>total_size_bytes</code> property is not queryable.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Topic.ontology_tag","title":"ontology_tag  <code>property</code>","text":"<pre><code>ontology_tag\n</code></pre> <p>The ontology type identifier (e.g., 'imu', 'gnss').</p> <p>This corresponds to the <code>__ontology_tag__</code> defined in the <code>Serializable</code> class registry.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Topic.ontology_tag--querying-with-query-builders","title":"Querying with Query Builders","text":"<p>The <code>ontology_tag</code> property is queryable when constructing a <code>QueryTopic</code> via the convenience method <code>QueryTopic.with_ontology_tag()</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic().with_ontology_tag(IMU.ontology_tag()),\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Topic.sequence_name","title":"sequence_name  <code>property</code>","text":"<pre><code>sequence_name\n</code></pre> <p>The name of the parent sequence containing this topic.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Topic.sequence_name--querying-with-query-builders","title":"Querying with Query Builders","text":"<p>The <code>sequence_name</code> property is not queryable directly. Use <code>QuerySequence</code> to query for sequences.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Topic, QuerySequence\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QuerySequence().with_name(\"test_winter_20260129_103000\")\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Topic.chunks_number","title":"chunks_number  <code>property</code>","text":"<pre><code>chunks_number\n</code></pre> <p>The number of physical data chunks stored for this topic.</p> <p>May be <code>None</code> if the server did not provide detailed storage statistics.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Topic.chunks_number--querying-with-query-builders","title":"Querying with Query Builders","text":"<p>The <code>chunks_number</code> property is not queryable.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Topic.serialization_format","title":"serialization_format  <code>property</code>","text":"<pre><code>serialization_format\n</code></pre> <p>The format used to serialize the topic data (e.g., 'arrow', 'image').</p> <p>This corresponds to the <code>SerializationFormat</code> enum.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Topic.serialization_format--querying-with-query-builders","title":"Querying with Query Builders","text":"<p>The <code>serialization_format</code> property is not queryable.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Sequence","title":"mosaicolabs.models.platform.Sequence","text":"<p>               Bases: <code>PlatformBase</code></p> <p>Represents a read-only view of a server-side Sequence platform resource.</p> <p>The <code>Sequence</code> class is designed to hold system-level metadata and enable fluid querying of user-defined properties. It serves as the primary metadata container for a logical grouping of related topics.</p> Data Retrieval <p>This class provides a metadata-only view of the sequence. To retrieve the actual time-series data contained within the sequence, you must use the <code>SequenceHandler.get_data_streamer()</code> method from a <code>SequenceHandler</code> instance.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Sequence--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The <code>user_metadata</code> field of this class is queryable when constructing a <code>QuerySequence</code> via the <code>.Q</code> proxy. Check the documentation of the <code>PlatformBase</code> to construct a a valid expression for the builders involving the <code>user_metadata</code> component.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Sequence, QuerySequence\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QuerySequence(\n            Sequence.Q.user_metadata[\"project\"].eq(\"Apollo\"), # Access the keys using the [] operator\n            Sequence.Q.user_metadata[\"vehicle.software_stack.planning\"].match(\"plan-4.\"), # Navigate the nested dicts using the dot notation\n        )\n    )\n\n    # # The same query using `with_expression`\n    # qresponse = client.query(\n    #     QuerySequence()\n    #     .with_expression(Sequence.Q.user_metadata[\"project\"].eq(\"Apollo\"))\n    #     .with_expression(\n    #         Sequence.Q.user_metadata[\"vehicle.software_stack.planning\"].match(\"plan-4.\")\n    #     )\n    # )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Sequence.user_metadata","title":"user_metadata  <code>instance-attribute</code>","text":"<pre><code>user_metadata\n</code></pre> <p>Custom user-defined key-value pairs associated with the entity.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Sequence.user_metadata--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The <code>user_metadata</code> field is queryable when constructing a <code>QueryTopic</code> or <code>QuerySequence</code> using the <code>.Q</code> proxy</p> Field Access Path Queryable Type Supported Operators <code>Sequence.Q.user_metadata[\"key\"]</code> <code>String</code>, <code>Numeric</code>, <code>Boolean</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code>, <code>.match()</code> <code>Sequence.Q.user_metadata[\"key.subkey.subsubkey...\"]</code> <code>String</code>, <code>Numeric</code>, <code>Boolean</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code>, <code>.match()</code> <code>Topic.Q.user_metadata[\"key\"]</code> <code>String</code>, <code>Numeric</code>, <code>Boolean</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code>, <code>.match()</code> <code>Topic.Q.user_metadata[\"key.subkey.subsubkey...\"]</code> <code>String</code>, <code>Numeric</code>, <code>Boolean</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code>, <code>.match()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Topic, Sequence, QueryTopic, QuerySequence\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific keys in sequence AND topic metadata.\n    qresponse = client.query(\n        QueryTopic(Topic.Q.user_metadata[\"update_rate_hz\"].geq(100)),\n        QuerySequence(Sequence.Q.user_metadata[\"project.version\"].match(\"v1.0\"))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Sequence.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre> <p>The unique identifier or resource name of the entity.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Sequence.name--querying-with-query-builders","title":"Querying with Query Builders","text":"<p>The <code>name</code> property is queryable when constructing a <code>QueryTopic</code> or a <code>QuerySequence</code> via the convenience methods:</p> <ul> <li><code>QueryTopic.with_name()</code></li> <li><code>QueryTopic.with_name_match()</code></li> <li><code>QuerySequence.with_name()</code></li> <li><code>QuerySequence.with_name_match()</code></li> </ul> Example <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic().with_name(\"/front/imu\"),\n        QuerySequence().with_name_match(\"test_winter_2025_01_\"),\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Sequence.created_datetime","title":"created_datetime  <code>property</code>","text":"<pre><code>created_datetime\n</code></pre> <p>The UTC timestamp indicating when the entity was created on the server.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Sequence.created_datetime--querying-with-query-builders","title":"Querying with Query Builders","text":"<p>The <code>created_datetime</code> property is queryable when constructing a <code>QueryTopic</code> or a <code>QuerySequence</code> via the convenience methods:</p> <ul> <li><code>QueryTopic.with_created_timestamp()</code></li> <li><code>QuerySequence.with_created_timestamp()</code></li> </ul> Example <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic, Time\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific topic creation time\n    qresponse = client.query(\n        QueryTopic().with_created_timestamp(time_start=Time.from_float(1765432100)),\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific sequence creation time\n    qresponse = client.query(\n        QuerySequence().with_created_timestamp(time_start=Time.from_float(1765432100)),\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Sequence.is_locked","title":"is_locked  <code>property</code>","text":"<pre><code>is_locked\n</code></pre> <p>Indicates if the resource is currently locked.</p> <p>A locked state typically occurs during active writing or maintenance operations, preventing deletion or structural modifications.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Sequence.is_locked--querying-with-query-builders","title":"Querying with Query Builders","text":"<p>The <code>is_locked</code> property is not queryable.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Sequence.total_size_bytes","title":"total_size_bytes  <code>property</code>","text":"<pre><code>total_size_bytes\n</code></pre> <p>The total physical storage footprint of the entity on the server in bytes.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Sequence.total_size_bytes--querying-with-query-builders","title":"Querying with Query Builders","text":"<p>The <code>total_size_bytes</code> property is not queryable.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Sequence.topics","title":"topics  <code>property</code>","text":"<pre><code>topics\n</code></pre> <p>Returns the list of names for all topics contained within this sequence.</p> Accessing Topic Data <p>This property returns string identifiers. To interact with topic data or metadata, use the <code>MosaicoClient.topic_handler()</code> factory.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.Sequence.topics--querying-with-query-builders","title":"Querying with Query Builders","text":"<p>The <code>topics</code> property is not queryable directly. Use <code>QueryTopic</code> to query for topics.</p> Example <pre><code>from mosaicolabs import MosaicoClient, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic().with_name(\"/sensors/camera/front/image_raw\")\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.platform_base.PlatformBase","title":"mosaicolabs.models.platform.platform_base.PlatformBase","text":"<p>               Bases: <code>BaseModel</code>, <code>_QueryProxyMixin</code></p> <p>Base class for Mosaico Sequence and Topic entities.</p> <p>The <code>PlatformBase</code> serves as a read-only view of a server-side resource. It is designed to hold system-level metadata and enable fluid querying of user-defined properties.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.platform_base.PlatformBase--core-functionality","title":"Core Functionality","text":"<ol> <li>System Metadata: Consolidates attributes like storage size and locking     status that are common across the catalog.</li> <li>Query Interface: Inherits from internal <code>_QueryableModel</code> to support expressive     syntax for filtering resources (e.g., <code>Sequence.Q.user_metadata[\"env\"] == \"prod\"</code>).</li> </ol> Read-Only Entities <p>Instances of this class are factory-generated from server responses. Users should not instantiate this class directly.</p> <p>Attributes:</p> Name Type Description <code>user_metadata</code> <code>Dict[str, Any]</code> <p>A dictionary of custom key-value pairs assigned by the user.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.platform_base.PlatformBase--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The <code>user_metadata</code> field is queryable when constructing a <code>QueryTopic</code> or <code>QuerySequence</code> via the <code>.Q</code> proxy.</p> Field Access Path Queryable Type Supported Operators <code>&lt;PlatformModel&gt;.Q.user_metadata[\"key\"]</code> <code>String</code>, <code>Numeric</code>, <code>Boolean</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code>, <code>.match()</code> Universal Compatibility <p>The <code>&lt;PlatformModel&gt;</code> placeholder represents any Mosaico class derived by <code>PlatformBase</code> (i.e. <code>Topic</code>, <code>Sequence</code>)</p> Example <pre><code>from mosaicolabs import MosaicoClient, Topic, Sequence, QueryTopic, QuerySequence\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific metadata key value.\n    qresponse = client.query(\n        QueryTopic(Topic.Q.user_metadata[\"update_rate_hz\"].geq(100))\n    )\n    # Filter for a specific nested metadata key value.\n    qresponse = client.query(\n        QuerySequence(Sequence.Q.user_metadata[\"project.version\"].match(\"v1.0\"))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.platform_base.PlatformBase.user_metadata","title":"user_metadata  <code>instance-attribute</code>","text":"<pre><code>user_metadata\n</code></pre> <p>Custom user-defined key-value pairs associated with the entity.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.platform_base.PlatformBase.user_metadata--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The <code>user_metadata</code> field is queryable when constructing a <code>QueryTopic</code> or <code>QuerySequence</code> using the <code>.Q</code> proxy</p> Field Access Path Queryable Type Supported Operators <code>Sequence.Q.user_metadata[\"key\"]</code> <code>String</code>, <code>Numeric</code>, <code>Boolean</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code>, <code>.match()</code> <code>Sequence.Q.user_metadata[\"key.subkey.subsubkey...\"]</code> <code>String</code>, <code>Numeric</code>, <code>Boolean</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code>, <code>.match()</code> <code>Topic.Q.user_metadata[\"key\"]</code> <code>String</code>, <code>Numeric</code>, <code>Boolean</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code>, <code>.match()</code> <code>Topic.Q.user_metadata[\"key.subkey.subsubkey...\"]</code> <code>String</code>, <code>Numeric</code>, <code>Boolean</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code>, <code>.match()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Topic, Sequence, QueryTopic, QuerySequence\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific keys in sequence AND topic metadata.\n    qresponse = client.query(\n        QueryTopic(Topic.Q.user_metadata[\"update_rate_hz\"].geq(100)),\n        QuerySequence(Sequence.Q.user_metadata[\"project.version\"].match(\"v1.0\"))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.platform_base.PlatformBase.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre> <p>The unique identifier or resource name of the entity.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.platform_base.PlatformBase.name--querying-with-query-builders","title":"Querying with Query Builders","text":"<p>The <code>name</code> property is queryable when constructing a <code>QueryTopic</code> or a <code>QuerySequence</code> via the convenience methods:</p> <ul> <li><code>QueryTopic.with_name()</code></li> <li><code>QueryTopic.with_name_match()</code></li> <li><code>QuerySequence.with_name()</code></li> <li><code>QuerySequence.with_name_match()</code></li> </ul> Example <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic().with_name(\"/front/imu\"),\n        QuerySequence().with_name_match(\"test_winter_2025_01_\"),\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.platform_base.PlatformBase.created_datetime","title":"created_datetime  <code>property</code>","text":"<pre><code>created_datetime\n</code></pre> <p>The UTC timestamp indicating when the entity was created on the server.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.platform_base.PlatformBase.created_datetime--querying-with-query-builders","title":"Querying with Query Builders","text":"<p>The <code>created_datetime</code> property is queryable when constructing a <code>QueryTopic</code> or a <code>QuerySequence</code> via the convenience methods:</p> <ul> <li><code>QueryTopic.with_created_timestamp()</code></li> <li><code>QuerySequence.with_created_timestamp()</code></li> </ul> Example <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic, Time\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific topic creation time\n    qresponse = client.query(\n        QueryTopic().with_created_timestamp(time_start=Time.from_float(1765432100)),\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific sequence creation time\n    qresponse = client.query(\n        QuerySequence().with_created_timestamp(time_start=Time.from_float(1765432100)),\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.platform_base.PlatformBase.is_locked","title":"is_locked  <code>property</code>","text":"<pre><code>is_locked\n</code></pre> <p>Indicates if the resource is currently locked.</p> <p>A locked state typically occurs during active writing or maintenance operations, preventing deletion or structural modifications.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.platform_base.PlatformBase.is_locked--querying-with-query-builders","title":"Querying with Query Builders","text":"<p>The <code>is_locked</code> property is not queryable.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.platform_base.PlatformBase.total_size_bytes","title":"total_size_bytes  <code>property</code>","text":"<pre><code>total_size_bytes\n</code></pre> <p>The total physical storage footprint of the entity on the server in bytes.</p>"},{"location":"SDK/API_reference/models/platform/#mosaicolabs.models.platform.platform_base.PlatformBase.total_size_bytes--querying-with-query-builders","title":"Querying with Query Builders","text":"<p>The <code>total_size_bytes</code> property is not queryable.</p>"},{"location":"SDK/API_reference/models/sensors/","title":"Sensors Models","text":""},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.IMU","title":"mosaicolabs.models.sensors.IMU","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code></p> <p>Inertial Measurement Unit data.</p> <p>This model aggregates raw or estimated motion data from accelerometers and gyroscopes, providing a high-frequency snapshot of an object's inertial state.</p> <p>Attributes:</p> Name Type Description <code>acceleration</code> <code>Vector3d</code> <p>Linear acceleration vector [ax, ay, az] in $m/s^2$.</p> <code>angular_velocity</code> <code>Vector3d</code> <p>Angular velocity vector [wx, wy, wz] in $rad/s$.</p> <code>orientation</code> <code>Optional[Quaternion]</code> <p>Optional estimated orientation expressed as a quaternion.</p> <code>header</code> <code>Optional[Header]</code> <p>Standard metadata providing temporal and spatial reference.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.IMU--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This class is fully queryable via the <code>.Q</code> proxy. You can filter IMU data based on physical thresholds or metadata within a <code>QueryOntologyCatalog</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, IMU, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Find high-acceleration events (e.g., impacts) on the X-axis\n    qresponse = client.query(\n        QueryOntologyCatalog(IMU.Q.acceleration.x.gt(15.0))\n        .with_expression(IMU.Q.angular_velocity.z.gt(1.0)),\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(IMU.Q.acceleration.x.gt(15.0), include_timestamp_range=True)\n        .with_expression(IMU.Q.angular_velocity.z.gt(1.0)),\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.IMU.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.IMU.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.IMU.acceleration","title":"acceleration  <code>instance-attribute</code>","text":"<pre><code>acceleration\n</code></pre> <p>Linear acceleration component.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.IMU.acceleration--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Acceleration components are queryable through the <code>acceleration</code> field prefix.</p> Field Access Path Queryable Type Supported Operators <code>IMU.Q.acceleration.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>IMU.Q.acceleration.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>IMU.Q.acceleration.z</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, IMU, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for high-impact events\n    qresponse = client.query(\n        QueryOntologyCatalog(IMU.Q.acceleration.z.gt(19.6))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(IMU.Q.acceleration.z.gt(19.6), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.IMU.angular_velocity","title":"angular_velocity  <code>instance-attribute</code>","text":"<pre><code>angular_velocity\n</code></pre> <p>Angular velocity component.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.IMU.angular_velocity--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Angular velocities components are queryable through the <code>angular_velocity</code> field prefix.</p> Field Access Path Queryable Type Supported Operators <code>IMU.Q.angular_velocity.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>IMU.Q.angular_velocity.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>IMU.Q.angular_velocity.z</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, IMU, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for high-turns events\n    qresponse = client.query(\n        QueryOntologyCatalog(IMU.Q.angular_velocity.z.gt(1.0))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(IMU.Q.angular_velocity.z.gt(1.0), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.IMU.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>orientation = None\n</code></pre> <p>Estimated orientation [qx, qy, qz, qw] (optional).</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.IMU.orientation--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Estimated orientation components are queryable through the <code>orientation</code> field prefix.</p> Field Access Path Queryable Type Supported Operators <code>IMU.Q.orientation.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>IMU.Q.orientation.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>IMU.Q.orientation.z</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>IMU.Q.orientation.w</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, IMU, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for orientation component values\n    qresponse = client.query(\n        QueryOntologyCatalog(IMU.Q.orientation.z.gt(0.707))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(IMU.Q.orientation.z.gt(0.707), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.IMU.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.IMU.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.GPSStatus","title":"mosaicolabs.models.sensors.GPSStatus","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code></p> <p>Status of the GNSS receiver and satellite fix.</p> <p>This class encapsulates quality metrics and operational state of the GNSS receiver, including fix type, satellite usage, and precision dilution factors.</p> <p>Attributes:</p> Name Type Description <code>status</code> <code>int</code> <p>Fix status indicator (e.g., No Fix, 2D, 3D).</p> <code>service</code> <code>int</code> <p>Service used for the fix (e.g., GPS, GLONASS, Galileo).</p> <code>satellites</code> <code>Optional[int]</code> <p>Number of satellites currently visible or used in the solution.</p> <code>hdop</code> <code>Optional[float]</code> <p>Horizontal Dilution of Precision (lower is better).</p> <code>vdop</code> <code>Optional[float]</code> <p>Vertical Dilution of Precision (lower is better).</p> <code>header</code> <code>Optional[Header]</code> <p>Standard metadata providing temporal and spatial reference.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.GPSStatus--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This class is fully queryable via the <code>.Q</code> proxy. You can filter status data based on fix quality or precision metrics within a <code>QueryOntologyCatalog</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, QueryOntologyCatalog, GPSStatus\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for high-quality fixes (low HDOP)\n    qresponse = client.query(\n        QueryOntologyCatalog(GPSStatus.Q.hdop.lt(2.0))\n        .with_expression(GPSStatus.Q.satellites.geq(6)),\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(GPSStatus.Q.hdop.lt(2.0), include_timestamp_range=True)\n        .with_expression(GPSStatus.Q.satellites.geq(6))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.GPSStatus.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.GPSStatus.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.GPSStatus.status","title":"status  <code>instance-attribute</code>","text":"<pre><code>status\n</code></pre> <p>Fix status.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.GPSStatus.status--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The fix status is queryable via the <code>status</code> field.</p> Field Access Path Queryable Type Supported Operators <code>GPSStatus.Q.status</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, QueryOntologyCatalog, GPSStatus\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for valid fixes\n    qresponse = client.query(\n        QueryOntologyCatalog(GPSStatus.Q.status.gt(0))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(GPSStatus.Q.status.gt(0), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.GPSStatus.service","title":"service  <code>instance-attribute</code>","text":"<pre><code>service\n</code></pre> <p>Service used (GPS, GLONASS, etc).</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.GPSStatus.service--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The service identifier is queryable via the <code>service</code> field.</p> Field Access Path Queryable Type Supported Operators <code>GPSStatus.Q.service</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, QueryOntologyCatalog, GPSStatus\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for specific service ID\n    qresponse = client.query(\n        QueryOntologyCatalog(GPSStatus.Q.service.eq(1))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(GPSStatus.Q.service.eq(1), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.GPSStatus.satellites","title":"satellites  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>satellites = None\n</code></pre> <p>Satellites visible/used.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.GPSStatus.satellites--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Satellite count is queryable via the <code>satellites</code> field.</p> Field Access Path Queryable Type Supported Operators <code>GPSStatus.Q.satellites</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, QueryOntologyCatalog, GPSStatus\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for fixes with at least 6 satellites\n    qresponse = client.query(\n        QueryOntologyCatalog(GPSStatus.Q.satellites.geq(6))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(GPSStatus.Q.satellites.geq(6), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.GPSStatus.hdop","title":"hdop  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hdop = None\n</code></pre> <p>Horizontal Dilution of Precision.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.GPSStatus.hdop--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>HDOP values are queryable via the <code>hdop</code> field.</p> Field Access Path Queryable Type Supported Operators <code>GPSStatus.Q.hdop</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, QueryOntologyCatalog, GPSStatus\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for excellent horizontal precision\n    qresponse = client.query(\n        QueryOntologyCatalog(GPSStatus.Q.hdop.lt(1.5))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(GPSStatus.Q.hdop.lt(1.5), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.GPSStatus.vdop","title":"vdop  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vdop = None\n</code></pre> <p>Vertical Dilution of Precision.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.GPSStatus.vdop--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>VDOP values are queryable via the <code>vdop</code> field.</p> Field Access Path Queryable Type Supported Operators <code>GPSStatus.Q.vdop</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, QueryOntologyCatalog, GPSStatus\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for good vertical precision\n    qresponse = client.query(\n        QueryOntologyCatalog(GPSStatus.Q.vdop.lt(2.0))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(GPSStatus.Q.vdop.lt(2.0), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.GPSStatus.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.GPSStatus.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.GPS","title":"mosaicolabs.models.sensors.GPS","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code></p> <p>Processed GNSS fix containing Position, Velocity, and Status.</p> <p>This class serves as the primary container for geodetic location data (WGS 84) and receiver state information.</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>Point3d</code> <p>Lat/Lon/Alt (WGS 84) represented as a <code>Point3d</code>.</p> <code>velocity</code> <code>Optional[Vector3d]</code> <p>Velocity vector [North, East, Alt] in $m/s$.</p> <code>status</code> <code>Optional[GPSStatus]</code> <p>Receiver status info including fix type and satellite count.</p> <code>header</code> <code>Optional[Header]</code> <p>Standard metadata providing temporal and spatial reference.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.GPS--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This class is fully queryable via the <code>.Q</code> proxy. You can filter GPS data based on geodetic coordinates or signal quality within a <code>QueryOntologyCatalog</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, QueryOntologyCatalog, GPS\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Find data collected above 1000m altitude\n    qresponse = client.query(\n        QueryOntologyCatalog(GPS.Q.position.z.gt(1000.0))\n        .with_expression(GPS.Q.status.satellites.geq(6)),\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(GPS.Q.position.z.gt(1000.0), include_timestamp_range=True)\n        .with_expression(GPS.Q.status.satellites.geq(6)),\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.GPS.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.GPS.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.GPS.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position\n</code></pre> <p>Lat/Lon/Alt (WGS 84).</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.GPS.position--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Position components are queryable through the <code>position</code> field prefix.</p> Field Access Path Queryable Type Supported Operators <code>GPS.Q.position.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>GPS.Q.position.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>GPS.Q.position.z</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, QueryOntologyCatalog, GPS\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific latitude range\n    qresponse = client.query(\n        QueryOntologyCatalog(GPS.Q.position.x.between([45.0, 46.0]))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(GPS.Q.position.x.between([45.0, 46.0]), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.GPS.velocity","title":"velocity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>velocity = None\n</code></pre> <p>Velocity vector [North, East, Alt] m/s.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.GPS.velocity--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Velocity components are queryable through the <code>velocity</code> field prefix.</p> Field Access Path Queryable Type Supported Operators <code>GPS.Q.velocity.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>GPS.Q.velocity.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>GPS.Q.velocity.z</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, QueryOntologyCatalog, GPS\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for high vertical velocity\n    qresponse = client.query(\n        QueryOntologyCatalog(GPS.Q.velocity.z.gt(5.0))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(GPS.Q.velocity.z.gt(5.0), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.GPS.status","title":"status  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>status = None\n</code></pre> <p>Receiver status information.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.GPS.status--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Status components are queryable through the <code>status</code> field prefix.</p> Field Access Path Queryable Type Supported Operators <code>GPS.Q.status.satellites</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>GPS.Q.status.hdop</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>GPS.Q.status.vdop</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>GPS.Q.status.status</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>GPS.Q.status.service</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, QueryOntologyCatalog, GPS\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for high-precision fixes with at least 8 satellites\n    qresponse = client.query(\n        QueryOntologyCatalog(GPS.Q.status.satellites.geq(8))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(GPS.Q.status.status.eq(1), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.GPS.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.GPS.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.NMEASentence","title":"mosaicolabs.models.sensors.NMEASentence","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code></p> <p>Raw NMEA 0183 sentence string.</p> <p>Attributes:</p> Name Type Description <code>sentence</code> <code>str</code> <p>The NMEA 0183 sentence string.</p> <code>header</code> <code>Optional[Header]</code> <p>Standard metadata providing temporal and spatial reference.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.NMEASentence--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This class is fully queryable via the <code>.Q</code> proxy. You can filter NMEA data based on the sentence content within a <code>QueryOntologyCatalog</code>.</p> Field Access Path Queryable Type Supported Operators <code>NMEASentence.Q.sentence</code> <code>String</code> <code>.eq()</code>, <code>.neq()</code>, <code>.match()</code>, <code>.in_()</code> Example <pre><code>from mosaicolabs import MosaicoClient, QueryOntologyCatalog, NMEASentence\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for NMEA sentences containing \"GPGGA\"\n    qresponse = client.query(\n        QueryOntologyCatalog(NMEASentence.Q.sentence.match(\"GPGGA\"))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(NMEASentence.Q.sentence.match(\"GPGGA\"), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.NMEASentence.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.NMEASentence.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.NMEASentence.sentence","title":"sentence  <code>instance-attribute</code>","text":"<pre><code>sentence\n</code></pre> <p>Raw ASCII sentence.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.NMEASentence.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.NMEASentence.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Magnetometer","title":"mosaicolabs.models.sensors.Magnetometer","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code></p> <p>Magnetic field measurement data.</p> <p>This class represents the magnetic field measurements from a magnetometer sensor.</p> <p>Attributes:</p> Name Type Description <code>magnetic_field</code> <code>Vector3d</code> <p>Magnetic field vector [mx, my, mz] in microTesla.</p> <code>header</code> <code>Optional[Header]</code> <p>Standard metadata providing temporal and spatial reference.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Magnetometer--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This class is fully queryable via the <code>.Q</code> proxy. You can filter magnetometer data based on magnetic field values within a <code>QueryOntologyCatalog</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Magnetometer, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for magnetic field values within a specific range\n    qresponse = client.query(\n        QueryOntologyCatalog(Magnetometer.Q.magnetic_field.x.between(-100, 100))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Magnetometer.Q.magnetic_field.x.between(-100, 100), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Magnetometer.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Magnetometer.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Magnetometer.magnetic_field","title":"magnetic_field  <code>instance-attribute</code>","text":"<pre><code>magnetic_field\n</code></pre> <p>Magnetic field vector [mx, my, mz] in microTesla.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Magnetometer.magnetic_field--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The magnetic field vector is queryable via the <code>magnetic_field</code> field.</p> Field Access Path Queryable Type Supported Operators <code>Magnetometer.Q.magnetic_field.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>Magnetometer.Q.magnetic_field.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>Magnetometer.Q.magnetic_field.z</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Magnetometer, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for magnetic field values within a specific range\n    qresponse = client.query(\n        QueryOntologyCatalog(Magnetometer.Q.magnetic_field.x.between(-100, 100))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Magnetometer.Q.magnetic_field.x.between(-100, 100), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Magnetometer.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Magnetometer.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Pressure","title":"mosaicolabs.models.sensors.Pressure","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code>, <code>VarianceMixin</code></p> <p>Represents a physical pressure value. The internal representation is always stored in Pascals (Pa).</p> <p>Users are encouraged to use the <code>from_*</code> factory methods when initializing pressure values expressed in units other than Pascals.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>float</code> <p>Pressure value in Pascals (Pa). When using the constructor directly, the value must be provided in Pascals.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Pressure--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This class is fully queryable via the <code>.Q</code> proxy. You can filter pressure data based on pressure values within a <code>QueryOntologyCatalog</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Pressure, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for pressure values within a specific range\n    qresponse = client.query(\n        QueryOntologyCatalog(Pressure.Q.value.between([100000, 200000]))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Pressure.Q.value.between([100000, 200000]), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Pressure.variance","title":"variance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variance = None\n</code></pre> <p>Optional 64-bit float representing the variance of the data.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with the optional variance attribute.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Pressure.variance--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>VarianceMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>variance</code> component.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Pressure.variance_type","title":"variance_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variance_type = None\n</code></pre> <p>Optional 16-bit integer representing the variance parameterization.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with the optional covariance type attribute.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Pressure.variance_type--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>VarianceMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>variance_type</code> component.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Pressure.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Pressure.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Pressure.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value\n</code></pre> <p>The absolute pressure reading from the sensor in Pascals.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Pressure.value--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The pressure value is queryable via the <code>value</code> field.</p> Field Access Path Queryable Type Supported Operators <code>Pressure.Q.value</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Pressure, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for pressure values within a specific range\n    qresponse = client.query(\n        QueryOntologyCatalog(Pressure.Q.value.between([100000, 200000]))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Pressure.Q.value.between([100000, 200000]), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Pressure.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Pressure.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Pressure.from_atm","title":"from_atm  <code>classmethod</code>","text":"<pre><code>from_atm(\n    *, value, header=None, variance=None, variance_type=None\n)\n</code></pre> <p>Creates a <code>Pressure</code> instance using the value in Atm and converting it in Pascal using the formula <code>Pascal = Atm * 101325</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The pressure value in Atm.</p> required <code>header</code> <code>Optional[Header]</code> <p>The standard metadata header (optional).</p> <code>None</code> <code>variance</code> <code>Optional[float]</code> <p>The variance of the data.</p> <code>None</code> <code>variance_type</code> <code>Optional[int]</code> <p>Enum integer representing the variance parameterization.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Pressure</code> <code>Pressure</code> <p>A <code>Pressure</code> instance with value in Pascal.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Pressure.from_bar","title":"from_bar  <code>classmethod</code>","text":"<pre><code>from_bar(\n    *, value, header=None, variance=None, variance_type=None\n)\n</code></pre> <p>Creates a <code>Pressure</code> instance using the value in Bar and converting it in Pascal using the formula <code>Pascal = Bar * 100000</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The pressure value in Bar.</p> required <code>header</code> <code>Optional[Header]</code> <p>The standard metadata header (optional).</p> <code>None</code> <code>variance</code> <code>Optional[float]</code> <p>The variance of the data.</p> <code>None</code> <code>variance_type</code> <code>Optional[int]</code> <p>Enum integer representing the variance parameterization.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Pressure</code> <code>Pressure</code> <p>A <code>Pressure</code> instance with value in Pascal.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Pressure.from_psi","title":"from_psi  <code>classmethod</code>","text":"<pre><code>from_psi(\n    *, value, header=None, variance=None, variance_type=None\n)\n</code></pre> <p>Creates a <code>Pressure</code> instance using the value in Psi and converting it in Pascal using the formula <code>Pascal = Psi * 6894.7572931783</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The pressure value in Psi.</p> required <code>header</code> <code>Optional[Header]</code> <p>The standard metadata header (optional).</p> <code>None</code> <code>variance</code> <code>Optional[float]</code> <p>The variance of the data.</p> <code>None</code> <code>variance_type</code> <code>Optional[int]</code> <p>Enum integer representing the variance parameterization.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Pressure</code> <code>Pressure</code> <p>A <code>Pressure</code> instance with value in Pascal.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Pressure.to_atm","title":"to_atm","text":"<pre><code>to_atm()\n</code></pre> <p>Converts and returns the <code>Pressure</code> value in Atm using the formula <code>Atm = Pascal / 101325</code>.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The <code>Pressure</code> value in Atm.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Pressure.to_bar","title":"to_bar","text":"<pre><code>to_bar()\n</code></pre> <p>Converts and returns the <code>Pressure</code> value in Bar using the formula <code>Bar = Pascal / 100000</code>.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The <code>Pressure</code> value in Bar.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Pressure.to_psi","title":"to_psi","text":"<pre><code>to_psi()\n</code></pre> <p>Converts and returns the <code>Pressure</code> value in Psi using the formula <code>Psi = Pascal / 6894.7572931783</code>.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The <code>Pressure</code> value in Psi.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Range","title":"mosaicolabs.models.sensors.Range","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code>, <code>VarianceMixin</code></p> <p>Represents a range measurement that defines a valid distance interval between the minimum and the maximum value. This with also the field of view, the radiation type and the range value. The internal representation is always stored in meters (m).</p> <p>Attributes:</p> Name Type Description <code>radiation_type</code> <code>int</code> <p>Which type of radiation the sensor used.</p> <code>field_of_view</code> <code>float</code> <p>The arc angle, in Radians (rad), over which the distance reading is valid.</p> <code>min_range</code> <code>float</code> <p>Minimum range value in Meters (m). Fixed distance means that the minimum range must be equal to the maximum range.</p> <code>max_range</code> <code>float</code> <p>Maximum range value in Meters (m). Fixed distance means that the minimum range must be equal to the maximum range.</p> <code>range</code> <code>float</code> <p>Range value in Meters (m).</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Range--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This class is fully queryable via the <code>.Q</code> proxy. You can filter range data based on range parameters within a <code>QueryOntologyCatalog</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Range, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for range data based on range parameters\n    qresponse = client.query(\n        QueryOntologyCatalog(Range.Q.range.between(0.0, 10.0))\n        .with_epression(Range.Q.radiation_type.eq(0))\n        .with_epression(Range.Q.max_range.between(70.0, 90.0)),\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Range.Q.range.between(0.0, 10.0), include_timestamp_range=True)\n        .with_epression(Range.Q.radiation_type.eq(0))\n        .with_epression(Range.Q.max_range.between(70.0, 90.0)),\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Range.variance","title":"variance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variance = None\n</code></pre> <p>Optional 64-bit float representing the variance of the data.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with the optional variance attribute.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Range.variance--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>VarianceMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>variance</code> component.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Range.variance_type","title":"variance_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variance_type = None\n</code></pre> <p>Optional 16-bit integer representing the variance parameterization.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with the optional covariance type attribute.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Range.variance_type--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>VarianceMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>variance_type</code> component.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Range.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Range.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Range.radiation_type","title":"radiation_type  <code>instance-attribute</code>","text":"<pre><code>radiation_type\n</code></pre> <p>Which type of radiation the sensor used.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Range.radiation_type--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The radiation_type is queryable via the <code>radiation_type</code> field.</p> Field Access Path Queryable Type Supported Operators <code>Range.Q.radiation_type</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Range, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for range data based on radiation type\n    qresponse = client.query(\n        QueryOntologyCatalog(Range.Q.radiation_type.eq(0))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Range.field_of_view","title":"field_of_view  <code>instance-attribute</code>","text":"<pre><code>field_of_view\n</code></pre> <p>The arc angle, in radians, over which the distance reading is valid.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Range.field_of_view--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The field_of_view is queryable via the <code>field_of_view</code> field.</p> Field Access Path Queryable Type Supported Operators <code>Range.Q.field_of_view</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Range, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for range data based on field of view\n    qresponse = client.query(\n        QueryOntologyCatalog(Range.Q.field_of_view.between(0.0, 1.0))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Range.min_range","title":"min_range  <code>instance-attribute</code>","text":"<pre><code>min_range\n</code></pre> <p>Minimum range value in meters. Fixed distance means that the minimum range must be equal to the maximum range.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Range.min_range--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The min_range is queryable via the <code>min_range</code> field.</p> Field Access Path Queryable Type Supported Operators <code>Range.Q.min_range</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Range, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for range data based on minimum range\n    qresponse = client.query(\n        QueryOntologyCatalog(Range.Q.min_range.between(0.0, 10.0))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Range.max_range","title":"max_range  <code>instance-attribute</code>","text":"<pre><code>max_range\n</code></pre> <p>Maximum range value in meters. Fixed distance means that the minimum range must be equal to the maximum range.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Range.max_range--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The max_range is queryable via the <code>max_range</code> field.</p> Field Access Path Queryable Type Supported Operators <code>Range.Q.max_range</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Range, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for range data based on maximum range\n    qresponse = client.query(\n        QueryOntologyCatalog(Range.Q.max_range.between(0.0, 10.0))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Range.range","title":"range  <code>instance-attribute</code>","text":"<pre><code>range\n</code></pre> <p>Range value in meters.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Range.range--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The range is queryable via the <code>range</code> field.</p> Field Access Path Queryable Type Supported Operators <code>Range.Q.range</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Range, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for range data based on range\n    qresponse = client.query(\n        QueryOntologyCatalog(Range.Q.range.between(0.0, 10.0))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Range.Q.range.between(0.0, 10.0), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Range.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Range.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Range.validate_min_and_max_range","title":"validate_min_and_max_range","text":"<pre><code>validate_min_and_max_range()\n</code></pre> <p>Ensures that <code>min_range</code> is smaller or equal to <code>max_range</code>.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Range.validate_range","title":"validate_range","text":"<pre><code>validate_range()\n</code></pre> <p>Ensures that <code>range</code> is between <code>min_range</code> and <code>max_range</code>.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Temperature","title":"mosaicolabs.models.sensors.Temperature","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code>, <code>VarianceMixin</code></p> <p>Represents a thermodynamic temperature. The internal representation is always stored in Kelvin (K).</p> <p>Users are encouraged to use the <code>from_*</code> factory methods when initializing temperature values expressed in units other than Kelvin.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>float</code> <p>Temperature value in Kelvin (K). When using the constructor directly, the value must be provided in Kelvin.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Temperature--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This class is fully queryable via the <code>.Q</code> proxy. You can filter temperature data based on temperature values within a <code>QueryOntologyCatalog</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Temperature, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for temperature values within a specific range\n    qresponse = client.query(\n        QueryOntologyCatalog(Temperature.Q.value.between([273.15, 373.15]))\n        .with_expression(Temperature.Q.header.stamp.sec.between(1700000000, 1800000000)),\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Temperature.Q.value.between([273.15, 373.15]), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Temperature.variance","title":"variance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variance = None\n</code></pre> <p>Optional 64-bit float representing the variance of the data.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with the optional variance attribute.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Temperature.variance--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>VarianceMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>variance</code> component.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Temperature.variance_type","title":"variance_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variance_type = None\n</code></pre> <p>Optional 16-bit integer representing the variance parameterization.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with the optional covariance type attribute.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Temperature.variance_type--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>VarianceMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>variance_type</code> component.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Temperature.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Temperature.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Temperature.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value\n</code></pre> <p>Temperature value in Kelvin.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Temperature.value--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The temperature value is queryable via the <code>value</code> field.</p> Field Access Path Queryable Type Supported Operators <code>Temperature.Q.value</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, Temperature, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for temperature values within a specific range\n    qresponse = client.query(\n        QueryOntologyCatalog(Temperature.Q.value.between([273.15, 373.15]))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(Temperature.Q.value.between([273.15, 373.15]), include_timestamp_range=True)\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Temperature.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Temperature.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Temperature.from_celsius","title":"from_celsius  <code>classmethod</code>","text":"<pre><code>from_celsius(\n    *, value, header=None, variance=None, variance_type=None\n)\n</code></pre> <p>Creates a <code>Temperature</code> instance using the value in Celsius and converting it in Kelvin using the formula <code>Kelvin = Celsius + 273.15</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The temperature value in Celsius.</p> required <code>header</code> <code>Optional[Header]</code> <p>The standard metadata header (optional).</p> <code>None</code> <code>variance</code> <code>Optional[float]</code> <p>The variance of the data.</p> <code>None</code> <code>variance_type</code> <code>Optional[int]</code> <p>Enum integer representing the variance parameterization.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Temperature</code> <code>Temperature</code> <p>A <code>Temperature</code> instance with value in Kelvin.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Temperature.from_fahrenheit","title":"from_fahrenheit  <code>classmethod</code>","text":"<pre><code>from_fahrenheit(\n    *, value, header=None, variance=None, variance_type=None\n)\n</code></pre> <p>Creates a <code>Temperature</code> instance using the value in Fahrenheit and converting it in Kelvin using the formula <code>Kelvin = (Fahrenheit - 32) * 5 / 9 + 273.15</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The temperature value in Celsius.</p> required <code>header</code> <code>Optional[Header]</code> <p>The standard metadata header (optional).</p> <code>None</code> <code>variance</code> <code>Optional[float]</code> <p>The variance of the data.</p> <code>None</code> <code>variance_type</code> <code>Optional[int]</code> <p>Enum integer representing the variance parameterization.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Temperature</code> <code>Temperature</code> <p>A <code>Temperature</code> instance with value in Kelvin.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Temperature.to_celsius","title":"to_celsius","text":"<pre><code>to_celsius()\n</code></pre> <p>Converts and returns the <code>Temperature</code> value in Celsius using the formula <code>Celsius = Kelvin - 273.15</code>.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The <code>Temperature</code> value in Celsius.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Temperature.to_fahrenheit","title":"to_fahrenheit","text":"<pre><code>to_fahrenheit()\n</code></pre> <p>Converts and returns the <code>Temperature</code> value in Fahrenheit using the formula <code>Fahrenheit = (Kelvin - 273.15) * 9 / 5 + 32</code>.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The <code>Temperature</code> value in Fahrenheit.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.RobotJoint","title":"mosaicolabs.models.sensors.RobotJoint","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code></p> <p>Snapshot of robot joint states.</p> <p>Arrays must be index-aligned (e.g., names[0] corresponds to positions[0]).</p> <p>Attributes:</p> Name Type Description <code>names</code> <code>List[str]</code> <p>Names of the different robot joints</p> <code>positions</code> <code>List[float]</code> <p>Positions ([rad] or [m]) of the different robot joints</p> <code>velocities</code> <code>List[float]</code> <p>Velocities ([rad/s] or [m/s]) of the different robot joints</p> <code>efforts</code> <code>List[float]</code> <p>Efforts ([N] or [N/m]) applied to the different robot joints</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.RobotJoint--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The robot joint states cannot be queried via the <code>.Q</code> proxy.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.RobotJoint.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.RobotJoint.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.RobotJoint.names","title":"names  <code>instance-attribute</code>","text":"<pre><code>names\n</code></pre> <p>Names of the different robot joints</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.RobotJoint.names--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The names are not queryable via the <code>.Q</code> proxy (Lists are not supported yet).</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.RobotJoint.positions","title":"positions  <code>instance-attribute</code>","text":"<pre><code>positions\n</code></pre> <p>Positions ([rad] or [m]) of the different robot joints</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.RobotJoint.positions--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The positions are not queryable via the <code>.Q</code> proxy (Lists are not supported yet).</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.RobotJoint.velocities","title":"velocities  <code>instance-attribute</code>","text":"<pre><code>velocities\n</code></pre> <p>Velocities ([rad/s] or [m/s]) of the different robot joints</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.RobotJoint.velocities--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The velocities are not queryable via the <code>.Q</code> proxy (Lists are not supported yet).</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.RobotJoint.efforts","title":"efforts  <code>instance-attribute</code>","text":"<pre><code>efforts\n</code></pre> <p>Efforts ([N] or [N/m]) applied to the different robot joints</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.RobotJoint.efforts--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The efforts are not queryable via the <code>.Q</code> proxy (Lists are not supported yet).</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.RobotJoint.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.RobotJoint.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Image","title":"mosaicolabs.models.sensors.Image","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code></p> <p>Represents raw, uncompressed image data.</p> <p>This class provides a flattened, row-major binary representation of an image. It is designed to handle: 1.  Arbitrary Data Types: From standard uint8 RGB to float32 Depth and uint16 IR. 2.  Memory Layouts: Explicit control over <code>stride</code> (stride) and endianness (<code>is_bigendian</code>). 3.  Transport: Can act as a container for RAW bytes or wrap them in lossless containers (PNG).</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>bytes</code> <p>The flattened image memory buffer.</p> <code>format</code> <code>ImageFormat</code> <p>The format used for serialization ('png' or 'raw').</p> <code>width</code> <code>int</code> <p>The width of the image in pixels.</p> <code>height</code> <code>int</code> <p>The height of the image in pixels.</p> <code>stride</code> <code>int</code> <p>Bytes per row. Essential for alignment.</p> <code>encoding</code> <code>str</code> <p>Pixel format (e.g., 'bgr8', 'mono16').</p> <code>is_bigendian</code> <code>bool</code> <p>True if data is Big-Endian. Defaults to system endianness if null.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Image--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This class is fully queryable via the <code>.Q</code> proxy. You can filter image data based on image parameters within a <code>QueryOntologyCatalog</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, QueryOntologyCatalog, Image\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for image data based on image parameters\n    qresponse = client.query(\n        QueryOntologyCatalog(Image.Q.width.between(1500, 2000))\n        .with_expression(Image.Q.height.between(1500, 2000))\n        .with_expression(Image.Q.format.eq(\"png\")),\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Image.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Image.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Image.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data\n</code></pre> <p>The flattened image memory buffer.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Image.data--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The data is not queryable via the <code>data</code> field (bytes are not comparable).</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Image.format","title":"format  <code>instance-attribute</code>","text":"<pre><code>format\n</code></pre> <p>The format used for serialization ('png' or 'raw').</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Image.format--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The format is queryable via the <code>format</code> field.</p> Field Access Path Queryable Type Supported Operators <code>Image.Q.format</code> <code>String</code> <code>.eq()</code>, <code>.neq()</code>, <code>.match()</code>, <code>.in_()</code> Example <pre><code>from mosaicolabs import MosaicoClient, QueryOntologyCatalog, Image\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for image data based on format\n    qresponse = client.query(\n        QueryOntologyCatalog(Image.Q.format.eq(ImageFormat.PNG))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Image.width","title":"width  <code>instance-attribute</code>","text":"<pre><code>width\n</code></pre> <p>The width of the image in pixels.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Image.width--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The width is queryable via the <code>width</code> field.</p> Field Access Path Queryable Type Supported Operators <code>Image.Q.width</code> <code>Integer</code> <code>.eq()</code>, <code>.neq()</code>, <code>.gt()</code>, <code>.gte()</code>, <code>.lt()</code>, <code>.lte()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, QueryOntologyCatalog, Image\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for image data based on width\n    qresponse = client.query(\n        QueryOntologyCatalog(Image.Q.width.between(0, 100))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Image.height","title":"height  <code>instance-attribute</code>","text":"<pre><code>height\n</code></pre> <p>The height of the image in pixels.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Image.height--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The height is queryable via the <code>height</code> field.</p> Field Access Path Queryable Type Supported Operators <code>Image.Q.height</code> <code>Integer</code> <code>.eq()</code>, <code>.neq()</code>, <code>.gt()</code>, <code>.gte()</code>, <code>.lt()</code>, <code>.lte()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, QueryOntologyCatalog, Image\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for image data based on height\n    qresponse = client.query(\n        QueryOntologyCatalog(Image.Q.height.between(0, 100))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Image.stride","title":"stride  <code>instance-attribute</code>","text":"<pre><code>stride\n</code></pre> <p>The number of bytes per row of the image.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Image.stride--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The stride is queryable via the <code>stride</code> field.</p> Field Access Path Queryable Type Supported Operators <code>Image.Q.stride</code> <code>Integer</code> <code>.eq()</code>, <code>.neq()</code>, <code>.gt()</code>, <code>.gte()</code>, <code>.lt()</code>, <code>.lte()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, QueryOntologyCatalog, Image\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for image data based on stride\n    qresponse = client.query(\n        QueryOntologyCatalog(Image.Q.stride.between(0, 100))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Image.encoding","title":"encoding  <code>instance-attribute</code>","text":"<pre><code>encoding\n</code></pre> <p>The pixel encoding (e.g., 'bgr8', 'mono16'). Optional field.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Image.encoding--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The encoding is queryable via the <code>encoding</code> field.</p> Field Access Path Queryable Type Supported Operators <code>Image.Q.encoding</code> <code>String</code> <code>.eq()</code>, <code>.neq()</code>, <code>.match()</code>, <code>.in_()</code> Example <pre><code>from mosaicolabs import MosaicoClient, QueryOntologyCatalog, Image\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for image data based on encoding\n    qresponse = client.query(\n        QueryOntologyCatalog(Image.Q.encoding.eq(\"bgr8\"))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Image.is_bigendian","title":"is_bigendian  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_bigendian = None\n</code></pre> <p>Store if the original data is Big-Endian. Optional field.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Image.is_bigendian--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The is_bigendian is queryable via the <code>is_bigendian</code> field.</p> Field Access Path Queryable Type Supported Operators <code>Image.Q.is_bigendian</code> <code>Boolean</code> <code>.eq()</code>, <code>.neq()</code> Example <pre><code>from mosaicolabs import MosaicoClient, QueryOntologyCatalog, Image\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for image data based on is_bigendian\n    qresponse = client.query(\n        QueryOntologyCatalog(Image.Q.is_bigendian.eq(True))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Image.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Image.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Image.from_linear_pixels","title":"from_linear_pixels  <code>classmethod</code>","text":"<pre><code>from_linear_pixels(\n    data,\n    stride,\n    height,\n    width,\n    encoding,\n    header=None,\n    is_bigendian=None,\n    format=_DEFAULT_IMG_FORMAT,\n)\n</code></pre> <p>Encodes linear pixel uint8 data into the storage container.</p> <p>The \"Wide Grayscale\" Trick: When saving complex types (like <code>float32</code> depth or <code>uint16</code> raw) into standard image containers like PNG, we cannot rely on standard RGB encoders as they might apply color corrections or bit-depth reductions.</p> <p>Instead, this method treats the data as a raw byte stream. It reshapes the stream into a 2D \"Grayscale\" image where: - <code>Image_Height</code> = <code>Original_Height</code> - <code>Image_Width</code> = <code>Stride</code> (The full row stride in bytes)</p> <p>This guarantees that every bit of the original memory (including padding) is preserved losslessly.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>List[int]</code> <p>Flattened list of bytes (uint8).</p> required <code>stride</code> <code>int</code> <p>Row stride in bytes.</p> required <code>height</code> <code>int</code> <p>Image height.</p> required <code>width</code> <code>int</code> <p>Image width.</p> required <code>encoding</code> <code>str</code> <p>Pixel format string.</p> required <code>format</code> <code>ImageFormat</code> <p>Target container ('raw' or 'png').</p> <code>_DEFAULT_IMG_FORMAT</code> <p>Returns:</p> Name Type Description <code>Image</code> <code>Image</code> <p>An instantiated object.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Image.to_linear_pixels","title":"to_linear_pixels","text":"<pre><code>to_linear_pixels()\n</code></pre> <p>Decodes the storage container back to a linear byte list.</p> <p>Reverses the \"Wide Grayscale\" encoding to return the original, flattened memory buffer.</p> <p>Returns:</p> Type Description <code>List[int]</code> <p>List[int]: A list of uint8 integers representing the raw memory.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Image.to_pillow","title":"to_pillow","text":"<pre><code>to_pillow()\n</code></pre> <p>Converts the raw binary data into a standard PIL Image.</p> <p>This method performs the heavy lifting of interpretation: 1.  Decoding: Unpacks the transport container (e.g., PNG -&gt; bytes). 2.  Casting: Interprets bytes according to <code>self.encoding</code> (e.g., as float32). 3.  Endianness: Swaps bytes if the source endianness differs from the local CPU. 4.  Color Swap: Converts BGR (common in OpenCV/Robotics) to RGB (required by PIL).</p> <p>Returns:</p> Type Description <code>Image</code> <p>PILImage.Image: A visualizable image object.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the encoding is unknown.</p> <code>ValueError</code> <p>If data size doesn't match dimensions.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.Image.from_pillow","title":"from_pillow  <code>classmethod</code>","text":"<pre><code>from_pillow(\n    pil_image,\n    header=None,\n    target_encoding=None,\n    output_format=None,\n)\n</code></pre> <p>Factory method to create an Image from a PIL object.</p> <p>Automatically handles:</p> <ul> <li>Data flattening (row-major).</li> <li>Stride calculation.</li> <li>RGB to BGR conversion (if target_encoding requires it).</li> <li>Type casting (e.g., float -&gt; uint8).</li> </ul> <p>Parameters:</p> Name Type Description Default <code>pil_image</code> <code>Image</code> <p>Source image.</p> required <code>header</code> <code>Optional[Header]</code> <p>Metadata.</p> <code>None</code> <code>target_encoding</code> <code>Optional[str]</code> <p>Target pixel format (e.g., \"bgr8\").</p> <code>None</code> <code>output_format</code> <code>Optional[ImageFormat]</code> <p>('raw' or 'png').</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Image</code> <code>Image</code> <p>Populated data object.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CompressedImage","title":"mosaicolabs.models.sensors.CompressedImage","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code></p> <p>Represents image data stored as a compressed binary blob (e.g. JPEG, PNG, H264, ...).</p> <p>This class acts as a data container. It delegates the complex logic of decoding (bytes -&gt; Image) and encoding (Image -&gt; bytes) to the registered codecs in <code>_IMG_CODECS_FACTORY</code>.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>bytes</code> <p>The compressed binary payload.</p> <code>format</code> <code>str</code> <p>The format identifier string (e.g., 'jpeg', 'png').</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CompressedImage--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This class is fully queryable via the <code>.Q</code> proxy. You can filter image data based on image parameters within a <code>QueryOntologyCatalog</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, CompressedImage, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for image data based on image parameters\n    qresponse = client.query(\n        QueryOntologyCatalog(CompressedImage.Q.format.eq(\"jpeg\"))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CompressedImage.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CompressedImage.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CompressedImage.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data\n</code></pre> <p>The serialized (compressed) image data as bytes.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CompressedImage.data--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The data is not queryable via the <code>data</code> field (bytes are not comparable).</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CompressedImage.format","title":"format  <code>instance-attribute</code>","text":"<pre><code>format\n</code></pre> <p>The compression format (e.g., 'jpeg', 'png').</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CompressedImage.format--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"Field Access Path Queryable Type Supported Operators <code>CompressedImage.Q.format</code> <code>String</code> <code>.eq()</code>, <code>.neq()</code>, <code>.match()</code>, <code>.in_()</code> Example <pre><code>from mosaicolabs import MosaicoClient, CompressedImage, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for image data based on image parameters\n    qresponse = client.query(\n        QueryOntologyCatalog(CompressedImage.Q.format.eq(\"jpeg\"))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CompressedImage.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CompressedImage.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CompressedImage.to_image","title":"to_image","text":"<pre><code>to_image()\n</code></pre> <p>Decompresses the stored binary data into a usable PIL Image object.</p> <p>NOTE: The function use the _DefaultCodec which is valid for stateless formats only ('png', 'jpeg', ...). If dealing with a stateful compressed image, the conversion must be made via explicit instantiation of a StatefulDecodingSession class.</p> <p>Returns:</p> Name Type Description <code>Optional[Image]</code> <p>PILImage.Image: A ready-to-use Pillow image object.</p> <code>None</code> <code>Optional[Image]</code> <p>If the data is empty or decoding fails.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CompressedImage.from_image","title":"from_image  <code>classmethod</code>","text":"<pre><code>from_image(image, format=PNG, header=None, **kwargs)\n</code></pre> <p>Factory method to create a CompressedImage from a PIL Image.</p> <p>NOTE: The function use the _DefaultCodec which is valid for stateless formats only ('png', 'jpeg', ...). If dealing with a stateful compressed image, the conversion must be made via user defined encoding algorithms.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>The source Pillow image.</p> required <code>format</code> <code>ImageFormat</code> <p>The target compression format (default: 'jpeg').</p> <code>PNG</code> <code>header</code> <code>Optional[Header]</code> <p>Optional Header metadata.</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments passed to the codec's encode method       (e.g., quality=90).</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>CompressedImage</code> <code>CompressedImage</code> <p>A new instance containing the compressed bytes.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no codec is found or encoding fails.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.ImageFormat","title":"mosaicolabs.models.sensors.ImageFormat","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Supported containers for image formats.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CameraInfo","title":"mosaicolabs.models.sensors.CameraInfo","text":"<p>               Bases: <code>Serializable</code>, <code>HeaderMixin</code></p> <p>Meta-information for interpreting images from a calibrated camera.</p> <p>This structure mirrors standard robotics camera models (e.g., ROS <code>sensor_msgs/CameraInfo</code>). It enables pipelines to rectify distorted images or project 3D points onto the 2D image plane.</p> <p>Attributes:</p> Name Type Description <code>height</code> <code>int</code> <p>Height in pixels of the image with which the camera was calibrated</p> <code>width</code> <code>int</code> <p>Width in pixels of the image with which the camera was calibrated</p> <code>distortion_model</code> <code>str</code> <p>The distortion model used</p> <code>distortion_parameters</code> <code>list[float]</code> <p>The distortion coefficients (k1, k2, t1, t2, k3...). Size depends on the model.</p> <code>intrinsic_parameters</code> <code>list[float]</code> <p>The 3x3 Intrinsic Matrix (K) flattened row-major.</p> <code>rectification_parameters</code> <code>list[float]</code> <p>The 3x3 Rectification Matrix (R) flattened row-major.</p> <code>projection_parameters</code> <code>list[float]</code> <p>The 3x4 Projection Matrix (P) flattened row-major.</p> <code>binning</code> <code>Optional[Vector2d]</code> <p>Hardware binning factor (x, y). If null, assumes (0, 0) (no binning).</p> <code>roi</code> <code>Optional[ROI]</code> <p>Region of Interest. Used if the image is a sub-crop of the full resolution.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CameraInfo--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>This class is fully queryable via the <code>.Q</code> proxy. You can filter camera data based on camera parameters within a <code>QueryOntologyCatalog</code>.</p> Example <pre><code>from mosaicolabs import MosaicoClient, QueryOntologyCatalog, CameraInfo\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for camera data based on camera parameters\n    qresponse = client.query(\n        QueryOntologyCatalog(CameraInfo.Q.height.between(1080, 2160))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CameraInfo.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header = None\n</code></pre> <p>An optional metadata header providing temporal and spatial context to the ontology model.</p> <p>This field is injected into the model via composition, ensuring that sensor data is  paired with standard acquisition attributes like sequence IDs and high-precision  timestamps.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CameraInfo.header--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>Check the documentation of the <code>HeaderMixin</code> to construct a valid expression for the  <code>QueryOntologyCatalog</code> builder involving the <code>header</code> component.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CameraInfo.height","title":"height  <code>instance-attribute</code>","text":"<pre><code>height\n</code></pre> <p>Height in pixels of the image with which the camera was calibrated</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CameraInfo.height--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The height is queryable via the <code>height</code> field.</p> Field Access Path Queryable Type Supported Operators <code>CameraInfo.Q.height</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, QueryOntologyCatalog, CameraInfo\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for camera data based on camera parameters\n    qresponse = client.query(\n        QueryOntologyCatalog(CameraInfo.Q.height.between(1080, 2160))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CameraInfo.width","title":"width  <code>instance-attribute</code>","text":"<pre><code>width\n</code></pre> <p>Width in pixels of the image with which the camera was calibrated</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CameraInfo.width--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The width is queryable via the <code>width</code> field.</p> Field Access Path Queryable Type Supported Operators <code>CameraInfo.Q.width</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, QueryOntologyCatalog, CameraInfo\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for camera data based on camera parameters\n    qresponse = client.query(\n        QueryOntologyCatalog(CameraInfo.Q.width.between(1920, 3840))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CameraInfo.distortion_model","title":"distortion_model  <code>instance-attribute</code>","text":"<pre><code>distortion_model\n</code></pre> <p>The distortion model used</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CameraInfo.distortion_model--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The distortion model is queryable via the <code>distortion_model</code> field.</p> Field Access Path Queryable Type Supported Operators <code>CameraInfo.Q.distortion_model</code> <code>Categorical</code> <code>.eq()</code>, <code>.neq()</code>, <code>.in_()</code> Example <pre><code>from mosaicolabs import MosaicoClient, QueryOntologyCatalog, CameraInfo\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for camera data based on camera parameters\n    qresponse = client.query(\n        QueryOntologyCatalog(CameraInfo.Q.distortion_model.eq(\"plumb_bob\"))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CameraInfo.distortion_parameters","title":"distortion_parameters  <code>instance-attribute</code>","text":"<pre><code>distortion_parameters\n</code></pre> <p>The distortion coefficients (k1, k2, t1, t2, k3...). Size depends on the model.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CameraInfo.distortion_parameters--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The distortion parameters are not queryable via the <code>.Q</code> proxy (Lists are not supported yet).</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CameraInfo.intrinsic_parameters","title":"intrinsic_parameters  <code>instance-attribute</code>","text":"<pre><code>intrinsic_parameters\n</code></pre> <p>The 3x3 Intrinsic Matrix (K) flattened row-major.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CameraInfo.intrinsic_parameters--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The intrinsic parameters are not queryable via the <code>.Q</code> proxy (Lists are not supported yet).</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CameraInfo.rectification_parameters","title":"rectification_parameters  <code>instance-attribute</code>","text":"<pre><code>rectification_parameters\n</code></pre> <p>The 3x3 Rectification Matrix (R) flattened row-major.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CameraInfo.rectification_parameters--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The rectification parameters cannot be queried via the <code>.Q</code> proxy (Lists are not supported yet).</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CameraInfo.projection_parameters","title":"projection_parameters  <code>instance-attribute</code>","text":"<pre><code>projection_parameters\n</code></pre> <p>The 3x4 Projection Matrix (P) flattened row-major.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CameraInfo.projection_parameters--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The projection parameters cannot be queried via the <code>.Q</code> proxy (Lists are not supported yet).</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CameraInfo.binning","title":"binning  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>binning = None\n</code></pre> <p>Hardware binning factor (x, y). If null, assumes (0, 0) (no binning).</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CameraInfo.binning--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The binning parameters are queryable via the <code>binning</code> field.</p> Field Access Path Queryable Type Supported Operators <code>CameraInfo.Q.binning.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>CameraInfo.Q.binning.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, QueryOntologyCatalog, CameraInfo\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for camera data based on camera parameters\n    qresponse = client.query(\n        QueryOntologyCatalog(CameraInfo.Q.binning.x.eq(2))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CameraInfo.roi","title":"roi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>roi = None\n</code></pre> <p>Region of Interest. Used if the image is a sub-crop of the full resolution.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CameraInfo.roi--querying-with-the-q-proxy","title":"Querying with the <code>.Q</code> Proxy","text":"<p>The roi parameters are queryable via the <code>roi</code> field.</p> Field Access Path Queryable Type Supported Operators <code>CameraInfo.Q.roi.offset.x</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>CameraInfo.Q.roi.offset.y</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>CameraInfo.Q.roi.width</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> <code>CameraInfo.Q.roi.height</code> <code>Numeric</code> <code>.eq()</code>, <code>.neq()</code>, <code>.lt()</code>, <code>.gt()</code>, <code>.leq()</code>, <code>.geq()</code>, <code>.in_()</code>, <code>.between()</code> Example <pre><code>from mosaicolabs import MosaicoClient, QueryOntologyCatalog, CameraInfo\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for camera data based on camera parameters\n    qresponse = client.query(\n        QueryOntologyCatalog(CameraInfo.Q.roi.offset.x.eq(2))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CameraInfo.is_registered","title":"is_registered  <code>classmethod</code>","text":"<pre><code>is_registered()\n</code></pre> <p>Checks if a class is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if registered.</p>"},{"location":"SDK/API_reference/models/sensors/#mosaicolabs.models.sensors.CameraInfo.ontology_tag","title":"ontology_tag  <code>classmethod</code>","text":"<pre><code>ontology_tag()\n</code></pre> <p>Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.</p> <p>This method provides the string key used by the Mosaico platform to identify and route specific data types within the ontology registry. It abstracts away the internal naming conventions, ensuring that you always use the correct identifier for queries and serialization.</p> <p>Returns:</p> Type Description <code>str</code> <p>The registered string tag for this class (e.g., <code>\"imu\"</code>, <code>\"gps\"</code>).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the class was not properly initialized via <code>__init_subclass__</code>.</p> Practical Application: Topic Filtering <p>This method is particularly useful when constructing <code>QueryTopic</code> requests. By using the convenience method <code>QueryTopic.with_ontology_tag()</code>, you can filter topics by data type without hardcoding strings that might change.</p> <p>Example:     <pre><code>from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryTopic(\n            Topic.with_ontology_tag(IMU.ontology_tag()),\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre></p>"},{"location":"SDK/API_reference/query/builders/","title":"Query Builders","text":""},{"location":"SDK/API_reference/query/builders/#mosaicolabs.models.query.builders","title":"mosaicolabs.models.query.builders","text":"<p>This module provides the high-level \"Fluent\" API for constructing complex searches across the Mosaico Data Platform.</p> <p>It implements a Domain-Specific Language that allows users to filter Sequences, Topics, and Ontology data using a type-safe, method-chaining interface.</p> <p>Key Components:</p> <ul> <li><code>Query</code>: The root container that aggregates multiple specialized sub-queries.</li> <li><code>QueryOntologyCatalog</code>: For fine-grained filtering based on sensor-specific field values (e.g., <code>IMU.Q.acceleration.x &gt; 9.8</code>).</li> <li><code>QueryTopic</code>: Specifically for filtering topic-level metadata.</li> <li><code>QuerySequence</code>: Specifically for filtering sequence-level metadata.</li> </ul>"},{"location":"SDK/API_reference/query/builders/#mosaicolabs.models.query.builders.QueryOntologyCatalog","title":"QueryOntologyCatalog","text":"<pre><code>QueryOntologyCatalog(\n    *expressions, include_timestamp_range=None\n)\n</code></pre> <p>A top-level query object for the Data Catalog that combines multiple sensor-field expressions.</p> <p>This builder allows for fine-grained filtering based on the actual values contained within sensor payloads (e.g., IMU acceleration, GPS coordinates, or custom telemetry). It produces a \"flat\" dictionary output where field paths utilize dot-notation (e.g., <code>\"imu.acceleration.x\"</code>).</p> <p>This class is designed to work with the <code>.Q</code> query proxy injected into every <code>Serializable</code> data ontology model. You can use this proxy on any registered sensor class (like <code>IMU</code>, <code>Vector3d</code>, <code>Point3d</code>), etc. to create type-safe expressions.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Topic, QuerySequence\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for a specific data value (using constructor)\n    qresponse = client.query(\n        QueryOntologyCatalog(IMU.Q.acceleration.x.lt(-4.0)) # Using constructor\n        .with_expression(IMU.Q.acceleration.y.gt(5.0)) # Using with_expression\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(IMU.Q.acceleration.x.lt(-4.0), include_timestamp_range=True)\n        .with_expression(IMU.Q.acceleration.y.gt(5.0))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre> <p>The constructor initializes the query with an optional list of <code>_QueryCatalogExpression</code> objects, generated via <code>&lt;Model&gt;.Q.</code> proxy, where model is any of the available data ontology (e.g. IMU.Q, GPS.Q, String.Q, etc.)</p> <p>Parameters:</p> Name Type Description Default <code>*expressions</code> <code>_QueryExpression</code> <p>A variable number of expressions, generated via the <code>.Q</code> proxy on an ontology model.</p> <code>()</code> <code>include_timestamp_range</code> <code>Optional[bool]</code> <p>If <code>True</code>, the server will return the <code>start</code> and <code>end</code> timestamps corresponding to the temporal bounds of the matched data.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If an expression is not of the supported type.</p> <code>ValueError</code> <p>If an operator does not start with the required '$' prefix.</p> <code>NotImplementedError</code> <p>If a duplicate key (field path) is detected within the same query.</p>"},{"location":"SDK/API_reference/query/builders/#mosaicolabs.models.query.builders.QueryOntologyCatalog.with_expression","title":"with_expression","text":"<pre><code>with_expression(expr)\n</code></pre> <p>Adds a new <code>_QueryCatalogExpression</code> expression to the query using a fluent interface.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Topic, QuerySequence\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Chain multiple sensor filters together\n    qresponse = client.query(\n        QueryOntologyCatalog()\n        .with_expression(GPS.Q.status.satellites.geq(8))\n        .with_expression(GPS.Q.position.x.between([44.0, 45.0]))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter for a specific component value and extract the first and last occurrence times\n    qresponse = client.query(\n        QueryOntologyCatalog(include_timestamp_range=True)\n        .with_expression(IMU.Q.acceleration.x.lt(-4.0))\n        .with_expression(IMU.Q.acceleration.y.gt(5.0))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {{topic.name:\n                        [topic.timestamp_range.start, topic.timestamp_range.end]\n                        for topic in item.topics}}\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>_QueryExpression</code> <p>A valid expression generated via the <code>.Q</code> proxy on an ontology model, e.g., <code>GPS.Q.status.satellites.leq(10)</code>.</p> required <p>Returns:</p> Type Description <code>QueryOntologyCatalog</code> <p>The <code>QueryOntologyCatalog</code> instance for method chaining.</p>"},{"location":"SDK/API_reference/query/builders/#mosaicolabs.models.query.builders.QueryOntologyCatalog.name","title":"name","text":"<pre><code>name()\n</code></pre> <p>Returns the top-level key ('ontology') used for nesting inside a root <code>Query</code>.</p>"},{"location":"SDK/API_reference/query/builders/#mosaicolabs.models.query.builders.QueryOntologyCatalog.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Serializes the ontology expressions into a flat dictionary for the platform API.</p> Example Output <p><code>{\"imu.timestamp_ns\": {\"$between\": [...]}, \"imu.acceleration.x\": {\"$leq\": 10}}</code></p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dictionary containing all merged sensor-field expressions.</p>"},{"location":"SDK/API_reference/query/builders/#mosaicolabs.models.query.builders.QueryTopic","title":"QueryTopic","text":"<pre><code>QueryTopic(*expressions)\n</code></pre> <p>A top-level query object for Topic data that combines multiple expressions with a logical AND.</p> <p>This builder handles the complex partitioning required to query both flat system fields (like <code>name</code> or <code>ontology_tag</code>) and nested dictionary fields (like <code>user_metadata</code>). The resulting dictionary output preserves this hierarchical structure for server-side processing.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Image, Topic, QuerySequence\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Query for all 'image' topics created in a specific timeframe, matching some metadata (key, value) pair\n    qresponse = client.query(\n        QueryTopic()\n        .with_ontology_tag(Image.ontology_tag())\n        .with_created_timestamp(time_start=Time.from_float(1700000000))\n        .with_expression(Topic.Q.user_metadata[\"camera_id.serial_number\"].eq(\"ABC123_XYZ\"))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre> <p>The constructor initializes the query with an optional list of <code>_QueryTopicExpression</code> objects, generated via <code>Topic.Q.</code> proxy.</p> <p>This builder leverages the <code>.Q</code> query proxy on the <code>user_metadata</code> field of the <code>Topic</code> model to provide a type-safe, fluent interface for filtering.</p> <p>Parameters:</p> Name Type Description Default <code>*expressions</code> <code>_QueryExpression</code> <p>A variable number of <code>Topic.Q</code> (<code>_QueryTopicExpression</code>) expression objects.</p> <code>()</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If an expression is not of the supported <code>Topic.Q</code> type.</p> <code>ValueError</code> <p>If an operator does not follow the required internal '$' prefix format.</p> <code>NotImplementedError</code> <p>If a duplicate key is detected, as the current implementation enforces unique keys per query.</p>"},{"location":"SDK/API_reference/query/builders/#mosaicolabs.models.query.builders.QueryTopic.with_expression","title":"with_expression","text":"<pre><code>with_expression(expr)\n</code></pre> <p>Adds a new expression to the query using a fluent interface.</p> <p>This is the way to add filters for nested metadata.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Topic, QuerySequence\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Target a specific known topic path\n    qresponse = client.query(\n        QueryTopic().with_expression(Topic.Q.user_metadata[\"version\"].eq(\"1.0\"))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>_QueryExpression</code> <p>A <code>_QueryTopicExpression</code> constructed via a <code>Topic.Q</code> proxy.</p> required <p>Returns:</p> Type Description <code>QueryTopic</code> <p>The <code>QueryTopic</code> instance for method chaining.</p>"},{"location":"SDK/API_reference/query/builders/#mosaicolabs.models.query.builders.QueryTopic.with_name","title":"with_name","text":"<pre><code>with_name(name)\n</code></pre> <p>Adds an exact match filter for the topic 'name' field.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Topic, QuerySequence\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Target a specific known topic path\n    qresponse = client.query(\n        QueryTopic().with_name(\"vehicle/front/camera\")\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The exact name of the topic to match.</p> required <p>Returns:</p> Type Description <code>QueryTopic</code> <p>The <code>QueryTopic</code> instance for method chaining.</p>"},{"location":"SDK/API_reference/query/builders/#mosaicolabs.models.query.builders.QueryTopic.with_name_match","title":"with_name_match","text":"<pre><code>with_name_match(name)\n</code></pre> <p>Adds a partial (fuzzy) match filter for the topic 'name' field.</p> <p>This performs an 'in-between' search (equivalent to %name%) on the full <code>sequence/topic</code> path.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Topic, QuerySequence\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Search for all topics containing the word 'camera'\n    qresponse = client.query(\n        QueryTopic().with_name_match(\"camera\")\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The string pattern to search for within the topic name.</p> required <p>Returns:</p> Type Description <code>QueryTopic</code> <p>The <code>QueryTopic</code> instance for method chaining.</p>"},{"location":"SDK/API_reference/query/builders/#mosaicolabs.models.query.builders.QueryTopic.with_ontology_tag","title":"with_ontology_tag","text":"<pre><code>with_ontology_tag(ontology_tag)\n</code></pre> <p>Adds an exact match filter for the 'ontology_tag' field.</p> <p>This filter restricts the search to topics belonging to a specific data type identifier (e.g., 'imu', 'gnss').</p> Example <p><pre><code>from mosaicolabs import MosaicoClient, Topic, QuerySequence\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter for IMU-only data streams\n    qresponse = client.query(\n        QueryTopic().with_ontology_tag(IMU.ontology_tag())\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre> Note: To ensure compatibility and avoid hardcoding strings, it is highly recommended to retrieve the tag dynamically using the <code>ontology_tag()</code> method of the desired ontology class.</p> <p>Parameters:</p> Name Type Description Default <code>ontology_tag</code> <code>str</code> <p>The string tag (e.g., 'imu', 'gps') to filter by.</p> required <p>Returns:</p> Type Description <code>QueryTopic</code> <p>The <code>QueryTopic</code> instance for method chaining.</p>"},{"location":"SDK/API_reference/query/builders/#mosaicolabs.models.query.builders.QueryTopic.with_created_timestamp","title":"with_created_timestamp","text":"<pre><code>with_created_timestamp(time_start=None, time_end=None)\n</code></pre> <p>Adds a filter for the 'created_timestamp' field using high-precision Time.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Topic, QuerySequence\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Find sequences created during a specific day\n    qresponse = client.query(\n        QueryTopic().with_created_timestamp(\n            time_start=Time.from_float(1704067200.0), # 2024-01-01\n            time_end=Time.from_float(1704153600.0)    # 2024-01-02\n        )\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>time_start</code> <code>Optional[Time]</code> <p>Optional lower bound (inclusive).</p> <code>None</code> <code>time_end</code> <code>Optional[Time]</code> <p>Optional upper bound (inclusive).</p> <code>None</code> <p>Returns:</p> Type Description <code>QueryTopic</code> <p>The <code>QueryTopic</code> instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both bounds are None or if <code>time_start &gt; time_end</code>.</p>"},{"location":"SDK/API_reference/query/builders/#mosaicolabs.models.query.builders.QueryTopic.name","title":"name","text":"<pre><code>name()\n</code></pre> <p>Returns the top-level key ('topic') used when nesting this query inside a root <code>Query</code>.</p>"},{"location":"SDK/API_reference/query/builders/#mosaicolabs.models.query.builders.QueryTopic.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Serializes the query into a nested dictionary for the platform API.</p> <p>This method partitions expressions into two groups:</p> <ol> <li>System Fields: Standard fields like <code>name</code> are kept in the root dictionary.</li> <li>Metadata Fields: Fields starting with a dictionary-type model key (e.g., <code>user_metadata</code>)    are stripped of their prefix and nested under that key.</li> </ol> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dictionary representation of the query, e.g., <code>{\"name\": {\"$eq\": \"...\"}, \"user_metadata\": {\"key\": {\"$eq\": \"...\"}}}</code>.</p>"},{"location":"SDK/API_reference/query/builders/#mosaicolabs.models.query.builders.QuerySequence","title":"QuerySequence","text":"<pre><code>QuerySequence(*expressions)\n</code></pre> <p>A top-level query object for Sequence data that combines multiple expressions with a logical AND.</p> <p>This builder handles the complex partitioning required to query both flat system fields (like <code>name</code>) and nested dictionary fields (like <code>user_metadata</code>). The resulting dictionary output preserves this hierarchical structure for server-side processing.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Topic, QuerySequence\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Search for sequences by project name and creation date\n    qresponse = client.query(\n        QuerySequence()\n        .with_expression(Sequence.Q.user_metadata[\"project\"].eq(\"Apollo\"))\n        .with_created_timestamp(time_start=Time.from_float(1690000000.0))\n    )\n\n    # Inspect the response\n    for item in qresponse:\n        print(f\"Sequence: {item.sequence.name}\")\n        print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre> <p>The constructor initializes the query with an optional list of <code>_QuerySequenceExpression</code> objects, generated via <code>Sequence.Q.</code> proxy.</p> <p>This builder leverages the <code>.Q</code> query proxy specifically on the <code>user_metadata</code> field of the <code>Sequence</code> model to provide a type-safe, fluent interface for filtering.</p> <p>Parameters:</p> Name Type Description Default <code>*expressions</code> <code>_QueryExpression</code> <p>A variable number of <code>Sequence.Q</code> (<code>_QuerySequenceExpression</code>) objects.</p> <code>()</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If an expression is not of the supported <code>Sequence.Q</code> type.</p> <code>ValueError</code> <p>If an operator does not follow the required internal '$' prefix format.</p> <code>NotImplementedError</code> <p>If a duplicate key is detected, as the current implementation enforces unique keys per query.</p>"},{"location":"SDK/API_reference/query/builders/#mosaicolabs.models.query.builders.QuerySequence.with_expression","title":"with_expression","text":"<pre><code>with_expression(expr)\n</code></pre> <p>Adds a new expression to the query using a fluent interface.</p> <p>This is the way to add filters for nested metadata.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Topic, QuerySequence\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Target a specific known topic path\n    qresponse = client.query(\n        QuerySequence().with_expression(Sequence.Q.user_metadata[\"project\"].eq(\"Apollo\"))\n    )\n\n    # Inspect the response\n    for item in qresponse:\n        print(f\"Sequence: {item.sequence.name}\")\n        print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>_QueryExpression</code> <p>A <code>_QuerySequenceExpression</code> constructed via a <code>Sequence.Q</code> proxy.</p> required <p>Returns:</p> Type Description <code>QuerySequence</code> <p>The <code>QuerySequence</code> instance for method chaining.</p>"},{"location":"SDK/API_reference/query/builders/#mosaicolabs.models.query.builders.QuerySequence.with_name","title":"with_name","text":"<pre><code>with_name(name)\n</code></pre> <p>Adds an exact match filter for the sequence 'name' field.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Topic, QuerySequence\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Find all sequences with name equal to 'test_winter_01'\n    qresponse = client.query(\n        QuerySequence().with_name(\"test_winter_01\")\n    )\n\n    # Inspect the response\n    for item in qresponse:\n        print(f\"Sequence: {item.sequence.name}\")\n        print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The exact name of the sequence to match.</p> required <p>Returns:</p> Type Description <code>QuerySequence</code> <p>The <code>QuerySequence</code> instance for method chaining.</p>"},{"location":"SDK/API_reference/query/builders/#mosaicolabs.models.query.builders.QuerySequence.with_name_match","title":"with_name_match","text":"<pre><code>with_name_match(name)\n</code></pre> <p>Adds a partial (fuzzy) match filter for the sequence 'name' field.</p> <p>This performs an 'in-between' search (equivalent to %name%) on the sequence name.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Topic, QuerySequence\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Find all sequences with name containing 'calibration_run_'\n    qresponse = client.query(\n        QuerySequence().with_name_match(\"calibration_run_\")\n    )\n\n    # Inspect the response\n    for item in qresponse:\n        print(f\"Sequence: {item.sequence.name}\")\n        print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The string pattern to search for within the sequence name.</p> required <p>Returns:</p> Type Description <code>QuerySequence</code> <p>The <code>QuerySequence</code> instance for method chaining.</p>"},{"location":"SDK/API_reference/query/builders/#mosaicolabs.models.query.builders.QuerySequence.with_created_timestamp","title":"with_created_timestamp","text":"<pre><code>with_created_timestamp(time_start=None, time_end=None)\n</code></pre> <p>Adds a filter for the 'created_timestamp' field using high-precision Time.</p> Example <pre><code>from mosaicolabs import MosaicoClient, Topic, QuerySequence\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Find sequences created during a specific time range\n    qresponse = client.query(\n        QuerySequence().with_created_timestamp(\n            time_start=Time.from_float(1704067200.0), # 2024-01-01\n            time_end=Time.from_float(1704153600.0)    # 2024-01-02\n        )\n    )\n\n    # Inspect the response\n    for item in qresponse:\n        print(f\"Sequence: {item.sequence.name}\")\n        print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>time_start</code> <code>Optional[Time]</code> <p>Optional lower bound (inclusive).</p> <code>None</code> <code>time_end</code> <code>Optional[Time]</code> <p>Optional upper bound (inclusive).</p> <code>None</code> <p>Returns:</p> Type Description <code>QuerySequence</code> <p>The <code>QuerySequence</code> instance for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both bounds are <code>None</code> or if <code>time_start &gt; time_end</code>.</p>"},{"location":"SDK/API_reference/query/builders/#mosaicolabs.models.query.builders.QuerySequence.name","title":"name","text":"<pre><code>name()\n</code></pre> <p>Returns the top-level key ('sequence') used for nesting inside a root <code>Query</code>.</p>"},{"location":"SDK/API_reference/query/builders/#mosaicolabs.models.query.builders.QuerySequence.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Serializes the query into a nested dictionary for the platform API.</p> <p>This method partitions expressions into:</p> <ol> <li>Normal Fields: Fields like <code>name</code> are kept in a flat dictionary.</li> <li>Metadata Fields: Fields targeting <code>user_metadata</code> are collected and nested.</li> </ol> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dictionary representation preserving the hierarchical structure.</p>"},{"location":"SDK/API_reference/query/builders/#mosaicolabs.models.query.builders.Query","title":"Query","text":"<pre><code>Query(*queries)\n</code></pre> <p>A top-level \"root\" query object that aggregates multiple specialized sub-queries into a single request body.</p> <p>This class serves as the final envelope for multi-domain queries, ensuring that different query types (Topic, Sequence, Ontology) do not overwrite each other.</p> Example <pre><code>from mosaicolabs import QueryOntologyCatalog, QuerySequence, Query, IMU, MosaicoClient\n\n# Establish a connection to the Mosaico Data Platform\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Build a filter with name pattern and metadata-related expression\n    query = Query(\n        # Append a filter for sequence metadata\n        QuerySequence()\n        .with_expression(\n            # Use query proxy for generating a _QuerySequenceExpression\n            Sequence.Q.user_metadata[\"environment.visibility\"].lt(50)\n        )\n        .with_name_match(\"test_drive\"),\n        # Append a filter with deep time-series data discovery and measurement time windowing\n        QueryOntologyCatalog(include_timestamp_range=True)\n        .with_expression(IMU.Q.acceleration.x.gt(5.0))\n        .with_expression(IMU.Q.header.stamp.sec.gt(1700134567))\n        .with_expression(IMU.Q.header.stamp.nanosec.between([123456, 789123])),\n    )\n    # Perform the server side query\n    qresponse = client.query(query=query)\n    # Inspect the response\n        if qresponse is not None:\n            # Results are automatically grouped by Sequence for easier data management\n            for item in qresponse:\n                print(f\"Sequence: {item.sequence.name}\")\n                print(f\"Topics: {{topic.name:\n                            [topic.timestamp_range.start, topic.timestamp_range.end]\n                            for topic in item.topics}}\")\n</code></pre> <p>Initializes the root query with a set of sub-queries.</p> <p>Parameters:</p> Name Type Description Default <code>*queries</code> <code>QueryableProtocol</code> <p>A variable number of sub-query objects (e.g., <code>QueryTopic()</code>, <code>QuerySequence()</code>).</p> <code>()</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If duplicate query types are detected in the initial arguments.</p>"},{"location":"SDK/API_reference/query/builders/#mosaicolabs.models.query.builders.Query.append","title":"append","text":"<pre><code>append(*queries)\n</code></pre> <p>Adds additional sub-queries to the existing root query.</p> <p>Parameters:</p> Name Type Description Default <code>*queries</code> <code>QueryableProtocol</code> <p>Additional sub-query instances.</p> <code>()</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an appended query type is already present in the request.</p> Example <pre><code>from mosaicolabs import QueryOntologyCatalog, QuerySequence, Query, IMU, MosaicoClient\n\n# Build a filter with name pattern and metadata-related expression\nquery = Query(\n    # Append a filter for sequence metadata\n    QuerySequence()\n    .with_expression(\n        # Use query proxy for generating a _QuerySequenceExpression\n        Sequence.Q.user_metadata[\"environment.visibility\"].lt(50)\n    )\n    .with_name_match(\"test_drive\")\n)\n\n# Append a filter with deep time-series data discovery and measurement time windowing\nquery.append(\n    QueryOntologyCatalog()\n    .with_expression(IMU.Q.acceleration.x.gt(5.0))\n    .with_expression(IMU.Q.header.stamp.sec.gt(1700134567))\n    .with_expression(IMU.Q.header.stamp.nanosec.between([123456, 789123])),\n)\n</code></pre>"},{"location":"SDK/API_reference/query/builders/#mosaicolabs.models.query.builders.Query.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Serializes the entire multi-domain query into the final JSON dictionary.</p> <p>It orchestrates the conversion by calling the <code>.name()</code> and <code>.to_dict()</code> methods of each contained sub-query.</p> Example Output <pre><code>{\n    \"topic\": { ... topic filters ... },\n    \"sequence\": { ... sequence filters ... },\n    \"ontology\": { ... ontology filters ... }\n}\n</code></pre> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The final aggregated query dictionary.</p>"},{"location":"SDK/API_reference/query/internal/","title":"Internal Types","text":""},{"location":"SDK/API_reference/query/internal/#mosaicolabs.models.query.protocols.QueryableProtocol","title":"mosaicolabs.models.query.protocols.QueryableProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Structural protocol for classes that integrate into a multi-domain <code>Query</code>.</p> <p>A class implicitly satisfies this protocol if it provides a unique identification tag via <code>name()</code> and a serialization method via <code>to_dict()</code>. This protocol ensures that the root <code>Query</code> or the  can orchestrate complex requests without knowing the specific internal logic of each sub-query.</p>"},{"location":"SDK/API_reference/query/internal/#mosaicolabs.models.query.protocols.QueryableProtocol--reference-implementations","title":"Reference Implementations","text":"<p>The following classes are standard examples of this protocol:</p> <ul> <li><code>QueryTopic</code>: Filters Topic-level metadata.</li> <li><code>QuerySequence</code>: Filters Sequence-level metadata.</li> <li><code>QueryOntologyCatalog</code>: Filters fine-grained sensor field data.</li> </ul>"},{"location":"SDK/API_reference/query/internal/#mosaicolabs.models.query.protocols.QueryableProtocol.with_expression","title":"with_expression","text":"<pre><code>with_expression(expr)\n</code></pre> <p>Appends a new filter expression using a fluent interface.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>_QueryExpression</code> <p>A valid <code>_QueryExpression</code></p> required"},{"location":"SDK/API_reference/query/internal/#mosaicolabs.models.query.protocols.QueryableProtocol.name","title":"name","text":"<pre><code>name()\n</code></pre> <p>Returns the unique key identifying this sub-query within the root request.</p> <p>Examples include <code>\"topic\"</code>, <code>\"sequence\"</code>, or <code>\"ontology\"</code>.</p>"},{"location":"SDK/API_reference/query/internal/#mosaicolabs.models.query.protocols.QueryableProtocol.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Serializes the internal expressions into a platform-compatible dictionary.</p>"},{"location":"SDK/API_reference/query/internal/#mosaicolabs.models.query.expressions._QueryExpression","title":"mosaicolabs.models.query.expressions._QueryExpression","text":"<pre><code>_QueryExpression(full_path, op, value)\n</code></pre> <p>Base class for all atomic comparison operations in the Mosaico Query DSL.</p> <p>A <code>_QueryExpression</code> represents the smallest indivisible unit of a query. It is typically not instantiated directly by the user, but is instead the result of a terminal method call on a queryable field (e.g., <code>.gt()</code>, <code>.eq()</code>, <code>.between()</code>) via the <code>.Q</code> query proxy.</p> <p>The class manages the expression lifecycle in a Query:</p> <ol> <li>Generation: A user calls <code>IMU.Q.acceleration.x.gt(9.8)</code>, which generates     a <code>_QueryCatalogExpression</code> (a subclass of this class).</li> <li>Validation: A Builder receives the expression     and validates its type, operator format, and key uniqueness.</li> <li>Serialization: The builder calls <code>.to_dict()</code> on the expression to     transform it into the specific JSON format expected by the platform.</li> </ol> <p>Attributes:</p> Name Type Description <code>full_path</code> <p>The complete, dot-separated path to the target field on the platform.</p> <code>op</code> <p>The Mosaico-compliant operator string (e.g., <code>\"$eq\"</code>, <code>\"$gt\"</code>, <code>\"$between\"</code>).</p> <code>value</code> <p>The comparison value or data structure (e.g., a constant, a list for <code>$in</code>, or a range for <code>$between</code>).</p> <p>Initializes an atomic comparison.</p> <p>Parameters:</p> Name Type Description Default <code>full_path</code> <code>str</code> <p>The dot-separated field path used in the final query dictionary.</p> required <code>op</code> <code>str</code> <p>The short-string operation identifier (must start with <code>$</code>).</p> required <code>value</code> <code>Any</code> <p>The constant value for the comparison.</p> required"},{"location":"SDK/API_reference/query/internal/#mosaicolabs.models.query.expressions._QueryExpression.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Converts the expression into its final dictionary format.</p> Example <p><code>{\"gps.status.service\": {\"$eq\": 0}}</code></p>"},{"location":"SDK/API_reference/query/internal/#mosaicolabs.models.query.expressions._QueryTopicExpression","title":"mosaicolabs.models.query.expressions._QueryTopicExpression","text":"<pre><code>_QueryTopicExpression(full_path, op, value)\n</code></pre> <p>               Bases: <code>_QueryExpression</code></p> <p>An atomic comparison unit specialized for the Topic Catalog context.</p> <p>This class is utilized exclusively by the <code>QueryTopic</code> builder to filter topics based on system attributes (like <code>name</code> or <code>ontology_tag</code>) and nested user metadata.</p> <p>The <code>QueryTopic</code> class enforces that all provided expressions are instances of this type to prevent cross-domain query contamination.</p> <p>Internal Translation Example:</p> User Call Internal Translation <code>Topic.Q.user_metadata[\"calibrated\"].eq(True)</code> <code>_QueryTopicExpression(\"user_metadata.calibrated\", \"$eq\", True)</code> <code>QueryTopic().with_name(\"camera_front\")</code> <code>_QueryTopicExpression(\"name\", \"$eq\", \"camera_front\")</code> <code>QueryTopic().with_ontology_tag(\"imu\")</code> <code>_QueryTopicExpression(\"ontology_tag\", \"$eq\", \"imu\")</code> <p>Initializes an atomic comparison.</p> <p>Parameters:</p> Name Type Description Default <code>full_path</code> <code>str</code> <p>The dot-separated field path used in the final query dictionary.</p> required <code>op</code> <code>str</code> <p>The short-string operation identifier (must start with <code>$</code>).</p> required <code>value</code> <code>Any</code> <p>The constant value for the comparison.</p> required"},{"location":"SDK/API_reference/query/internal/#mosaicolabs.models.query.expressions._QueryTopicExpression.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Converts the expression into its final dictionary format.</p> Example <p><code>{\"gps.status.service\": {\"$eq\": 0}}</code></p>"},{"location":"SDK/API_reference/query/internal/#mosaicolabs.models.query.expressions._QuerySequenceExpression","title":"mosaicolabs.models.query.expressions._QuerySequenceExpression","text":"<pre><code>_QuerySequenceExpression(full_path, op, value)\n</code></pre> <p>               Bases: <code>_QueryExpression</code></p> <p>An atomic comparison unit specialized for the Sequence Catalog context.</p> <p>This class represents filters targeting high-level sequence containers. It is the only expression type accepted by the <code>QuerySequence</code> builder.</p> <p>It handles fields such as the sequence <code>name</code>, <code>created_timestamp</code>, or custom entries within the sequence's <code>user_metadata</code>.</p> <p>Internal Translation Example:</p> User Call Internal Translation <code>Sequence.Q.user_metadata[\"project\"].eq(\"Apollo\")</code> <code>_QuerySequenceExpression(\"user_metadata.project\", \"$eq\", \"Apollo\")</code> <code>QuerySequence().with_name(\"Apollo\")</code> <code>_QuerySequenceExpression(\"name\", \"$eq\", \"Apollo\")</code> <code>QuerySequence().with_created_timestamp(Time.from_float(1704067200.0))</code> <code>_QuerySequenceExpression(\"created_timestamp\", \"$between\", [1704067200.0, None])</code> <p>Initializes an atomic comparison.</p> <p>Parameters:</p> Name Type Description Default <code>full_path</code> <code>str</code> <p>The dot-separated field path used in the final query dictionary.</p> required <code>op</code> <code>str</code> <p>The short-string operation identifier (must start with <code>$</code>).</p> required <code>value</code> <code>Any</code> <p>The constant value for the comparison.</p> required"},{"location":"SDK/API_reference/query/internal/#mosaicolabs.models.query.expressions._QuerySequenceExpression.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Converts the expression into its final dictionary format.</p> Example <p><code>{\"gps.status.service\": {\"$eq\": 0}}</code></p>"},{"location":"SDK/API_reference/query/internal/#mosaicolabs.models.query.expressions._QueryCatalogExpression","title":"mosaicolabs.models.query.expressions._QueryCatalogExpression","text":"<pre><code>_QueryCatalogExpression(full_path, op, value)\n</code></pre> <p>               Bases: <code>_QueryExpression</code></p> <p>An atomic comparison unit specialized for Data Ontology (Sensor Payload) filtering.</p> <p>This expression type is used by the <code>QueryOntologyCatalog</code> builder to filter actual sensor data values across the entire platform.</p> <p>Because ontology queries target specific fields within a sensor payload (e.g., accelerometer readings), these expressions use fully qualified dot-notated paths prefixed by the ontology tag.</p> <p>Internal Translation Example:</p> User Call Internal Translation <code>IMU.Q.acceleration.x.gt(9.8)</code> <code>_QueryCatalogExpression(\"imu.acceleration.x\", \"$gt\", 9.8)</code> <code>IMU.Q.acceleration.y.gt(9.8)</code> <code>_QueryCatalogExpression(\"imu.acceleration.y\", \"$gt\", 9.8)</code> <code>IMU.Q.acceleration.z.gt(9.8)</code> <code>_QueryCatalogExpression(\"imu.acceleration.z\", \"$gt\", 9.8)</code> <code>IMU.Q.acceleration.x.gt(9.8)</code> <code>_QueryCatalogExpression(\"imu.acceleration.x\", \"$gt\", 9.8)</code> <p>Initializes an atomic comparison.</p> <p>Parameters:</p> Name Type Description Default <code>full_path</code> <code>str</code> <p>The dot-separated field path used in the final query dictionary.</p> required <code>op</code> <code>str</code> <p>The short-string operation identifier (must start with <code>$</code>).</p> required <code>value</code> <code>Any</code> <p>The constant value for the comparison.</p> required"},{"location":"SDK/API_reference/query/internal/#mosaicolabs.models.query.expressions._QueryCatalogExpression.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Converts the expression into its final dictionary format.</p> Example <p><code>{\"gps.status.service\": {\"$eq\": 0}}</code></p>"},{"location":"SDK/API_reference/query/response/","title":"Response","text":""},{"location":"SDK/API_reference/query/response/#mosaicolabs.models.query.response","title":"mosaicolabs.models.query.response","text":""},{"location":"SDK/API_reference/query/response/#mosaicolabs.models.query.response.TimestampRange","title":"TimestampRange  <code>dataclass</code>","text":"<pre><code>TimestampRange(start, end)\n</code></pre> <p>Represents a temporal window defined by a start and end timestamp.</p> <p>This utility class is used to define the bounds of sensor data or sequences within the Mosaico archive.</p> <p>Attributes:</p> Name Type Description <code>start</code> <code>int</code> <p>The beginning of the range (inclusive), typically in nanoseconds.</p> <code>end</code> <code>int</code> <p>The end of the range (inclusive), typically in nanoseconds.</p>"},{"location":"SDK/API_reference/query/response/#mosaicolabs.models.query.response.QueryResponseItemSequence","title":"QueryResponseItemSequence  <code>dataclass</code>","text":"<pre><code>QueryResponseItemSequence(name)\n</code></pre> <p>Metadata container for a single sequence discovered during a query.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The unique identifier of the sequence in the Mosaico database.</p>"},{"location":"SDK/API_reference/query/response/#mosaicolabs.models.query.response.QueryResponseItemTopic","title":"QueryResponseItemTopic  <code>dataclass</code>","text":"<pre><code>QueryResponseItemTopic(name, timestamp_range)\n</code></pre> <p>Metadata for a specific topic (sensor stream) within a sequence.</p> <p>Contains information about the topic's identity and its available time range in the archive.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the topic (e.g., 'front_camera/image_raw').</p> <code>timestamp_range</code> <code>Optional[TimestampRange]</code> <p>The availability window of the data for this specific topic.</p>"},{"location":"SDK/API_reference/query/response/#mosaicolabs.models.query.response.QueryResponseItem","title":"QueryResponseItem  <code>dataclass</code>","text":"<pre><code>QueryResponseItem(sequence, topics)\n</code></pre> <p>A unified result item representing a sequence and its associated topics.</p> <p>This serves as the primary unit of data returned when querying the Mosaico metadata catalog.</p> <p>Attributes:</p> Name Type Description <code>sequence</code> <code>QueryResponseItemSequence</code> <p>The parent sequence metadata.</p> <code>topics</code> <code>List[QueryResponseItemTopic]</code> <p>The list of topics available within this sequence that matched the query criteria.</p>"},{"location":"SDK/API_reference/query/response/#mosaicolabs.models.query.response.QueryResponse","title":"QueryResponse  <code>dataclass</code>","text":"<pre><code>QueryResponse(items=list())\n</code></pre> <p>An iterable collection of results returned by a Mosaico metadata query.</p> <p>This class provides convenience methods to transform search results back into query builders, enabling a fluid, multi-stage filtering workflow.</p> Example <pre><code>from mosaicolabs import MosaicoClient, IMU, Floating64, QueryOntologyCatalog\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Filter IMU data by a specific acquisition second\n    qresponse = client.query(\n        QueryOntologyCatalog(IMU.Q.header.stamp.sec.lt(1770282868))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n\n    # Filter primitive Floating64 telemetry by frame identifier\n    qresponse = client.query(\n        QueryOntologyCatalog(Floating64.Q.header.frame_id.eq(\"robot_base\"))\n    )\n\n    # Inspect the response\n    if qresponse is not None:\n        # Results are automatically grouped by Sequence for easier data management\n        for item in qresponse:\n            print(f\"Sequence: {item.sequence.name}\")\n            print(f\"Topics: {[topic.name for topic in item.topics]}\")\n</code></pre> <p>Attributes:</p> Name Type Description <code>items</code> <code>List[QueryResponseItem]</code> <p>The list of items matching the query.</p>"},{"location":"SDK/API_reference/query/response/#mosaicolabs.models.query.response.QueryResponse.to_query_sequence","title":"to_query_sequence","text":"<pre><code>to_query_sequence()\n</code></pre> <p>Converts the current response into a QuerySequence builder.</p> <p>This allows for further filtering or operations on the specific set of sequences returned in this response.</p> Example <p>This demonstrates query chaining to narrow your search to specific sequences and topics. This is necessary when criteria span different data channels; otherwise, the resulting filters chained in <code>AND</code> in a single query would produce an empty result.</p> <pre><code>from mosaicolabs import MosaicoClient, QuerySequence\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Broad Search: Find sequences with high-precision GPS\n    initial_response = client.query(QueryOntologyCatalog(GPS.Q.status.status.eq(2)))\n\n    # Chaining: Use results to \"lock\" the domain and find specific data in those sequences\n    # on different data channels\n    if not initial_response.is_empty():\n        final_response = client.query(\n            initial_response.to_query_sequence(),              # The \"locked\" sequence domain\n            QueryTopic().with_name(\"/localization/log_string\"), # Target a specific log topic\n            QueryOntologyCatalog(String.Q.data.match(\"[ERR]\"))  # Filter by content\n        )\n</code></pre> <p>Returns:</p> Name Type Description <code>QuerySequence</code> <code>QuerySequence</code> <p>A builder initialized with an '$in' filter on the sequence names.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the response is empty.</p>"},{"location":"SDK/API_reference/query/response/#mosaicolabs.models.query.response.QueryResponse.to_query_topic","title":"to_query_topic","text":"<pre><code>to_query_topic()\n</code></pre> <p>Converts the current response into a QueryTopic builder.</p> <p>Useful for narrowing down a search to specific topics found within the retrieved sequences.</p> Example <pre><code>from mosaicolabs import MosaicoClient, QueryTopic\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Broad Search: Find sequences with high-precision GPS\n    initial_response = client.query(\n            QueryTopic().with_name(\"/localization/log_string\"), # Target a specific log topic\n            QuerySequence().with_name_match(\"test_winter_2025_\")  # Filter by content\n        )\n\n    # Chaining: Use results to \"lock\" the domain and find specific log-patterns in those sequences\n    if not initial_response.is_empty():\n        final_response = client.query(\n            initial_response.to_query_topic(),              # The \"locked\" topic domain\n            QueryOntologyCatalog(String.Q.data.match(\"[ERR]\"))  # Filter by content\n        )\n</code></pre> <p>Returns:</p> Name Type Description <code>QueryTopic</code> <code>QueryTopic</code> <p>A builder initialized with an '$in' filter on the topic names.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the response is empty.</p>"},{"location":"SDK/API_reference/query/response/#mosaicolabs.models.query.response.QueryResponse.is_empty","title":"is_empty","text":"<pre><code>is_empty()\n</code></pre> <p>Returns True if the response contains no results.</p>"},{"location":"SDK/bridges/ml/","title":"Machine Learning & Analytics","text":"<p>The Mosaico ML module serves as the high-performance bridge between the Mosaico Data Platform and the modern Data Science ecosystem. While the platform is optimized for high-speed raw message streaming, this module provides the abstractions necessary to transform asynchronous sensor data into tabular formats compatible with Physical AI, Deep Learning, and Predictive Analytics.</p> <p>Working with robotics and multi-modal datasets presents three primary technical hurdles that the ML module is designed to solve:</p> <ul> <li>Heterogeneous Sampling: Sensors like LIDAR (low frequency), IMU (high frequency), and GPS (intermittent) operate at different rates.</li> <li>High Volume: Datasets often exceed the available system RAM.</li> <li>Nested Structures: Robotics data is typically deeply nested with coordinate transformations and covariance matrices.</li> </ul>"},{"location":"SDK/bridges/ml/#from-sequences-to-dataframes","title":"From Sequences to DataFrames","text":"<p>API Reference: <code>mosaicolabs.ml.DataFrameExtractor</code></p> <p>The <code>DataFrameExtractor</code> is a specialized utility designed to convert Mosaico sequences into tabular formats. Unlike standard streamers that instantiate individual Python objects, this extractor operates at the Batch Level by pulling raw <code>RecordBatch</code> objects directly from the underlying stream to maximize throughput.</p>"},{"location":"SDK/bridges/ml/#key-technical-features","title":"Key Technical Features","text":"<ul> <li>Recursive Flattening: Automatically \"unpacks\" deeply nested Mosaico Ontology structures into primitive columns.</li> <li>Semantic Naming: Columns use a <code>{topic_name}.{ontology_tag}.{field_path}</code> convention (e.g., <code>/front/camera/imu.imu.acceleration.x</code>) to remain self-describing.</li> <li>Namespace Isolation: Topic names are included in column headers to prevent collisions when multiple sensors of the same type are present.</li> <li>Memory-Efficient Windowing: Uses a generator-based approach to yield data in time-based \"chunks\" (e.g., 5-second windows) while handling straddling batches via a carry-over buffer.</li> <li>Sparse Merging: Creates a \"sparse\" DataFrame containing the union of all timestamps, using <code>NaN</code> for missing sensor readings at specific intervals.</li> </ul> <p>This example demonstrates iterating through a sequence in 10-second tabular chunks.</p> <pre><code>from mosaicolabs import MosaicoClient\nfrom mosaicolabs.ml import DataFrameExtractor\n\nwith MosaicoClient.connect(\"localhost\", 6726):\n    # Initialize from an existing SequenceHandler\n    seq_handler = client.sequence_handler(\"drive_session_01\")\n    extractor = DataFrameExtractor(seq_handler)\n\n    # Iterate through 10-second chunks\n    for df in extractor.to_pandas_chunks(window_sec=10.0):\n        # 'df' is a pandas DataFrame with semantic columns\n        # Example: df[\"/front/camera/imu.imu.acceleration.x\"]\n        print(f\"Processing chunk with {len(df)} rows\")\n</code></pre> <p>For complex types like images that require specialized decoding, Mosaico allows you to \"inflate\" a flattened DataFrame row back into a strongly-typed <code>Message</code> object.</p> <pre><code>from mosaicolabs import MosaicoClient\nfrom mosaicolabs.ml import DataFrameExtractor\nfrom mosaicolabs.models import Message, Image\n\nwith MosaicoClient.connect(\"localhost\", 6726):\n    # Initialize from an existing SequenceHandler\n    seq_handler = client.sequence_handler(\"drive_session_01\")\n    extractor = DataFrameExtractor(seq_handler)\n\n    # Get data chunks\n    for df in extractor.to_pandas_chunks(topics=[\"/sensors/front/image_raw\"]):\n        for _, row in df.iterrows():\n            # Reconstruct the full Message (envelope + payload) from a row\n            img_msg = Message.from_dataframe_row(\n                row=row,\n                topic_name=\"/sensors/front/image_raw\",\n            )\n\n            if img_msg:\n                img = img_msg.get_data(Image).to_pillow()\n                # Access typed fields with IDE autocompletion\n                print(f\"Time: {img_msg.timestamp_ns}\")\n                img.show()\n</code></pre>"},{"location":"SDK/bridges/ml/#sparse-to-dense-representation","title":"Sparse to Dense Representation","text":"<p>API Reference: <code>mosaicolabs.ml.SyncTransformer</code></p> <p>The <code>SyncTransformer</code> is a temporal resampler designed to solve the Heterogeneous Sampling problem inherent in robotics and Physical AI.  It aligns multi-rate sensor streams (for example, an IMU at 100Hz and a GPS at 5Hz) onto a uniform, fixed-frequency grid to prepare them for machine learning models. The <code>SyncTransformer</code> operates as a processor that bridges the gaps between windowed chunks yielded by the <code>DataFrameExtractor</code>. Unlike standard resamplers that treat each data batch in isolation, this transformer maintains internal state to ensure signal continuity across batch boundaries.</p>"},{"location":"SDK/bridges/ml/#key-design-principles","title":"Key Design Principles","text":"<ul> <li>Stateful Continuity: It maintains an internal cache of the last known sensor values and the next expected grid tick, allowing signals to bridge the gap between independent DataFrame chunks.</li> <li>Semantic Integrity: It respects the physical reality of data acquisition by yielding <code>None</code> for grid ticks that occur before a sensor's first physical measurement, avoiding data \"hallucination\".</li> <li>Vectorized Performance: Internal kernels leverage high-speed lookups for high-throughput processing.</li> <li>Protocol-Based Extensibility: The mathematical logic for resampling is decoupled through a <code>SynchPolicy</code> protocol, allowing for custom kernel injection.</li> </ul>"},{"location":"SDK/bridges/ml/#implemented-synchronization-policies","title":"Implemented Synchronization Policies","text":"<p>API Reference: <code>mosaicolabs.ml.SyncPolicy</code></p> <p>Each policy defines a specific logic for how the transformer bridges temporal gaps between sparse data points.</p>"},{"location":"SDK/bridges/ml/#1-synchold-last-value-hold","title":"1. <code>SyncHold</code> (Last-Value-Hold)","text":"<ul> <li>Behavior: Finds the most recent valid measurement and \"holds\" it constant until a new one arrives.</li> <li>Best For: Sensors where states remain valid until explicitly changed, such as robot joint positions or battery levels.</li> </ul>"},{"location":"SDK/bridges/ml/#2-syncasof-staleness-guard","title":"2. <code>SyncAsOf</code> (Staleness Guard)","text":"<ul> <li>Behavior: Carries the last known value forward only if it has not exceeded a defined maximum \"tolerance\" (fresher than a specific age).</li> <li>Best For: High-speed signals that become unreliable if not updated frequently, such as localization coordinates.</li> </ul>"},{"location":"SDK/bridges/ml/#3-syncdrop-interval-filter","title":"3. <code>SyncDrop</code> (Interval Filter)","text":"<ul> <li>Behavior: Ensures a grid tick only receives a value if a new measurement actually occurred within that specific grid interval; otherwise, it returns <code>None</code>.</li> <li>Best For: Downsampling high-frequency data where a strict 1-to-1 relationship between windows and unique hardware events is required.</li> </ul>"},{"location":"SDK/bridges/ml/#scikit-learn-compatibility","title":"Scikit-Learn Compatibility","text":"<p>By implementing the standard <code>fit</code>/<code>transform</code> interface, the <code>SyncTransformer</code> makes robotics data a \"first-class citizen\" of the Scikit-learn ecosystem. This allows for the plug-and-play integration of multi-rate sensor data into standard pipelines.</p> <pre><code>from sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import StandardScaler\nfrom mosaicolabs import MosaicoClient\nfrom mosaicolabs.ml import DataFrameExtractor, SyncTransformer, SynchHold\n\n\n# Define a pipeline for physical AI preprocessing\npipeline = Pipeline([\n    ('sync', SyncTransformer(target_fps=30.0, policy=SynchHold())),\n    ('scaler', StandardScaler())\n])\n\nwith MosaicoClient.connect(\"localhost\", 6726):\n    # Initialize from an existing SequenceHandler\n    seq_handler = client.sequence_handler(\"drive_session_01\")\n    extractor = DataFrameExtractor(seq_handler)\n\n    # Process sequential chunks while maintaining signal continuity\n    for sparse_chunk in extractor.to_pandas_chunks(window_sec=5.0):\n        # The transformer automatically carries state across sequential calls\n        normalized_dense_chunk = pipeline.transform(sparse_chunk)\n</code></pre>"},{"location":"SDK/bridges/ros/","title":"ROS","text":"<p>The ROS Bridge module serves as the ingestion gateway for ROS (Robot Operating System) data into the Mosaico Data Platform. Its primary function is to solve the interoperability challenges associated with ROS bag files\u2014specifically format fragmentation (ROS 1 <code>.bag</code> vs. ROS 2 <code>.mcap</code>/<code>.db3</code>) and the lack of strict schema enforcement in custom message definitions.</p> <p>The core philosophy of the module is \"Adaptation, Not Just Parsing.\" Rather than simply extracting raw dictionaries from ROS messages, the bridge actively translates them into the standardized Mosaico Ontology. For example, a <code>geometry_msgs/Pose</code> is validated, normalized, and instantiated as a strongly-typed <code>mosaicolabs.models.data.Pose</code> object before ingestion.</p>"},{"location":"SDK/bridges/ros/#architecture","title":"Architecture","text":"<p>The module is composed of four distinct layers that handle the pipeline from raw file access to server transmission.</p>"},{"location":"SDK/bridges/ros/#the-loader-layer-rosloader","title":"The Loader Layer (<code>ROSLoader</code>)","text":"<p>The <code>ROSLoader</code> acts as the abstraction layer over the physical bag files. It utilizes the <code>rosbags</code> library to provide a unified interface for reading both ROS 1 and ROS 2 formats (<code>.bag</code>, <code>.db3</code>, <code>.mcap</code>).</p> <ul> <li>Responsibilities: File I/O, raw deserialization, and topic filtering (supporting glob patterns like <code>/cam/*</code>).</li> <li>Error Handling: It implements configurable policies (<code>IGNORE</code>, <code>LOG_WARN</code>, <code>RAISE</code>) to handle corrupted messages or deserialization failures without crashing the entire pipeline.</li> </ul>"},{"location":"SDK/bridges/ros/#the-adaptation-layer-rosbridge-adapters","title":"The Adaptation Layer (<code>ROSBridge</code> &amp; Adapters)","text":"<p>This layer represents the semantic core of the module, translating raw ROS data into the Mosaico Ontology.</p> <ul> <li><code>ROSAdapterBase</code>: An abstract base class that establishes the contract for converting specific ROS message types into their corresponding Mosaico Ontology types.</li> <li>Concrete Adapters: The library provides built-in implementations for common standards, such as <code>IMUAdapter</code> (mapping <code>sensor_msgs/Imu</code> to <code>IMU</code>) and <code>ImageAdapter</code> (mapping <code>sensor_msgs/Image</code> to <code>Image</code>). These adapters include advanced logic for recursive unwrapping, automatically extracting data from complex nested wrappers like <code>PoseWithCovarianceStamped</code>. Developers can also implement custom adapters to handle non-standard or proprietary types.</li> <li><code>ROSBridge</code>: A central registry and dispatch mechanism that maps ROS message type strings (e.g., <code>sensor_msgs/msg/Imu</code>) to their corresponding adapter classes, ensuring the correct translation logic is applied for each message.</li> </ul>"},{"location":"SDK/bridges/ros/#extending-the-bridge-custom-adapters","title":"Extending the Bridge (Custom Adapters)","text":"<p>Users can extend the bridge to support new ROS message types by implementing a custom adapter and registering it.</p> <ol> <li>Inherit from <code>ROSAdapterBase</code>: Define the input ROS type string and the target Mosaico Ontology type.</li> <li>Implement <code>from_dict</code>: Define the logic to convert the <code>ROSMessage.data</code> dictionary into an intance of the target ontology object.</li> <li>Register: Decorate the class with <code>@register_adapter</code>.</li> </ol> <pre><code>from mosaicolabs.ros_bridge import ROSAdapterBase, register_adapter, ROSMessage\nfrom mosaicolabs.models import Message\nfrom my_ontology import MyCustomData # Assuming this class exists\n\n@register_adapter\nclass MyCustomAdapter(ROSAdapterBase[MyCustomData]):\n    ros_msgtype = \"my_pkg/msg/MyCustomType\"\n    __mosaico_ontology_type__ = MyCustomData\n\n    @classmethod\n    def from_dict(cls, ros_data: dict) -&gt; MyCustomData:\n        # Transformation logic here\n        return MyCustomData(...)\n</code></pre>"},{"location":"SDK/bridges/ros/#the-orchestrator-rosbaginjector","title":"The Orchestrator (<code>RosbagInjector</code>)","text":"<p>The <code>RosbagInjector</code> is the central command center of the ROS Bridge module. It is designed to be the primary entry point for developers who want to embed high-performance ROS ingestion directly into their Python applications or automation scripts.</p> <p>The injector acts as a \"glue\" layer, orchestrating the interaction between the <code>ROSLoader</code> (file access), the <code>ROSBridge</code> (data adaptation), and the <code>MosaicoClient</code> (network transmission). It handles the complex lifecycle of a data upload\u2014including connection management, batching, and transaction safety\u2014while providing real-time feedback through a visual CLI interface.</p>"},{"location":"SDK/bridges/ros/#core-workflow-execution-run","title":"Core Workflow Execution: <code>run()</code>","text":"<p>The <code>run()</code> method is the heart of the injector. When called, it initiates a multi-phase pipeline:</p> <ol> <li>Handshake &amp; Registry: Establishes a connection to the Mosaico server and registers any provided custom <code>.msg</code> definitions into the global <code>ROSTypeRegistry</code>.</li> <li>Sequence Creation: Requests the server to initialize a new data sequence based on the provided name and metadata.</li> <li>Adaptive Streaming: Iterates through the ROS bag records. For each message, it identifies the correct adapter, translates the ROS dictionary into a Mosaico object, and pushes it into an optimized asynchronous write buffer.</li> <li>Transaction Finalization: Once the bag is exhausted, it flushes all remaining buffers and signals the server to commit the sequence.</li> </ol>"},{"location":"SDK/bridges/ros/#the-blueprint-rosinjectionconfig","title":"The Blueprint: <code>ROSInjectionConfig</code>","text":"<p>The behavior of the injector is entirely driven by the <code>ROSInjectionConfig</code>. This configuration object ensures that the ingestion logic is decoupled from the user interface, allowing for consistent behavior whether triggered via the CLI or a complex script.</p> Attribute Type Description <code>file_path</code> <code>Path</code> The location of the source ROS bag (<code>.mcap</code>, <code>.db3</code>, or <code>.bag</code>). <code>sequence_name</code> <code>str</code> The unique identifier for the sequence on the server. <code>metadata</code> <code>dict</code> Searchable tags and context (e.g., <code>{\"weather\": \"rainy\"}</code>) attached to the sequence. <code>ros_distro</code> <code>Stores</code> Crucial for <code>.db3</code> bags: Specifies the ROS distribution (e.g., <code>ROS2_HUMBLE</code>) to ensure standard messages are parsed with the correct schema version. <code>topics</code> <code>List[str]</code> A filter list supporting glob patterns (e.g., <code>[\"/camera/*\"]</code>). If omitted, all supported topics are ingested. <code>custom_msgs</code> <code>List</code> A list of tuples <code>(package, path, store)</code> used to dynamically register proprietary message definitions at runtime. <code>on_error</code> <code>OnErrorPolicy</code> Safety Switch: Determines if a failed upload should <code>Delete</code> the partial sequence or <code>Report</code> the error and keep the data. <code>log_level</code> <code>str</code> Controls terminal verbosity, ranging from <code>DEBUG</code> to <code>ERROR</code>."},{"location":"SDK/bridges/ros/#practical-example-programmatic-usage","title":"Practical Example: Programmatic Usage","text":"<pre><code>from pathlib import Path\nfrom mosaicolabs.ros_bridge import RosbagInjector, ROSInjectionConfig, Stores\n\ndef run_injection():\n    # Define the Injection Configuration\n    # This data class acts as the single source for the operation.\n    config = ROSInjectionConfig(\n        # Input Data\n        file_path=Path(\"data/session_01.db3\"),\n\n        # Target Platform Metadata\n        sequence_name=\"test_ros_sequence\",\n        metadata={\n            \"driver_version\": \"v2.1\", \n            \"weather\": \"sunny\",\n            \"location\": \"test_track_A\"\n        },\n\n        # Topic Filtering (supports glob patterns)\n        # This will only upload topics starting with '/cam'\n        topics=[\"/cam*\"],\n\n        # ROS Configuration\n        # Specifying the distro ensures correct parsing of standard messages\n        # (.db3 sqlite3 rosbags need the specification of distro)\n        ros_distro=Stores.ROS2_HUMBLE,\n\n        # Custom Message Registration\n        # Register proprietary messages before loading to prevent errors\n        custom_msgs=[\n            (\n                \"my_custom_pkg\",                 # ROS Package Name\n                Path(\"./definitions/my_pkg/\"),   # Path to directory containing .msg files\n                Stores.ROS2_HUMBLE,              # Scope (valid for this distro)\n            ) # registry will automatically infer type names as `my_custom_pkg/msg/{filename}`\n        ],\n\n        # Execution Settings\n        log_level=\"WARNING\",  # Reduce verbosity for automated scripts\n    )\n\n    # Instantiate the Controller\n    injector = RosbagInjector(config)\n\n    # Execute\n    # The run method handles connection, loading, and uploading automatically.\n    # It raises exceptions for fatal errors, allowing you to wrap it in try/except blocks.\n    try:\n        injector.run()\n        print(\"Injection job completed successfully.\")\n    except Exception as e:\n        print(f\"Injection job failed: {e}\")\n\n# Use as script or call the injection function in your code\nif __name__ == \"__main__\":\n    run_injection()\n</code></pre>"},{"location":"SDK/bridges/ros/#cli-usage","title":"CLI Usage","text":"<p>The module includes a command-line interface for quick ingestion tasks. The full list of options can be retrieved by running <code>mosaico.ros_injector -h</code></p> <pre><code># Basic Usage\npoetry run mosaico.ros_injector ./data.mcap --name \"Test_Run_01\"\n\n# Advanced Usage: Filtering topics and adding metadata\npoetry run mosaico.ros_injector ./data.db3 \\\n  --name \"Test_Run_01\" \\\n  --topics /camera/front/* /gps/fix \\\n  --metadata ./metadata.json \\\n  --ros-distro ros2_humble\n</code></pre>"},{"location":"SDK/bridges/ros/#the-type-registry-rostyperegistry","title":"The Type Registry (<code>ROSTypeRegistry</code>)","text":"<p>The <code>ROSTypeRegistry</code> is a context-aware singleton designed to manage the schemas required to decode ROS data. ROS message definitions are frequently external to the data files themselves\u2014this is especially true for ROS 2 <code>.db3</code> (SQLite) formats and proprietary datasets containing custom sensors. Without these definitions, the bridge cannot deserialize the raw binary \"blobs\" into readable dictionaries.</p> <ul> <li>Schema Resolution: It allows the <code>ROSLoader</code> to resolve custom <code>.msg</code> definitions on-the-fly during bag playback.</li> <li>Version Isolation (Stores): ROS messages often vary across distributions (e.g., a \"Header\" in ROS 1 Noetic is structurally different from ROS 2 Humble). The registry uses a \"Profile\" system to store these version-specific definitions separately, preventing cross-distribution conflicts.</li> <li>Global vs. Scoped Definitions: You can register definitions Globally (available to all loaders) or Scoped to a specific distribution.</li> </ul>"},{"location":"SDK/bridges/ros/#pre-loading-definitions","title":"Pre-loading Definitions","text":"<p>While you can pass custom messages via <code>ROSInjectionConfig</code>, it can become cumbersome for large-scale projects with hundreds of proprietary types. The recommended approach is to pre-load the registry at the start of your application. This makes the definitions available to all subsequent loaders automatically.</p> Method Scope Description <code>register(...)</code> Single Message Registers a single custom type. The source can be a path to a <code>.msg</code> file or a raw string containing the definition. <code>register_directory(...)</code> Batch Package Scans a directory for all <code>.msg</code> files and registers them under a specific package name (e.g., <code>my_pkg/msg/Sensor</code>). <code>get_types(...)</code> Internal Implements a \"Cascade\" logic: merges Global definitions with distribution-specific overrides for a loader. <code>reset()</code> Utility Clears all stored definitions. Primarily used for unit testing to ensure process isolation."},{"location":"SDK/bridges/ros/#centralized-registration-example","title":"Centralized Registration Example","text":"<p>A clean way to manage large projects is to centralize your message registration in a single setup function (e.g., <code>setup_registry.py</code>):</p> <pre><code>from pathlib import Path\nfrom mosaicolabs.ros_bridge import ROSTypeRegistry, Stores\n\ndef initialize_project_schemas():\n    # 1. Register a proprietary message valid for all ROS versions\n    ROSTypeRegistry.register(\n        msg_type=\"common_msgs/msg/SystemHeartbeat\",\n        source=Path(\"./definitions/Heartbeat.msg\")\n    )\n\n    # 2. Batch register an entire package for ROS 2 Humble\n    ROSTypeRegistry.register_directory(\n        package_name=\"robot_v3_msgs\",\n        dir_path=Path(\"./definitions/robot_v3/msgs\"),\n        store=Stores.ROS2_HUMBLE\n    )\n</code></pre> <p>Once registered, the <code>RosbagInjector</code> (and the underlying <code>ROSLoader</code>) automatically detects and uses these definitions. There is no longer the need to pass the <code>custom_msgs</code> list in the <code>ROSInjectionConfig</code>.</p> <pre><code># main_injection.py\nimport setup_registry  # Runs the registration logic above\nfrom mosaicolabs.ros_bridge import RosbagInjector, ROSInjectionConfig, Stores\nfrom pathlib import Path\n\n# Initialize registry\nsetup_registry.initialize_project_schemas()\n\n# Configure injection WITHOUT listing custom messages again\nconfig = ROSInjectionConfig(\n    file_path=Path(\"mission_data.mcap\"),\n    sequence_name=\"mission_01\",\n    metadata={\"operator\": \"Alice\"},\n    ros_distro=Stores.ROS2_HUMBLE,  # Loader will pull the Humble-specific types we registered\n    # custom_msgs=[]  &lt;-- No longer needed!\n)\n\ninjector = RosbagInjector(config)\ninjector.run()\n</code></pre>"},{"location":"SDK/bridges/ros/#testing-validation","title":"Testing &amp; Validation","text":"<p>The ROS Bag Injection module has been validated against a variety of standard datasets to ensure compatibility with different ROS distributions, message serialization formats (CDR/ROS 1), and bag container formats (<code>.bag</code>, <code>.mcap</code>, <code>.db3</code>).</p>"},{"location":"SDK/bridges/ros/#recommended-dataset-for-verification","title":"Recommended Dataset for Verification","text":"<p>For evaluating Mosaico capabilities, we recommend the NVIDIA NGC Catalog - R2B Dataset 2024. This dataset has been verified to be fully compatible with the injection pipeline.</p> <p>The following table details the injection performance for the NVIDIA R2B Dataset 2024. These benchmarks were captured on a system running macOS 26.2 with an Apple M2 Pro (10 cores, 16GB RAM).</p>"},{"location":"SDK/bridges/ros/#nvidia-r2b-dataset-2024-injection-performance","title":"NVIDIA R2B Dataset 2024 Injection Performance","text":"Sequence Name Compression Factor Injection Time Hardware Architecture Notes <code>r2b_galileo2</code> ~70% ~40 sec Apple M2 Pro (16GB) High compression achieved for telemetry data. <code>r2b_galileo</code> ~1% ~30 sec Apple M2 Pro (16GB) Low compression due to pre-compressed source images. <code>r2b_robotarm</code> ~66% ~50 sec Apple M2 Pro (16GB) High efficiency for high-frequency state updates. <code>r2b_whitetunnel</code> ~1% ~30 sec Apple M2 Pro (16GB) Low compression; contains topics with no available adapter."},{"location":"SDK/bridges/ros/#understanding-performance-factors","title":"Understanding Performance Factors","text":"<ul> <li>Compression Factors: Sequences like <code>r2b_galileo2</code> achieve high ratios (~70%) because Mosaico optimizes the underlying columnar storage for scalar telemetry. Conversely, sequences with pre-compressed video feeds show minimal gains (~1%) because the data is already in a dense format.</li> <li>Injection Time: This metric includes the overhead of local MCAP/DB3 deserialization via <code>ROSLoader</code>, semantic translation through the <code>ROSBridge</code>, and the asynchronous transmission to the Mosaico server.</li> <li>Hardware Impact: On the Apple M2 Pro, the <code>RosbagInjector</code> utilizes multi-threading for the Adaptation Layer, allowing serialization tasks to run in parallel while the main thread manages the Flight stream.</li> </ul>"},{"location":"SDK/bridges/ros/#known-issues-limitations","title":"Known Issues &amp; Limitations","text":"<p>While the underlying <code>rosbags</code> library supports the majority of standard ROS 2 bag files, specific datasets with non-standard serialization alignment or proprietary encodings may encounter compatibility issues.</p> <p>NVIDIA Isaac ROS Benchmark Dataset (2023)</p> <ul> <li>Source: NVIDIA NGC Catalog - R2B Dataset 2023</li> <li>Issue: Deserialization failure during ingestion.</li> <li>Technical Details: The ingestion process fails within the <code>AnyReader.deserialize</code> method of the <code>rosbags</code> library. The internal CDR deserializer triggers an assertion error indicating a mismatch in the expected data length vs. the raw payload size.</li> <li>Error Signature: <pre><code># In rosbags.serde.cdr:\nassert pos + 4 + 3 &gt;= len(rawdata)\n</code></pre></li> <li>Recommendation: This issue originates in the upstream parser handling of this specific dataset's serialization alignment. It is currently recommended to exclude this dataset or transcode it using standard ROS 2 tools before ingestion.</li> </ul>"},{"location":"SDK/bridges/ros/#supported-message-types","title":"Supported Message Types","text":"<p>ROS-Specific Data Models</p> <p>In addition to mapping standard ROS messages to the core Mosaico ontology, the <code>ros-bridge</code> module implements two specialized data models. These are defined specifically for this module to handle ROS-native concepts that are not yet part of the official Mosaico standard:</p> <ul> <li><code>FrameTransform</code>: Designed to handle coordinate frame transformations (modeled after <code>tf2_msgs/msg/TFMessage</code>). It encapsulates a list of <code>Transform</code> objects to manage spatial relationships.</li> <li><code>BatteryState</code>: Modeled after <code>sensor_msgs/msg/BatteryState</code>), this class captures comprehensive power supply metrics. It includes core data (voltage, current, capacity, percentage) and detailed metadata such as power supply health, technology status, and individual cell readings.</li> </ul> <p>Note: Although these are provisional additions, both <code>FrameTransform</code> and <code>BatteryState</code> inherit from <code>Serializable</code> and <code>HeaderMixin</code>. This ensures they remain fully compatible with Mosaico\u2019s existing serialization and header management infrastructure.</p>"},{"location":"SDK/bridges/ros/#supported-message-types-table","title":"Supported Message Types Table","text":"ROS Message Type Mosaico Ontology Type Adapter <code>geometry_msgs/Pose</code>, <code>PoseStamped</code>... <code>Pose</code> <code>PoseAdapter</code> <code>geometry_msgs/Twist</code>, <code>TwistStamped</code>... <code>Velocity</code> <code>TwistAdapter</code> <code>geometry_msgs/Accel</code>, <code>AccelStamped</code>... <code>Acceleration</code> <code>AccelAdapter</code> <code>geometry_msgs/Vector3</code>, <code>Vector3Stamped</code> <code>Vector3d</code> <code>Vector3Adapter</code> <code>geometry_msgs/Point</code>, <code>PointStamped</code> <code>Point3d</code> <code>PointAdapter</code> <code>geometry_msgs/Quaternion</code>, <code>QuaternionStamped</code> <code>Quaternion</code> <code>QuaternionAdapter</code> <code>geometry_msgs/Transform</code>, <code>TransformStamped</code> <code>Transform</code> <code>TransformAdapter</code> <code>geometry_msgs/Wrench</code>, <code>WrenchStamped</code> <code>ForceTorque</code> <code>WrenchAdapter</code> <code>nav_msgs/Odometry</code> <code>MotionState</code> <code>OdometryAdapter</code> <code>nmea_msgs/Sentence</code> <code>NMEASentence</code> <code>NMEASentenceAdapter</code> <code>sensor_msgs/Image</code>, <code>CompressedImage</code> <code>Image</code>, <code>CompressedImage</code> <code>ImageAdapter</code>, <code>CompressedImageAdapter</code> <code>sensor_msgs/Imu</code> <code>IMU</code> <code>IMUAdapter</code> <code>sensor_msgs/NavSatFix</code> <code>GPS</code>, <code>GPSStatus</code> <code>GPSAdapter</code>, <code>NavSatStatusAdapter</code> <code>sensor_msgs/CameraInfo</code> <code>CameraInfo</code> <code>CameraInfoAdapter</code> <code>sensor_msgs/RegionOfInterest</code> <code>ROI</code> <code>ROIAdapter</code> <code>sensor_msgs/JointState</code> <code>RobotJoint</code> <code>RobotJointAdapter</code> <code>sensor_msgs/BatteryState</code> <code>BatteryState</code> (ROS-specific) <code>BatteryStateAdapter</code> <code>std_msgs/msg/String</code> <code>String</code> <code>_GenericStdAdapter</code> <code>std_msgs/msg/Int8(16,32,64)</code> <code>Integer8(16,32,64)</code> <code>_GenericStdAdapter</code> <code>std_msgs/msg/UInt8(16,32,64)</code> <code>Unsigned8(16,32,64)</code> <code>_GenericStdAdapter</code> <code>std_msgs/msg/Float32(64)</code> <code>Floating32(64)</code> <code>_GenericStdAdapter</code> <code>std_msgs/msg/Bool</code> <code>Boolean</code> <code>_GenericStdAdapter</code> <code>tf2_msgs/msg/TFMessage</code> <code>FrameTransform</code> (ROS-specific) <code>FrameTransformAdapter</code>"},{"location":"SDK/handling/data-handling/","title":"Writing & Reading Data","text":"<p>The Data Handling module serves as the high-performance operational core of the Mosaico SDK, providing a unified interface for moving multi-modal sensor data between local applications and the Mosaico Data Platform. Engineered to solve the \"Big Data\" challenges of robotics and autonomous systems, this module abstracts the complexities of network I/O, asynchronous buffering, and high-precision temporal alignment.</p>"},{"location":"SDK/handling/data-handling/#asymmetric-architecture","title":"Asymmetric Architecture","text":"<p>The SDK employs a specialized architecture that separates concerns into Writers and Handlers, ensuring each layer is optimized for its unique traffic pattern:</p> <ul> <li>Ingestion (Writing): Designed for low-latency, high-throughput ingestion of 4K video, high-frequency IMU telemetry, and dense point clouds. It utilizes a \"Multi-Lane\" approach where each sensor stream operates in isolation with dedicated system resources.</li> <li>Discovery &amp; Retrieval (Reading): Architected to separate metadata-based resource discovery from high-volume data transmission. This separation allows developers to inspect sequence and topic catalogs\u2014querying metadata and temporal bounds\u2014before committing to a high-bandwidth data stream.</li> </ul>"},{"location":"SDK/handling/data-handling/#memory-efficient-data-flow","title":"Memory-Efficient Data Flow","text":"<p>The Mosaico SDK is engineered to handle massive data volumes without exhausting local system resources, enabling the processing of datasets that span terabytes while maintaining a minimal and predictable memory footprint.</p> <ul> <li>Smart Batching &amp; Buffering: Both reading and writing operations are executed in memory-limited batches rather than loading or sending entire sequences at once.</li> <li>Asynchronous Processing: The SDK offloads CPU-intensive tasks, such as image serialization and network I/O, to background threads within the <code>MosaicoClient</code>.</li> <li>Automated Lifecycle: In reading workflows, processed batches are automatically discarded and replaced with new data from the server. In writing workflows, buffers are automatically flushed based on configurable size or record limits.</li> <li>Stream Persistence: Integrated Error Policies allow developers to prioritize either a \"clean slate\" data state or \"recovery\" of partial data in the event of an application crash.</li> </ul>"},{"location":"SDK/handling/reading/","title":"The Reading Workflow","text":"<p>The Reading Workflow in Mosaico is architected to separate resource discovery from high-volume data transmission. This is achieved through two distinct layers: Handlers, which serve as metadata proxies, and Streamers, which act as the high-performance data engines.</p>"},{"location":"SDK/handling/reading/#handlers-the-catalog-layer","title":"Handlers: The Catalog Layer","text":"<p>Handlers are lightweight objects that represent a server-side resource. Their primary role is to provide immediate access to system information and user-defined metadata without downloading the actual sensor data. They act as the \"Catalog\" layer of the SDK, allowing you to inspect the contents of the platform before committing to a high-bandwidth data stream.</p> <p>Mosaico provides two specialized handler types: <code>SequenceHandler</code> and <code>TopicHandler</code>.</p>"},{"location":"SDK/handling/reading/#sequencehandler","title":"<code>SequenceHandler</code>","text":"<p>API Reference: <code>mosaicolabs.handlers.SequenceHandler</code>.</p> <p>Represents a complete recording session. It provides a holistic view, allowing you to inspect all available topic names, global sequence metadata, and the overall temporal bounds (earliest and latest timestamps) of the session.</p> <p>This example demonstrates how to use a Sequence handler to inspect metadata.</p> <pre><code>import sys\nfrom mosaicolabs import MosaicoClient\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Use a Handler to inspect the catalog\n    seq_handler = client.sequence_handler(\"mission_alpha\")\n    if seq_handler:     \n        print(f\"Sequence: {seq_handler.name}\")\n        print(f\"\\t| Topics: {seq_handler.topics}\")\n        print(f\"\\t| User metadata: {seq_handler.user_metadata}\")\n        print(f\"\\t| Timestamp span: {seq_handler.timestamp_ns_min} - {seq_handler.timestamp_ns_max}\")\n        print(f\"\\t| Created {seq_handler.sequence_info.created_datetime}\")\n        print(f\"\\t| Size (MB) {seq_handler.sequence_info.total_size_bytes/(1024*1024)}\")\n\n        # Once done, close the reading channel (recommended)\n        seq_handler.close()\n</code></pre>"},{"location":"SDK/handling/reading/#topichandler","title":"<code>TopicHandler</code>","text":"<p>API Reference: <code>mosaicolabs.handlers.TopicHandler</code>.</p> <p>Represents a specific data channel within a sequence (e.g., a single IMU or Camera). It provides granular system info, such as the specific ontology model used and the data volume of that individual stream.</p> <p>This example demonstrates how to use a Topic handler to inspect metadata.</p> <pre><code>import sys\nfrom mosaicolabs import MosaicoClient\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Use a Handler to inspect the catalog\n    top_handler = client.topic_handler(\"mission_alpha\", \"/front/imu\")\n    # Note that the same handler can be retrieve via the SequenceHandler of the parent sequence:\n    # seq_handler = client.sequence_handler(\"mission_alpha\")\n    # top_handler = seq_handler.get_topic_handler(\"/front/imu\")\n    if top_handler:\n        print(f\"Sequence:Topic: {top_handler.sequence_name}:{top_handler.name}\")\n        print(f\"\\t| User metadata: {top_handler.user_metadata}\")\n        print(f\"\\t| Timestamp span: {top_handler.timestamp_ns_min} - {top_handler.timestamp_ns_max}\")\n        print(f\"\\t| Created {top_handler.topic_info.created_datetime}\")\n        print(f\"\\t| Size (MB) {top_handler.topic_info.total_size_bytes/(1024*1024)}\")\n\n        # Once done, close the reading channel (recommended)\n        top_handler.close()\n</code></pre>"},{"location":"SDK/handling/reading/#streamers-the-data-engines","title":"Streamers: The Data Engines","text":"<p>Both handlers serve as factories; once you have identified the resource you need, the handler is used to spawn the appropriate Streamer to begin data consumption. Streamers are the active components that manage the physical data exchange between the server and your application. They handle the complexities of network buffering, batch management, and the de-serialization of raw bytes into Mosaico <code>Message</code> objects.</p>"},{"location":"SDK/handling/reading/#sequencedatastreamer-unified-replay","title":"<code>SequenceDataStreamer</code> (Unified Replay)","text":"<p>API Reference: <code>mosaicolabs.handlers.SequenceDataStreamer</code>.</p> <p>The <code>SequenceDataStreamer</code> is a unified engine designed specifically for sensor fusion and full-system replay. It allows you to consume multiple data streams as if they were a single, coherent timeline.</p> <p>To achieve this, the streamer employs the following technical mechanisms:</p> <ul> <li>K-Way Merge Sorting: The streamer monitors the timestamps across all requested topics simultaneously. On every iteration, it \"peeks\" at the next available message from each topic and yields the one with the lowest timestamp.</li> <li>Strict Chronological Order: This sorting ensures that messages are delivered in exact acquisition order, effectively normalizing topics that may operate at vastly different frequencies (e.g., high-rate IMU vs. low-rate GPS).</li> <li>Temporal Slicing: You can request a \"windowed\" extraction by specifying <code>start_timestamp_ns</code> and <code>end_timestamp_ns</code>. This is highly efficient as it avoids downloading the entire sequence, focusing only on the specific event or time range of interest.</li> <li>Smart Buffering: To maintain memory efficiency, the streamer retrieves data in memory-limited batches. As you iterate, processed batches are discarded and replaced with new data from the server, allowing you to stream sequences that exceed your available RAM.</li> </ul> <p>This example demonstrates how to initiate and use the Sequence data stream.</p> <pre><code>import sys\nfrom mosaicolabs import MosaicoClient \n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Use a Handler to inspect the catalog\n    seq_handler = client.sequence_handler(\"mission_alpha\")\n    if seq_handler:\n        # Start a Unified Stream (K-Way Merge) for multi-sensor replay\n        # We only want GPS and IMU data for this synchronized analysis\n        streamer = seq_handler.get_data_streamer(\n            topics=[\"/gps\", \"/imu\"], # Optionally filter topics\n            # Optionally set the time window to extract\n            start_timestamp_ns=1738508778000000000,\n            end_timestamp_ns=1738509618000000000\n        )\n\n        # Check the start message timestamp\n        print(f\"Recording starts at: {streamer.next_timestamp()}\")\n\n        for topic, msg in streamer:\n            # Processes GPS and IMU in perfect chronological order\n            print(f\"[{topic}] at {msg.timestamp_ns}: {type(msg.data).__name__}\")\n\n        # Once done, close the reading channel (recommended)\n        seq_handler.close()\n</code></pre>"},{"location":"SDK/handling/reading/#topicdatastreamer-targeted-access","title":"<code>TopicDataStreamer</code> (Targeted Access)","text":"<p>API Reference: <code>mosaicolabs.handlers.TopicDataStreamer</code>.</p> <p>The <code>TopicDataStreamer</code> provides a dedicated, high-throughput channel for interacting with a single data resource. By bypassing the complex synchronization logic required for merging multiple topics, it offers the lowest possible overhead for tasks requiring isolated data streams, such as training models on specific camera frames or IMU logs.</p> <p>To ensure efficiency, the streamer supports the following features:</p> <ul> <li>Temporal Slicing: Much like the <code>SequenceDataStreamer</code>, you can extract data in a time-windowed fashion by specifying <code>start_timestamp_ns</code> and <code>end_timestamp_ns</code>. This ensures that only the relevant portion of the stream is retrieved rather than the entire dataset.</li> <li>Smart Buffering: Data is not downloaded all at once; instead, the SDK retrieves information in memory-limited batches, substituting old data with new batches as you iterate to maintain a constant, minimal memory footprint.</li> </ul> <p>This example demonstrates how to initiate and use the Topic data stream.</p> <pre><code>import sys\nfrom mosaicolabs import MosaicoClient, IMU\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Retrieve the topic handler using (e.g.) MosaicoClient\n    top_handler = client.topic_handler(\"mission_alpha\", \"/front/imu\")\n    if top_handler:\n        # Start a Targeted Stream for single-sensor replay\n        imu_stream = top_handler.get_data_streamer(\n            # Optionally set the time window to extract\n            start_timestamp_ns=1738508778000000000,\n            end_timestamp_ns=1738509618000000000\n        )\n\n        # Peek at the start time\n        print(f\"Recording starts at: {streamer.next_timestamp()}\")\n\n        # Direct, low-overhead loop\n        for imu_msg in imu_stream:\n            process_sample(imu_msg.get_data(IMU)) # Some custom process function\n\n        # Once done, close the reading channel (recommended)\n        top_handler.close()\n</code></pre>"},{"location":"SDK/handling/writing/","title":"The Writing Workflow","text":"<p>The Writing Workflow in Mosaico is designed for high-throughput data ingestion, ensuring that your application remains responsive even when streaming high-bandwidth sensor data like 4K video or high-frequency IMU telemetry.</p> <p>The architecture is built around a \"Multi-Lane\" approach, where each sensor stream operates in its own isolated lane with dedicated system resources.</p>"},{"location":"SDK/handling/writing/#the-orchestrator-sequencewriter","title":"The Orchestrator: <code>SequenceWriter</code>","text":"<p>API Reference: <code>mosaicolabs.handlers.SequenceWriter</code>.</p> <p>The <code>SequenceWriter</code> acts as the central controller for a recording session. It manages the high-level lifecycle of the data on the server and serves as the factory for individual sensor streams.</p> <p>Key Roles:</p> <ul> <li>Lifecycle Management: It handles the lifecycle of a new sequence and ensures that it is either successfully committed as immutable data or, in the event of a failure, cleaned up according to your configured <code>OnErrorPolicy</code>.</li> <li>Resource Distribution: The writer pulls network connections from the Connection Pool and background threads from the Executor Pool, assigning them to individual topics. This isolation prevents a slow network connection on one topic from bottlenecking others.</li> <li>Context Safety: To ensure data integrity, the <code>SequenceWriter</code> must be used within a Python <code>with</code> block. This guarantees that all buffers are flushed and the sequence is closed properly, even if your application crashes.</li> </ul> <pre><code>from mosaicolabs import MosaicoClient, OnErrorPolicy\n\n# Open the connection with the Mosaico Client\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Start the Sequence Orchestrator\n    with client.sequence_create(\n        sequence_name=\"mission_log_042\", \n        # Custom metadata for this data sequence.\n        metadata={ # (1)!\n            \"vehicle\": {\n                \"vehicle_id\": \"veh_sim_042\",\n                \"powertrain\": \"EV\",\n                \"sensor_rig_version\": \"v3.2.1\",\n                \"software_stack\": {\n                    \"perception\": \"perception-5.14.0\",\n                    \"localization\": \"loc-2.9.3\",\n                    \"planning\": \"plan-4.1.7\",\n                },\n            },\n            \"driver\": {\n                \"driver_id\": \"drv_sim_017\",\n                \"role\": \"validation\",\n                \"experience_level\": \"senior\",\n            },\n        }\n        on_error = OnErrorPolicy.Delete # Default\n        ) as seq_writer:\n\n        # `seq_writer` is the writing handler of the new 'mission_log_042' sequence\n        # Data will be uploaded by spawning topic writers that will manage the actual data stream \n        # remote push... See below.\n</code></pre> <ol> <li>The metadata fields will be queryable via the <code>Query</code> mechanism. The mechanism allows creating queries like: <code>Sequence.Q.user_metadata[\"vehicle.software_stack.planning\"].match(\"plan-4.\")</code></li> </ol>"},{"location":"SDK/handling/writing/#the-data-engine-topicwriter","title":"The Data Engine: <code>TopicWriter</code>","text":"<p>API Reference: <code>mosaicolabs.handlers.TopicWriter</code>.</p> <p>Once a topic is created, a <code>TopicWriter</code> is spawned to handle the actual transmission of data for that specific stream. It abstracts the underlying networking protocols, allowing you to simply \"push\" Python objects while it handles the heavy lifting.</p> <p>Key Roles:</p> <ul> <li>Smart Buffering: Instead of sending every single message over the network\u2014which would be highly inefficient\u2014the <code>TopicWriter</code> accumulates records in a memory buffer.</li> <li>Automated Flushing: The writer automatically triggers a \"flush\" to the server whenever the internal buffer exceeds your configured limits, such as a maximum byte size or a specific number of records.</li> <li>Asynchronous Serialization: For CPU-intensive data (like encoding images), the writer can offload the serialization process to background threads, ensuring your main application loop stays fast.</li> </ul> <pre><code># Continues from the code above...\n\n    # \ud83d\udc49 with client.sequence_create(...) as seq_writer:\n        # Create individual Topic Writers\n        # Each writer gets its own assigned resources from the pools\n        imu_writer = seq_writer.topic_create(\n            topic_name=\"sensors/imu\", # The univocal topic name\n            metadata={ # The topic/sensor custom metadata\n                \"vendor\": \"inertix-dynamics\",\n                \"model\": \"ixd-f100\",\n                \"firmware_version\": \"1.2.0\",\n                \"serial_number\": \"IMUF-9A31D72X\",\n                \"calibrated\":\"false\",\n            },\n            ontology_type=IMU, # The ontology type stored in this topic\n        )\n\n        # Another individual topic writer for the GPS device\n        gps_writer = seq_writer.topic_create(\n            topic_name=\"sensors/gps\", # The univocal topic name\n            metadata={ # The topic/sensor custom metadata\n                \"role\": \"primary_gps\",\n                \"vendor\": \"satnavics\",\n                \"model\": \"snx-g500\",\n                \"firmware_version\": \"3.2.0\",\n                \"serial_number\": \"GPS-7C1F4A9B\",            \n                \"interface\": { # (1)!\n                    \"type\": \"UART\",\n                    \"baudrate\": 115200,\n                    \"protocol\": \"NMEA\",\n                },\n            }, # The topic/sensor custom metadata\n            ontology_type=GPS, # The ontology type stored in this topic\n        )\n\n        # Push data - The SDK handles batching and background I/O\n        imu_writer.push(\n            message=Message(\n                timestamp_ns=1700000000000, \n                data=IMU(acceleration=Vector3d(x=0, y=0, z=9.81), ...),\n            )\n        )\n\n        gps_writer.push(\n            message=Message(\n                timestamp_ns=1700000000100, \n                data=GPS(position=Vector3d(x=44.0123,y=10.12345,z=0), ...),\n            )\n        )\n\n# Exiting the block automatically flushes all topic buffers, finalizes the sequence on the server \n# and closes all connections and pools\n</code></pre> <ol> <li>The metadata fields will be queryable via the <code>Query</code> mechanism. The mechanism allows creating query expressions like: <code>Topic.Q.user_metadata[\"interface.type\"].eq(\"UART\")</code>.     API Reference:<ul> <li><code>mosaicolabs.models.platform.Topic</code></li> <li><code>mosaicolabs.models.query.builders.QueryTopic</code>.</li> </ul> </li> </ol>"},{"location":"SDK/handling/writing/#resilient-data-ingestion-error-management","title":"Resilient Data Ingestion &amp; Error Management","text":"<p>Recording high-bandwidth sensor data in dynamic environments requires a tiered approach to error handling. While the Mosaico SDK provides automated recovery through Error Policies, these act as a \"last line of defense\". For robust production pipelines, you must implement Defensive Ingestion Patterns to prevent isolated failures from compromising your entire recording session.</p>"},{"location":"SDK/handling/writing/#sequence-level-error-handling","title":"Sequence-Level Error Handling","text":"<p>API Reference: <code>mosaicolabs.enum.OnErrorPolicy</code>.</p> <p>Configured when instantiating a new <code>SequenceWriter</code> via <code>MosaicoClient.connect()</code> factory, these policies dictate how the server handles a sequence if an unhandled exception bubbles up to the <code>SequenceWriter</code> context manager.</p>"},{"location":"SDK/handling/writing/#1-onerrorpolicydelete-the-clean-slate-policy","title":"1. <code>OnErrorPolicy.Delete</code> (The \"Clean Slate\" Policy)","text":"<ul> <li>Behavior: If an error occurs, the SDK sends an <code>ABORT</code> signal to the server.</li> <li>Result: The server immediately deletes the entire sequence and all associated topic data.</li> <li>Best For: CI/CD pipelines, unit testing, or \"Gold Dataset\" generation where partial or corrupted logs are unacceptable.</li> </ul>"},{"location":"SDK/handling/writing/#2-onerrorpolicyreport-the-recovery-policy","title":"2. <code>OnErrorPolicy.Report</code> (The \"Recovery\" Policy)","text":"<ul> <li>Behavior: The SDK finalizes data that successfully reached the server and sends a <code>NOTIFY_CREATE</code> signal with error details.</li> <li>Result: The sequence is preserved but remains in an unlocked (pending) state, allowing for forensic analysis.</li> <li>Best For: Field tests and mission-critical logs where lead-up data is essential for debugging.</li> </ul> <p>An example schematic rationale for deciding between the two policies can be:</p> Scenario Recommended Policy Rationale Edge/Field Tests <code>OnErrorPolicy.Report</code> Forensic value: \"Partial data is better than no data\" for crash analysis. Automated CI/CD <code>OnErrorPolicy.Delete</code> Platform hygiene: Prevents cluttering the catalog with junk data from failed runs. Ground Truth Generation <code>OnErrorPolicy.Delete</code> Integrity: Ensures only 100% verified, complete sequences enter the database."},{"location":"SDK/handling/writing/#topic-level-error-handling","title":"Topic-Level Error Handling","text":"<p>Because the <code>SequenceWriter</code> cannot natively distinguish which specific topic failed within your injection script or custom processing code (such as a coordinate transformations), an unhandled exception will bubble up and trigger the global sequence-level error policy. To avoid this, you should catch errors locally for each topic. It is highly recommended to wrap the topic-specific processing and pushing logic within a local <code>try-except</code> block, if a single failure is accepted and the entire sequence can still be accepted with partial data on failing topics. As an example, see the How-Tos</p> <p>Upcoming versions of the SDK will introduce native Topic-Level Error Policies, which will allow the user to define the error behavior directly when creating the topic, removing the need for boilerplate <code>try-except</code> blocks around every sensor stream.</p>"},{"location":"SDK/howto/interleaved_writing_from_multi_topics/","title":"Writing Interleaved Topics","text":"<p>This guide demonstrates how to ingest data from multiple topics stored within a single file container (such as an MCAP or a specialized binary log) into the Mosaico Data Platform. Unlike serial ingestion where files are processed one by one, interleaved ingestion handles a stream of messages from different sensors\u2014such as IMU, GPS, and Pressure\u2014as they appear in the source file.</p> <p>For this guide, we use the MCAP library as an example to briefly show how to parse a high-performance robotics container and stream its contents into Mosaico.</p> <p>You will learn how to:</p> <ul> <li>Orchestrate a single sequence for a multi-sensor stream.</li> <li>Dynamically resolve Topic Writers using the local SDK cache.</li> <li>Implement a Custom Translator to map external schemas to the Mosaico Ontology.</li> <li>Isolate failures to a single sensor stream using Defensive Ingestion patterns.</li> </ul>"},{"location":"SDK/howto/interleaved_writing_from_multi_topics/#the-multi-topic-streaming-architecture","title":"The Multi-Topic Streaming Architecture","text":"<p>In a mixed ingestion scenario, the source file provides a serialized stream of records. Each record contains a topic name, a timestamp, and a data payload associated with a specific schema.</p> Topic Schema Example (MCAP) Mosaico Target Model <code>/robot/imu</code> <code>sensor_msgs/msg/Imu</code> <code>IMU</code> <code>/robot/gps</code> <code>sensor_msgs/msg/NavSatFix</code> <code>GPS</code> <code>/env/pressure</code> <code>sensor_msgs/msg/FluidPressure</code> <code>Pressure</code> <p>As the reader iterates through the file, Mosaico dynamically assigns each record to its corresponding \"lane\" (Topic Writer).</p>"},{"location":"SDK/howto/interleaved_writing_from_multi_topics/#step-1-implementing-the-custom-translator-and-adapters","title":"Step 1: Implementing the Custom Translator and Adapters","text":"<p>Because source files often use external data formats (like ROS, Protobuf, or JSON), you need a translation layer to map these raw payloads into strongly-typed Mosaico objects.</p> Map incoming data schemas to Mosaico Ontology models.<pre><code>from mosaicolabs.models import (IMU, \n                                GPS, \n                                Pressure, \n                                Vector3d, \n                                GPSStatus, \n                                Time, \n                                Serializable)\n\ndef custom_translator(schema_name: str, payload: dict):\n    if schema_name == \"sensor_msgs/msg/Imu\":\n        header = payload['header']\n        timestamp_ns = Time(\n            sec=header['stamp']['sec'], \n            nanosec=header['stamp']['nanosec']\n        ).to_nanoseconds()\n        return Message(\n            timestamp_ns=timestamp_ns,\n            data=IMU(\n                acceleration=Vector3d(**payload['linear_acceleration']),\n                angular_velocity=Vector3d(**payload['angular_velocity'])\n            )\n        )\n\n    if schema_name == \"sensor_msgs/msg/NavSatFix\":\n        header = payload['header']\n        timestamp_ns = Time(\n            sec=header['stamp']['sec'], \n            nanosec=header['stamp']['nanosec']\n        ).to_nanoseconds()\n        return Message(\n            timestamp_ns=timestamp_ns,\n            data=GPS(\n                position=Vector3d(\n                    x=payload['latitude'], \n                    y=payload['longitude'], \n                    z=payload['altitude']\n                ),\n                status=GPSStatus(\n                    status=payload['status']['status'], \n                    service=payload['status']['service']\n                )\n            )\n        )\n\n    if schema_name == \"sensor_msgs/msg/FluidPressure\":\n        header = payload['header']\n        timestamp_ns = Time(\n            sec=header['stamp']['sec'], \n            nanosec=header['stamp']['nanosec']\n        ).to_nanoseconds()\n        return Message(\n            timestamp_ns=timestamp_ns,\n            data=Pressure(value=payload['fluid_pressure'])\n        )\n\n    return None\n\n\ndef determine_mosaico_type(schema_name: str) -&gt; Optional[Type[\"Serializable\"]]:\n    \"\"\"Determine the Mosaico type of the topic based on the schema name.\"\"\"\n    if schema_name == \"sensor_msgs/msg/Imu\":\n        return IMU\n    elif schema_name == \"sensor_msgs/msg/NavSatFix\":\n        return GPS\n    elif schema_name == \"sensor_msgs/msg/FluidPressure\":\n        return Pressure\n\n    return None\n</code></pre>"},{"location":"SDK/howto/interleaved_writing_from_multi_topics/#understanding-the-output","title":"Understanding the Output","text":"<p>The Mosaico <code>Message</code> object is an in-memory object wrapping the sensor data with necessary metadata (e.g. timestamp), and ensuring it is ready for serialization and network transmission.</p> <p>In this specific case, the data are instances of the <code>IMU</code>, <code>GPS</code> and <code>Pressure</code> models. These are built-in parts of the Mosaico default ontology, meaning the platform already understands their schema and how to optimize their storage.</p> <p>For a more in-depth explanation:</p> <ul> <li>Documentation: Data Models &amp; Ontology</li> <li>API Reference: Sensor Models</li> </ul>"},{"location":"SDK/howto/interleaved_writing_from_multi_topics/#step-2-orchestrating-the-multi-topic-interleaved-ingestion","title":"Step 2: Orchestrating the Multi-Topic Interleaved Ingestion","text":"<p>To write data, we first establish a connection to the Mosaico server via the <code>MosaicoClient.connect()</code> method and create a <code>SequenceWriter</code>. A sequence writer acts as a logical container for related sensor data streams (topics).</p> <p>When initializing your data handling pipeline, it is highly recommended to wrap the Mosaico Client within a <code>with</code> statement. This context manager pattern ensures that underlying network connections and shared resource pools are correctly shut down and released when your operations conclude.</p> Connect to the Mosaico server and create a sequence writer<pre><code>from mcap.reader import make_reader\nfrom mosaicolabs import MosaicoClient, OnErrorPolicy, Message\n\nwith open(\"mission_data.mcap\", \"rb\") as f:\n    reader = make_reader(f)\n    with MosaicoClient.connect(\"localhost\", 6726) as client:\n        with client.sequence_create(\n            sequence_name=\"multi_sensor_ingestion\",\n            metadata={\"mission\": \"alpha_test\", \"environment\": \"laboratory\"},\n            on_error=OnErrorPolicy.Delete # (1)!\n        ) as swriter:\n            # Steps 3 and 4 (Topic Creation &amp; Pushing) happen here...\n</code></pre> <ol> <li>Mosaico supports two distinct error policies for sequences: <code>OnErrorPolicy.Delete</code> and <code>OnErrorPolicy.Report</code>.</li> </ol> <p>Context Management</p> <p>It is mandatory to use the <code>SequenceWriter</code> instance returned by <code>client.sequence_create()</code> inside its own <code>with</code> context. The following code will raise an exception:</p> <p><pre><code>swriter = client.sequence_create(\n    sequence_name=\"multi_sensor_ingestion\",\n    metadata={...},\n) \n# Performing operations using `swriter` will raise an exception\nswriter.topic_create(...) # Raises here\n</code></pre> This choice ensures that the sequence writing orchestrator is closed and cataloged when the block is exited, even if your application encounters a crash or is manually interrupted.</p>"},{"location":"SDK/howto/interleaved_writing_from_multi_topics/#sequence-level-error-handling","title":"Sequence-Level Error Handling","text":"<p>The behavior of the orchestrator during a failure is governed by the <code>on_error</code> policy. This is a Last-Resort automated error policy, which dictates how the server manages a sequence if an unhandled exception bubbles up to the <code>SequenceWriter</code> context manager. By default, this is set to <code>OnErrorPolicy.Delete</code>, which signals the server to physically remove the incomplete sequence and its associated topic directories, if any errors occurred. Alternatively, you can specify <code>OnErrorPolicy.Report</code>: in this case, the SDK will not delete the data but will instead send an error notification to the server, allowing the platform to flag the sequence as failed while retaining whatever records were successfully transmitted before the error occurred.</p> <p>For a more in-depth explanation:</p> <ul> <li>Documentation: The Writing Workflow</li> <li>API Reference: Writing Data</li> </ul>"},{"location":"SDK/howto/interleaved_writing_from_multi_topics/#step-3-topic-creation-and-resource-allocation","title":"Step 3: Topic Creation and Resource Allocation","text":"<p>Inside the sequence, we can stream interleaved data without loading the entire file into memory. We automatically create individual Topic Writers per each channel in the MCAP file to manage data streams. Each writer is an independent \"lane\" assigned its own internal buffer and background thread for serialization. The <code>swriter.get_topic_writer</code> pattern removes the need to pre-scan the file. Topics are created only when they are first encountered.</p> <pre><code>with client.sequence_create(...) as swriter:\n    # Iterate through all interleaved messages\n    for schema, channel, message in reader.iter_messages():\n        # 1. Resolve Topic Writer using the SDK cache\n        twriter = swriter.get_topic_writer(channel.topic) # (1)!\n\n        if twriter is None:\n            ontology_type = determine_mosaico_type(schema.name)\n            if ontology_type is None:\n                print(f\"Skipping message on {channel.topic} due to unknown ontology type\")\n                # Skip the topic if no ontology type is found\n                continue\n\n            # Dynamically register the topic writer upon discovery\n            twriter = swriter.topic_create( # (2)!\n                topic_name=channel.topic,\n                metadata={},\n                ontology_type=ontology_type\n            )\n</code></pre> <ol> <li>Here we are checking if the a <code>TopicWriter</code> for the current topic already exists.</li> <li>Here we are creating the topic writer for the current topic, if it doesn't exist yet.</li> </ol>"},{"location":"SDK/howto/interleaved_writing_from_multi_topics/#step-4-pushing-data-into-the-pipeline","title":"Step 4: Pushing Data into the Pipeline","text":"<p>The final stage of the ingestion process involves iterating through your data generators and transmitting records to the Mosaico platform by calling the <code>TopicWriter.push()</code> method for each record. The <code>push()</code> method optimizes the throughput by accumulating messages into internal batches.</p> <pre><code>        try:\n            # In a real scenario, use a deserializer like mcap_ros2.decoder\n            raw_data = deserialize_payload(message.data, schema.name) # (1)!\n            mosaico_msg = custom_translator(schema.name, raw_data)\n\n            if mosaico_msg is None:\n                # Log and skip, or raise if incomplete data is disallowed\n                print(\"Skipping row due to parsing error\")\n                continue # Ignore malformed records\n\n            twriter.push(message=mosaico_msg)\n        except Exception as e:\n            print(f\"Skip error on {channel.topic} at {message.log_time}: {e}\")\n</code></pre> <ol> <li>This is an example of a custom function that deserializes the payload of the current message.</li> </ol>"},{"location":"SDK/howto/interleaved_writing_from_multi_topics/#topic-level-error-management","title":"Topic-Level Error Management","text":"<p>In the code snippet above, we implemented a Controlled Ingestion by wrapping the topic-specific processing and pushing logic within a local <code>try-except</code> block. Because the <code>SequenceWriter</code> cannot natively distinguish which specific topic failed within your custom processing code (such as a coordinate transformation), an unhandled exception will bubble up and trigger the global sequence-level error policy. To avoid this, you should catch errors locally for each topic.</p> <p>Upcoming versions of the SDK will introduce native Topic-Level Error Policies. This feature will allow you to define the error behavior directly when creating the topic, removing the need for boilerplate <code>try-except</code> blocks around every sensor stream.</p>"},{"location":"SDK/howto/interleaved_writing_from_multi_topics/#the-full-example-code","title":"The full example code","text":"<pre><code>\"\"\"\nImport the necessary classes from the Mosaico SDK.\n\"\"\"\nfrom mcap.reader import make_reader\n\nfrom mosaicolabs import (\n    MosaicoClient, # The gateway to the Mosaico Platform\n    OnErrorPolicy, # The error policy for the SequenceWriter\n    Message, # The base class for all data messages\n    IMU, # The IMU sensor data class\n    Vector3d, # The 3D vector class, needed to populate the IMU and GPS data\n    GPS, # The GPS sensor data class\n    GPSStatus, # The GPS status enum, needed to populate the GPS data\n    Pressure, # The Pressure sensor data class\n)\n\n\"\"\"\nDefine the generator functions that yield `Message` objects.\nFor each schema, we define a function that translates the payload\nof the current message into a `Message` object.\n\"\"\"\ndef custom_translator(schema_name: str, payload: dict):\n    if schema_name == \"sensor_msgs/msg/Imu\":\n        header = payload['header']\n        timestamp_ns = Time(\n            sec=header['stamp']['sec'], \n            nanosec=header['stamp']['nanosec']\n        ).to_nanoseconds()\n        return Message(\n            timestamp_ns=timestamp_ns,\n            data=IMU(\n                acceleration=Vector3d(**payload['linear_acceleration']),\n                angular_velocity=Vector3d(**payload['angular_velocity'])\n            )\n        )\n\n    if schema_name == \"sensor_msgs/msg/NavSatFix\":\n        header = payload['header']\n        timestamp_ns = Time(\n            sec=header['stamp']['sec'], \n            nanosec=header['stamp']['nanosec']\n        ).to_nanoseconds()\n        return Message(\n            timestamp_ns=timestamp_ns,\n            data=GPS(\n                position=Vector3d(\n                    x=payload['latitude'], \n                    y=payload['longitude'], \n                    z=payload['altitude']\n                ),\n                status=GPSStatus(\n                    status=payload['status']['status'], \n                    service=payload['status']['service']\n                )\n            )\n        )\n\n    if schema_name == \"sensor_msgs/msg/FluidPressure\":\n        header = payload['header']\n        timestamp_ns = Time(\n            sec=header['stamp']['sec'], \n            nanosec=header['stamp']['nanosec']\n        ).to_nanoseconds()\n        return Message(\n            timestamp_ns=timestamp_ns,\n            data=Pressure(value=payload['fluid_pressure'])\n        )\n\n    return None\n\n\ndef determine_mosaico_type(schema_name: str) -&gt; Optional[Type[\"Serializable\"]]:\n    \"\"\"Determine the Mosaico type of the topic based on the schema name.\"\"\"\n    if schema_name == \"sensor_msgs/msg/Imu\":\n        return IMU\n    elif schema_name == \"sensor_msgs/msg/NavSatFix\":\n        return GPS\n    elif schema_name == \"sensor_msgs/msg/FluidPressure\":\n        return Pressure\n    return None\n\n\"\"\"\nMain ingestion orchestration\n\"\"\"\ndef main():\n    with open(\"mission_data.mcap\", \"rb\") as f:\n        reader = make_reader(f)\n        with MosaicoClient.connect(\"localhost\", 6726) as client:\n            with client.sequence_create(\n                sequence_name=\"multi_sensor_ingestion\",\n                metadata={\"mission\": \"alpha_test\", \"environment\": \"laboratory\"},\n                on_error=OnErrorPolicy.Delete\n            ) as swriter:\n                # Iterate through all interleaved messages\n                for schema, channel, message in reader.iter_messages():\n                    # 1. Resolve Topic Writer using the SDK cache\n                    twriter = swriter.get_topic_writer(channel.topic)\n\n                    if twriter is None:\n                        ontology_type = determine_mosaico_type(schema.name)\n                        if ontology_type is None:\n                            print(f\"Skipping message on {channel.topic} due to unknown ontology type\")\n                            # Skip the topic if no ontology type is found\n                            continue\n\n                        # Dynamically register the topic writer upon discovery\n                        twriter = swriter.topic_create(\n                            topic_name=channel.topic,\n                            metadata={},\n                            ontology_type=ontology_type\n                        )\n\n                    # 2. Defensive Ingestion: Isolate errors to this specific record\n                    try:\n                        # In a real scenario, use a deserializer like mcap_ros2.decoder\n                        raw_data = deserialize_payload(message.data, schema.name) # Example helper function\n                        mosaico_msg = custom_translator(schema.name, raw_data)\n\n                        if mosaico_msg is None:\n                            # Log and skip, or raise if incomplete data is disallowed\n                            print(\"Skipping row due to parsing error\")\n                            continue # Ignore malformed records\n\n                        twriter.push(message=mosaico_msg)\n                    except Exception as e:\n                        print(f\"Skip error on {channel.topic} at {message.log_time}: {e}\")\n\n        # All buffers are flushed and the sequence is committed when exiting the SequenceWriter 'with' block\n        print(\"Multi-topic ingestion completed!\")\n</code></pre>"},{"location":"SDK/howto/ontology_customization/","title":"Customizing the Data Ontology","text":"<p>This guide walks you through the process of extending the Mosaico Data Platform with custom data models. While Mosaico provides a rich default ontology for robotics (IMU, GPS, Images, etc.), specialized hardware often requires proprietary data structures.</p> <p>By the end of this guide, you will be able to:</p> <ul> <li>Define strongly-typed data models using Python and Apache Arrow.</li> <li>Register these models so they are recognized by the Mosaico Ecosystem.</li> <li>Integrate them into the ingestion and retrieval pipelines.</li> </ul> <p>For a more in-depth explanation:</p> <ul> <li>Documentation: Data Models &amp; Ontology</li> <li>API Reference: Base Models and Mixins</li> </ul>"},{"location":"SDK/howto/ontology_customization/#step-1-define-the-custom-data-model","title":"Step 1: Define the Custom Data Model","text":"<p>In Mosaico, data models are defined by inheriting from the <code>Serializable</code> base class. This ensures that your model can be automatically translated into the platform's high-performance storage format.</p> <p>For this example, we will create a model for <code>EncoderTicks</code>, found in the NVIDIA Isaac-related datasets.</p> <pre><code>import pyarrow as pa\nfrom mosaicolabs import HeaderMixin, Serializable\n\nclass EncoderTicks(\n    Serializable, # Automatically registers the model via `Serializable.__init_subclass__`\n    HeaderMixin,  # Injects standard metadata (timestamp, frame_id, seq)\n):\n    \"\"\"\n    Custom model for hardware-level encoder tick readings.\n    \"\"\"\n\n    # --- Wire Schema Definition (Apache Arrow) ---\n    # This defines the high-performance binary storage format on the server.\n    __msco_pyarrow_struct__ = pa.struct([\n        pa.field(\"left_ticks\", pa.uint32(), nullable=False),\n        pa.field(\"right_ticks\", pa.uint32(), nullable=False),\n        pa.field(\"encoder_timestamp\", pa.uint64(), nullable=False),\n    ])\n\n    # --- Data Fields ---\n    # Names and types must strictly match the Apache Arrow schema above.\n    left_ticks: int\n    right_ticks: int\n    encoder_timestamp: int\n</code></pre>"},{"location":"SDK/howto/ontology_customization/#step-2-ensure-discovery-via-module-import","title":"Step 2: Ensure \"Discovery\" via Module Import","text":"<p>It is a common pitfall to define a class and expect the platform to \"see\" it immediately. Mosaico utilizes the <code>Serializable.__init_subclass__</code> hook to perform automatic registration the moment the class is loaded into memory by the Python interpreter.</p> <p>For your custom type to be available in your application (especially during ingestion or when using the <code>ROSBridge</code>), you must ensure the module containing the class is imported.</p>"},{"location":"SDK/howto/ontology_customization/#best-practice-the-registry-pattern","title":"Best Practice: The Registry Pattern","text":"<p>Create a dedicated <code>models.py</code> or <code>ontology/</code> package for your project and import it at your application's entry point.</p> <pre><code># app/main.py\nimport my_project.ontology.encoders as encoders # &lt;-- This triggers the registration\nfrom mosaicolabs import MosaicoClient\n\ndef run_ingestion():\n    with MosaicoClient.connect(...) as client:\n        # Now 'EncoderTicks' is a valid ontology_type for topic creation\n        with client.sequence_create(name=\"test\") as sw:\n            tw = sw.topic_create(\"ticks\", ontology_type=encoders.EncoderTicks)\n            # ...\n</code></pre>"},{"location":"SDK/howto/ontology_customization/#step-3-verifying-registration","title":"Step 3: Verifying Registration","text":"<p>If you are unsure whether your model has been correctly \"seen\" by the ecosystem, you can check the internal registry of the <code>Serializable</code> class.</p> <pre><code>from mosaicolabs import Serializable\nimport my_project.ontology.encoders as encoders # &lt;-- This triggers the registration\n\nif encoders.EncoderTicks.is_registered():\n    print(\"Registration successful!\")\n</code></pre>"},{"location":"SDK/howto/query_chained/","title":"Complex Chained Queries","text":"<p>Sometimes a single query is insufficient because you need to correlate data across different topics. This guide demonstrates Query Chaining, a technique where the results of one search are used to \"lock\" the domain for a second, more specific search.</p>"},{"location":"SDK/howto/query_chained/#the-objective","title":"The Objective","text":"<p>Find sequences where a high-precision GPS state was achieved, and within those same sequences, locate any log messages containing the string <code>\"[ERR]\"</code>.</p> <p>For a more in-depth explanation:</p> <ul> <li>Documentation: Querying Catalogs</li> <li>API Reference: Query Builders</li> <li>API Reference: Query Response</li> </ul>"},{"location":"SDK/howto/query_chained/#implementation","title":"Implementation","text":"<pre><code>from mosaicolabs import MosaicoClient, QueryTopic, QueryOntologyCatalog, GPS, String\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Step 1: Initial Broad Search\n    # Find all sequences with high-precision GPS (e.g. status code 2)\n    initial_response = client.query(\n        QueryOntologyCatalog(GPS.Q.status.status.eq(2))\n    )\n\n    if initial_response:\n        # Step 2: Domain Locking\n        # .to_query_sequence() creates a new builder pre-filtered to ONLY these sequences\n        refined_domain = initial_response.to_query_sequence() # (1)!\n\n        # Step 3: Targeted Refinement\n        # Search for error strings only within the validated sequences\n        final_results = client.query(\n            refined_domain, # Restrict to this search domain\n            QueryTopic().with_name(\"/localization/log_string\"),\n            QueryOntologyCatalog(String.Q.data.match(\"[ERR]\"))\n        )\n\n        for item in final_results:\n            print(f\"Error found in precise sequence: {item.sequence.name}\")\n</code></pre> <ol> <li><code>to_query_sequence()</code> returns a <code>QuerySequence</code> builder pre-filtered to include only the sequences present in the response. See also <code>to_query_topic()</code></li> </ol> <p>The <code>query</code> method returns <code>None</code> if an error occurs, or a <code>QueryResponse</code> object. This response acts as a list of <code>QueryResponseItem</code> objects, each providing:</p> <ul> <li><code>item.sequence</code>: A <code>QueryResponseItemSequence</code> containing the sequence metadata.</li> <li><code>item.topics</code>: A list of <code>QueryResponseItemTopic</code> objects that matched the query.</li> </ul> <p>Result Normalization</p> <p>The <code>topic.name</code> returns the relative topic path (e.g., <code>/front/camera/image</code>), which is immediately compatible with other SDK methods like <code>MosaicoClient.topic_handler()</code>, <code>SequenceHandler.get_topic_handler()</code> or streamers.</p>"},{"location":"SDK/howto/query_chained/#key-concepts","title":"Key Concepts","text":"<ul> <li>Convenience Methods: High-level helpers like <code>QueryTopic().with_name()</code> provide a quick way to filter by ontology tags.</li> <li>Generic Methods: The <code>with_expression()</code> method accepts raw Query Expressions generated through the <code>.Q</code> proxy. This provides full access to every supported operator (<code>.gt()</code>, <code>.lt()</code>, <code>.between()</code>, etc.) for specific fields.</li> <li>The <code>.Q</code> Proxy: Every ontology model features a static <code>.Q</code> attribute that dynamically builds type-safe field paths for your expressions.</li> <li>Why is Chaining Necessary? A single <code>client.query()</code> call applies a logical AND to all conditions to find a single topic that satisfies everything. Since a topic cannot be both a <code>GPS</code> stream and a <code>String</code> log simultaneously, you must use chaining to link two different topics within the same Sequence context.</li> </ul>"},{"location":"SDK/howto/query_data/","title":"Detecting Events in Time-Series Data","text":"<p>Beyond metadata, the Mosaico platform allows for deep inspection of actual sensor payloads. This guide shows how to search for specific physical events, such as high-impact accelerations, across your entire data catalog.</p>"},{"location":"SDK/howto/query_data/#the-objective","title":"The Objective","text":"<p>Identify specific time segments where an IMU sensor recorded:</p> <ol> <li>Lateral acceleration (-axis) greater than .</li> <li>Longitudinal acceleration (-axis) greater than .</li> </ol> <p>For a more in-depth explanation:</p> <ul> <li>Documentation: Querying Catalogs</li> <li>API Reference: Query Builders</li> <li>API Reference: Query Response</li> </ul>"},{"location":"SDK/howto/query_data/#implementation","title":"Implementation","text":"<p>When you call multiple <code>with_*</code> methods of the <code>QueryOntologyCatalog</code> builder, the platform joins them with a logical AND condition. The server will return only the sequences that match the  criteria alltogether.</p> <pre><code>from mosaicolabs import MosaicoClient, QueryOntologyCatalog, IMU\n\n# 1. Establish a connection\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # 2. Execute the query across all available data\n    # include_timestamp_range is essential for pinpointing the exact time of the event\n    results = client.query(\n        QueryOntologyCatalog(include_timestamp_range=True)\n        .with_expression(IMU.Q.acceleration.x.gt(5.0))\n        .with_expression(IMU.Q.acceleration.y.gt(4.0))\n    )\n\n    # 3. Process the Response\n    if results:\n        for item in results:\n            print(f\"Impact detected in Sequence: {item.sequence.name}\")\n            for topic in item.topics:\n                # topic.timestamp_range provides the start and end of the match\n                print(f\"  - Match in Topic: {topic.name}\") # (1)!\n                start, end = topic.timestamp_range.start, topic.timestamp_range.end # (2)!\n                print(f\"    Event Window: {start} to {end} ns\")\n</code></pre> <ol> <li>The <code>item.topics</code> list contains all the topics that matched the query. In this case, it will contain all the topics that are of type IMU and for which the data-related filter is met. </li> <li>The <code>topic.timestamp_range</code> provides the first and last occurrence of the queried condition within a topic, allowing you to slice data accurately for further analysis.</li> </ol> <p>The <code>query</code> method returns <code>None</code> if an error occurs, or a <code>QueryResponse</code> object. This response acts as a list of <code>QueryResponseItem</code> objects, each providing:</p> <ul> <li><code>item.sequence</code>: A <code>QueryResponseItemSequence</code> containing the sequence metadata.</li> <li><code>item.topics</code>: A list of <code>QueryResponseItemTopic</code> objects that matched the query.</li> </ul> <p>Result Normalization</p> <p>The <code>topic.name</code> returns the relative topic path (e.g., <code>/front/camera/image</code>), which is immediately compatible with other SDK methods like <code>MosaicoClient.topic_handler()</code>, <code>SequenceHandler.topic_handler()</code> or streamers.</p>"},{"location":"SDK/howto/query_data/#key-concepts","title":"Key Concepts","text":"<ul> <li>Generic Methods: The <code>with_expression()</code> method accepts raw Query Expressions generated through the <code>.Q</code> proxy. This provides full access to every supported operator (<code>.gt()</code>, <code>.lt()</code>, <code>.between()</code>, etc.) for specific fields.</li> <li>The <code>.Q</code> Proxy: Every ontology model features a static <code>.Q</code> attribute that dynamically builds type-safe field paths for your expressions.</li> <li>Temporal Windows: Setting <code>include_timestamp_range=True</code> enables the platform to return the precise \"occurrence\" of the event, which is vital for later playback or slicing.</li> <li>Type-Safe Operators: The <code>.Q</code> proxy ensures that only valid operators (like <code>.gt()</code>) are available for numeric fields like <code>acceleration.x</code>.</li> </ul>"},{"location":"SDK/howto/query_multi_domain/","title":"Multi-Domain Querying","text":"<p>This guide demonstrates how to orchestrate a Unified Query across three distinct layers of the Mosaico Data Platform: the Sequence (session metadata), the Topic (channel configuration), and the Ontology Catalog (actual sensor data). By combining these builders in a single request, you can perform highly targeted searches that correlate mission-level context with specific sensor events.</p>"},{"location":"SDK/howto/query_multi_domain/#the-objective","title":"The Objective","text":"<p>We want to isolate data segments from a large fleet recording by searching for:</p> <ol> <li>Sequence: Sessions belonging to the <code>\"Apollo\"</code> project.</li> <li>Topic: Specifically the front-facing camera imu topic named <code>\"/front/camera/imu\"</code>.</li> <li>Ontology: Time segments where such an IMU recorded a longitudinal acceleration (x-axis) exceeding 5.0 m/s\u00b2.</li> </ol> <p>For a more in-depth explanation:</p> <ul> <li>Documentation: Querying Catalogs</li> <li>API Reference: Query Builders</li> <li>API Reference: Query Response</li> </ul>"},{"location":"SDK/howto/query_multi_domain/#implementation","title":"Implementation","text":"<p>When you pass multiple builders to the <code>MosaicoClient.query()</code> method, the platform joins them with a logical AND condition. The server will return only the sequences that match the <code>QuerySequence</code> criteria, and within those sequences, only the topics that match both the <code>QueryTopic</code> and <code>QueryOntologyCatalog</code> criteria. The multi-domain query allows you to execute a search across metadata and raw sensor data in a single, atomic request.</p> <pre><code>from mosaicolabs import MosaicoClient, QuerySequence, QueryTopic, QueryOntologyCatalog, IMU, Sequence\n\n# 1. Establish a connection\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n\n    # 2. Execute a unified multi-domain query\n    results = client.query(\n        # Filter 1: Sequence Layer (Project Metadata)\n        QuerySequence()\n            .with_expression(Sequence.Q.user_metadata[\"project.name\"].eq(\"Apollo\")), # (1)!\n\n        # Filter 2: Topic Layer (Specific Channel Name)\n        QueryTopic()\n            .with_name(\"/front/camera/imu\"), # Precise name match\n\n        # Filter 3: Ontology Layer (Deep Data Event Detection)\n        QueryOntologyCatalog(include_timestamp_range=True)\n            .with_expression(IMU.Q.acceleration.x.gt(5.0))\n    )\n\n    # 3. Process the Structured Response\n    if results:\n        for item in results:\n            # item.sequence contains the matched Sequence metadata\n            print(f\"Sequence: {item.sequence.name}\") \n\n            # item.topics contains only the topics and time-segments \n            # that satisfied ALL criteria simultaneously\n            for topic in item.topics:\n                # Access the high-precision timestamp for the detected event\n                print(f\"  - Match in Topic: {topic.name}\") # (2)!\n                start, end = topic.timestamp_range.start, topic.timestamp_range.end # (3)!\n                print(f\"    Event Window: {start} to {end} ns\")\n</code></pre> <ol> <li>Use dot notation to access nested fields in the <code>user_metadata</code> dictionary.</li> <li>The <code>item.topics</code> list contains all the topics that matched the query. In this case, it will contain all the topics that are of type IMU, with a name matching that specific topic name and for which the data-related filter is met.</li> <li>The <code>topic.timestamp_range</code> provides the first and last occurrence of the queried condition within a topic, allowing you to slice data accurately for further analysis.</li> </ol> <p>The <code>query</code> method returns <code>None</code> if an error occurs, or a <code>QueryResponse</code> object. This response acts as a list of <code>QueryResponseItem</code> objects, each providing:</p> <ul> <li><code>item.sequence</code>: A <code>QueryResponseItemSequence</code> containing the sequence metadata.</li> <li><code>item.topics</code>: A list of <code>QueryResponseItemTopic</code> objects that matched the query.</li> </ul> <p>Result Normalization</p> <p>The <code>topic.name</code> returns the relative topic path (e.g., <code>/front/camera/image</code>), which is immediately compatible with other SDK methods like <code>MosaicoClient.topic_handler()</code>, <code>SequenceHandler.get_topic_handler()</code> or streamers.</p>"},{"location":"SDK/howto/query_multi_domain/#key-concepts","title":"Key Concepts","text":"<ul> <li>Convenience Methods: High-level helpers like <code>with_name_match()</code> provide a quick way to filter common fields.</li> <li>Generic Methods: The <code>with_expression()</code> method accepts raw Query Expressions generated through the <code>.Q</code> proxy. This provides full access to every supported operator (<code>.gt()</code>, <code>.lt()</code>, <code>.between()</code>, etc.) for specific fields.</li> <li>The <code>.Q</code> Proxy: Every ontology model features a static <code>.Q</code> attribute that dynamically builds type-safe field paths for your expressions.</li> <li>Temporal Windows: By setting <code>include_timestamp_range=True</code> in the <code>QueryOntologyCatalog</code>, the platform identifies the exact start and end of the matching event within the stream.</li> <li>Dictionary Access: Use bracket notation (e.g., <code>Sequence.Q.user_metadata[\"key.subkey\"]</code>) to query custom tags that are not part of a fixed schema.</li> </ul>"},{"location":"SDK/howto/query_sequences/","title":"Querying Sequences by Name and Metadata","text":"<p>This guide demonstrates how to locate specific recording sessions based on their naming conventions and custom user metadata tags. This is the most common entry point for data discovery, allowing you to isolate sessions that match specific environmental or project conditions.</p>"},{"location":"SDK/howto/query_sequences/#the-objective","title":"The Objective","text":"<p>We want to find all sequences where:</p> <ol> <li>The sequence name contains the string <code>\"test_drive\"</code>.</li> <li>The user metadata indicates a specific project name (e.g., <code>\"Apollo\"</code>).</li> <li>The environmental visibility was recorded as less than 50m.</li> </ol> <p>For a more in-depth explanation:</p> <ul> <li>Documentation: Querying Catalogs</li> <li>API Reference: Query Builders</li> <li>API Reference: Query Response</li> </ul>"},{"location":"SDK/howto/query_sequences/#implementation","title":"Implementation","text":"<p>When you call multiple <code>with_*</code> methods of the <code>QuerySequence</code> builder, the platform joins them with a logical AND condition. The server will return only the sequences that match the  criteria alltogether.</p> <pre><code>from mosaicolabs import MosaicoClient, QuerySequence, Sequence\n\n# 1. Establish a connection\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # 2. Execute the query\n    results = client.query(\n        QuerySequence()\n        # Use a convenience method for fuzzy name matching\n        .with_name_match(\"test_drive\")\n        # Use the .Q proxy to filter fixed and dynamic metadata fields\n        .with_expression(Sequence.Q.user_metadata[\"project\"].eq(\"Apollo\"))\n        .with_expression(Sequence.Q.user_metadata[\"environment.visibility\"].lt(50)) # (1)!\n    )\n\n    # 3. Process the Response\n    if results:\n        for item in results:\n            # item.sequence contains the information for the matched sequence\n            print(f\"Matched Sequence: {item.sequence.name}\")\n            print(f\"  Topics: {[topic.name for topic in item.topics]}\") # (2)!\n</code></pre> <ol> <li>Use dot notation to access nested fields in the <code>user_metadata</code> dictionary.</li> <li>The <code>item.topics</code> list contains all the topics that matched the query. In this case, all the available topics are returned because no topic-specific filters were applied.</li> </ol> <p>The <code>query</code> method returns <code>None</code> if an error occurs, or a <code>QueryResponse</code> object. This response acts as a list of <code>QueryResponseItem</code> objects, each providing:</p> <ul> <li><code>item.sequence</code>: A <code>QueryResponseItemSequence</code> containing the sequence metadata.</li> <li><code>item.topics</code>: A list of <code>QueryResponseItemTopic</code> objects that matched the query.</li> </ul> <p>Result Normalization</p> <p>The <code>topic.name</code> returns the relative topic path (e.g., <code>/front/camera/image</code>), which is immediately compatible with other SDK methods like <code>MosaicoClient.topic_handler()</code>, <code>SequenceHandler.get_topic_handler()</code> or streamers.</p>"},{"location":"SDK/howto/query_sequences/#key-concepts","title":"Key Concepts","text":"<ul> <li>Convenience Methods: High-level helpers like <code>with_name_match()</code> provide a quick way to filter common fields.</li> <li>Generic Methods: The <code>with_expression()</code> method accepts raw Query Expressions generated through the <code>.Q</code> proxy. This provides full access to every supported operator (<code>.gt()</code>, <code>.lt()</code>, <code>.between()</code>, etc.) for specific fields.</li> <li>Dynamic Metadata Access: Using the bracket notation <code>Sequence.Q.user_metadata[\"key\"]</code> allows you to query any custom tag you attached during the ingestion phase.</li> </ul>"},{"location":"SDK/howto/query_topics/","title":"Querying Topics by Name and Metadata","text":"<p>This guide demonstrates how to locate specific recording sessions based on their naming conventions and custom user metadata tags. This is the most common entry point for data discovery, allowing you to isolate sessions that match specific environmental or project conditions.</p>"},{"location":"SDK/howto/query_topics/#the-objective","title":"The Objective","text":"<p>We want to find all topics where:</p> <ol> <li>The topic refers to an IMU sensor.</li> <li>The user metadata indicates a specific sensor interface (e.g., <code>\"serial\"</code>).</li> </ol> <p>For a more in-depth explanation:</p> <ul> <li>Documentation: Querying Catalogs</li> <li>API Reference: Query Builders</li> <li>API Reference: Query Response</li> </ul>"},{"location":"SDK/howto/query_topics/#implementation","title":"Implementation","text":"<p>When you call multiple <code>with_*</code> methods of the <code>QueryTopic</code> builder, the platform joins them with a logical AND condition. The server will return only the sequences that match the  criteria alltogether.</p> <pre><code>from mosaicolabs import MosaicoClient, QueryTopic, Topic, IMU\n\n# 1. Establish a connection\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # 2. Execute the query\n    results = client.query(\n        QueryTopic()\n        # Use a convenience method for fuzzy name matching\n        .with_ontology_tag(IMU.ontology_tag())\n        # Use the .Q proxy to filter fixed and dynamic metadata fields\n        .with_expression(Topic.Q.user_metadata[\"interface\"].eq(\"serial\")))\n\n    # 3. Process the Response\n    if results:\n        for item in results:\n            # item.sequence contains the metadata for the matched sequence\n            print(f\"Matched Sequence: {item.sequence.name}\")\n            print(f\"  Topics: {[topic.name for topic in item.topics]}\") # (1)!\n</code></pre> <ol> <li>The <code>item.topics</code> list contains all the topics that matched the query. In this case, it will contain all the topics that are of type IMU and have the user metadata field <code>interface</code> set to <code>\"serial\"</code>.</li> </ol> <p>The <code>query</code> method returns <code>None</code> if an error occurs, or a <code>QueryResponse</code> object. This response acts as a list of <code>QueryResponseItem</code> objects, each providing:</p> <ul> <li><code>item.sequence</code>: A <code>QueryResponseItemSequence</code> containing the sequence metadata.</li> <li><code>item.topics</code>: A list of <code>QueryResponseItemTopic</code> objects that matched the query.</li> </ul> <p>Result Normalization</p> <p>The <code>topic.name</code> returns the relative topic path (e.g., <code>/front/camera/image</code>), which is immediately compatible with other SDK methods like <code>MosaicoClient.topic_handler()</code>, <code>SequenceHandler.get_topic_handler()</code> or streamers.</p>"},{"location":"SDK/howto/query_topics/#key-concepts","title":"Key Concepts","text":"<ul> <li>Convenience Methods: High-level helpers like <code>with_ontology_tag()</code> provide a quick way to filter by ontology tags.</li> <li>Generic Methods: The <code>with_expression()</code> method accepts raw Query Expressions generated through the <code>.Q</code> proxy. This provides full access to every supported operator (<code>.gt()</code>, <code>.lt()</code>, <code>.between()</code>, etc.) for specific fields.</li> <li>Dynamic Metadata Access: Using the bracket notation <code>Topic.Q.user_metadata[\"key\"]</code> allows you to query any custom tag you attached during the ingestion phase.</li> </ul>"},{"location":"SDK/howto/reading/","title":"Reading a Sequence and its Topics","text":"<p>This guide demonstrates how to interact with the Mosaico Data Platform to inspect and retrieve data that has been previously ingested. You will learn how to use the Mosaico SDK to:</p> <ul> <li>Connect to the catalog to find existing recordings.</li> <li>Inspect sequence metadata and temporal bounds.</li> <li>Access specific topic handlers to analyze individual sensor streams.</li> </ul> <p>For a more in-depth explanation:</p> <ul> <li>Documentation: The Reading Workflow</li> <li>API Reference: Data Retrieval</li> </ul>"},{"location":"SDK/howto/reading/#step-1-connecting-to-the-catalog","title":"Step 1: Connecting to the Catalog","text":"<p>To begin inspecting data, you must establish a connection via the <code>MosaicoClient</code>. Reading is managed through a context manager to ensure all network resources are cleanly released.</p> <pre><code>from mosaicolabs import MosaicoClient\n\n# Establish a secure connection to the Mosaico server\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Use a Handler to inspect the catalog for a specific recording session\n    seq_handler = client.sequence_handler(\"multi_sensor_ingestion\")\n\n    if not seq_handler:\n        print(\"Sequence not found in the catalog.\")\n    else:\n        # Proceed to inspect metadata (Step 2)\n        pass\n</code></pre>"},{"location":"SDK/howto/reading/#step-2-inspecting-sequence-metadata","title":"Step 2: Inspecting Sequence Metadata","text":"<p>A <code>SequenceHandler</code> provides a view of a complete recording session without transferring the actual bulk data yet. This \"lazy\" inspection allows you to verify session parameters, such as the total size on disk and global user metadata.</p> <pre><code>    \"\"\"Inside the `if seq_handler:` block\"\"\"\n\n    # Print sequence metadata\n    print(f\"Sequence: {seq_handler.name}\")\n    print(f\"\u2022 Registered Topics: {seq_handler.topics}\")\n    print(f\"\u2022 User Metadata: {seq_handler.user_metadata}\")\n\n    # Analyze temporal bounds (earliest and latest timestamps across all sensors)\n    # Timestamps are consistently handled in nanoseconds\n    start, end = seq_handler.timestamp_ns_min, seq_handler.timestamp_ns_max\n    print(f\"\u2022 Duration (ns): {end - start}\")\n\n    # Access structural info from the server\n    size_mb = seq_handler.sequence_info.total_size_bytes / (1024 * 1024)\n    print(f\"\u2022 Total Size: {size_mb:.2f} MB\")\n    print(f\"\u2022 Created At: {seq_handler.sequence_info.created_datetime}\")\n</code></pre>"},{"location":"SDK/howto/reading/#step-3-accessing-individual-topics","title":"Step 3: Accessing Individual Topics","text":"<p>While a sequence represents a \"mission,\" a <code>TopicHandler</code> represents a specific data channel within that mission (e.g., a single IMU or GPS).</p> <pre><code>    \"\"\"Inside the `if seq_handler:` block\"\"\"\n\n    # Retrieve a specific handler for the IMU sensor\n    imu_handler = seq_handler.get_topic_handler(\"sensors/imu\")\n\n    if imu_handler:\n        print(f\"Inspecting Topic: {imu_handler.name}\")\n        print(f\"\u2022 Sensor Metadata: {imu_handler.user_metadata}\")\n\n        # Check topic-specific temporal bounds\n        print(f\"\u2022 Topic Span: {imu_handler.timestamp_ns_min} to {imu_handler.timestamp_ns_max}\")\n\n        # Topic-specific size on the server\n        topic_mb = imu_handler.topic_info.total_size_bytes / (1024 * 1024)\n        print(f\"\u2022 Topic Size: {topic_mb:.2f} MB\")\n</code></pre>"},{"location":"SDK/howto/reading/#comparison-sequence-vs-topic-handlers","title":"Comparison: Sequence vs. Topic Handlers","text":"Feature Sequence Handler Topic Handler Scope Entire Recording Session Single Sensor Stream Metadata Mission-wide (e.g., driver, weather) Sensor-specific (e.g., model, serial) Time Bounds Global min/max of all topics Min/max for that specific stream Topics List of all available streams N/A"},{"location":"SDK/howto/reading/#the-full-example-code","title":"The full example code","text":"<pre><code>from mosaicolabs import MosaicoClient\n\n# Establish a secure connection to the Mosaico server\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Use a Handler to inspect the catalog for a specific recording session\n    seq_handler = client.sequence_handler(\"multi_sensor_ingestion\")\n\n    if not seq_handler:\n        print(\"Sequence not found in the catalog.\")\n    else:\n        # Proceed to inspect metadata (Step 2)\n        pass\n\n    # Print sequence metadata\n    print(f\"Sequence: {seq_handler.name}\")\n    print(f\"\u2022 Registered Topics: {seq_handler.topics}\")\n    print(f\"\u2022 User Metadata: {seq_handler.user_metadata}\")\n\n    # Analyze temporal bounds (earliest and latest timestamps across all sensors)\n    # Timestamps are consistently handled in nanoseconds\n    start, end = seq_handler.timestamp_ns_min, seq_handler.timestamp_ns_max\n    print(f\"\u2022 Duration (ns): {end - start}\")\n\n    # Access structural info from the server\n    size_mb = seq_handler.sequence_info.total_size_bytes / (1024 * 1024)\n    print(f\"\u2022 Total Size: {size_mb:.2f} MB\")\n    print(f\"\u2022 Created At: {seq_handler.sequence_info.created_datetime}\")\n\n    # Retrieve a specific handler for the IMU sensor\n    imu_handler = seq_handler.get_topic_handler(\"sensors/imu\")\n\n    if imu_handler:\n        print(f\"Inspecting Topic: {imu_handler.name}\")\n        print(f\"\u2022 Sensor Metadata: {imu_handler.user_metadata}\")\n\n        # Check topic-specific temporal bounds\n        print(f\"\u2022 Topic Span: {imu_handler.timestamp_ns_min} to {imu_handler.timestamp_ns_max}\")\n\n        # Topic-specific size on the server\n        topic_mb = imu_handler.topic_info.total_size_bytes / (1024 * 1024)\n        print(f\"\u2022 Topic Size: {topic_mb:.2f} MB\")\n</code></pre>"},{"location":"SDK/howto/ros_injection_1/","title":"ROS Injection","text":"<p>Full Example Code</p> <p>The full example code is available under <code>mosaico-sdk-py/src/examples/ros_injection/main.py</code>.</p> <p>Prerequisites</p> <p>To fully grasp the following How-To, we recommend you to read the Customizing the Data Ontology How-To.</p> <p>Dataset</p> <p>This tutorial uses the <code>r2b_whitetunnel_0</code> sequence from the NVIDIA R2B Dataset 2024.</p> <p>This example provides a detailed, step-by-step walkthrough of a complete Mosaico data pipeline, from raw ROS bag ingestion to custom ontology creation and verification. It demonstrates how to bridge the gap between Robot Operating System (ROS) data and the Mosaico Data Platform. By following this pipeline, you will learn how to:</p> <ol> <li>Create a custom ontology data model that matches a specific hardware sensor.</li> <li>Implement a ROS Adapter that converts raw ROS dictionaries into your custom Mosaico model.</li> <li>Automate Ingestion using a high-performance injector to upload a complete recording (MCAP) to the server.</li> <li>Verify Results by inspecting the ingested data to ensure structural integrity.</li> </ol>"},{"location":"SDK/howto/ros_injection_1/#running-the-example","title":"Running the Example","text":"<p>This setup provides a local Mosaico server instance to receive and store the data from your Python scripts.</p>"},{"location":"SDK/howto/ros_injection_1/#start-the-mosaico-infrastructure","title":"Start the Mosaico Infrastructure","text":"<p>First, launch the required backend services (database and ingestion server) using Docker Compose. Run these commands from the <code>mosaico-sdk-py</code> root directory:</p> <pre><code># Navigate to the quickstart environment\ncd docker/quick_start\n\n# Start the Mosaico server and its dependencies\ndocker compose up\n</code></pre>"},{"location":"SDK/howto/ros_injection_1/#execute-the-ros-injection-script","title":"Execute the ROS Injection Script","text":"<p>Once the infrastructure is healthy, open a new terminal tab or window to run the demonstration script. Run these commands from the <code>mosaico-sdk-py</code> root directory:</p> <pre><code># Navigate to the examples directory\ncd examples\n\n# Run the ROS injection example using poetry\npoetry run python -m ros_injection.main\n</code></pre>"},{"location":"SDK/howto/ros_injection_1/#what-to-expect","title":"What to Expect","text":"<ul> <li>Server Logs: In your first terminal, you will see the Docker containers spinning up and the Mosaico Ingestion Server acknowledging incoming connections.</li> <li>Injection Progress: In your second terminal, the <code>RosbagInjector</code> will provide a CLI progress bar showing the topics being resolved, messages being adapted, and the final transmission status.</li> <li>Data Verification: After completion, the sequence will be fully cataloged on the server and ready for retrieval via the <code>SequenceHandler</code>.</li> </ul> <p>Would you like me to show you how to check the server logs to verify that the sequence was successfully committed to the database? You should see output similar to the following:</p> <pre><code>Downloading: https://api.ngc.nvidia.com/v2/resources/org/nvidia/team/isaac/r2bdataset2024/1/files?redirect=true&amp;path=r2b_whitetunnel/r2b_whitetunnel_0.mcap\nFetching r2b_whitetunnel_0.mcap \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 527.0/527.0 MB XY.Z MB/s 0:00:00\n\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Phase 2: Starting ROS Ingestion                                                                                                         \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n[14:29:38] INFO     mosaicolabs: SDK Logging initialized at level: INFO                                                logging_config.py:99\n           INFO     mosaicolabs.ros_bridge.injector: Connecting to Mosaico at 'localhost:6276'...                           injector.py:266\n[14:29:40] INFO     mosaicolabs.ros_bridge.injector: Opening bag: '/tmp/mosaico_assets/r2b_whitetunnel_0.mcap'              injector.py:274\n           INFO     mosaicolabs.ros_bridge.injector: Starting upload...                                                     injector.py:291\n/back_stereo_camera/left/camera_info               \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501         564/564         100.0%   \u2022   0:00:00   \u2022   0:00:24     \n/back_stereo_camera/left/image_compressed          \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501         525/525         100.0%   \u2022   0:00:00   \u2022   0:00:24     \n/back_stereo_camera/right/camera_info              \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501         564/564         100.0%   \u2022   0:00:00   \u2022   0:00:24     \n/back_stereo_camera/right/image_compressed         \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501         490/490         100.0%   \u2022   0:00:00   \u2022   0:00:24     \n/chassis/battery_state                             \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501         27/27           100.0%   \u2022   0:00:00   \u2022   0:00:19     \n/chassis/imu                                       \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501         1080/1080       100.0%   \u2022   0:00:00   \u2022   0:00:24     \n/chassis/odom                                      \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501         1080/1080       100.0%   \u2022   0:00:00   \u2022   0:00:24     \n/chassis/ticks                                     \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501         1081/1081       100.0%   \u2022   0:00:00   \u2022   0:00:24     \n/front_stereo_camera/left/camera_info              \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501         562/562         100.0%   \u2022   0:00:00   \u2022   0:00:24     \n/front_stereo_camera/left/image_compressed         \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501         521/521         100.0%   \u2022   0:00:00   \u2022   0:00:24     \n/front_stereo_camera/right/camera_info             \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501         562/562         100.0%   \u2022   0:00:00   \u2022   0:00:24     \n/front_stereo_camera/right/image_compressed        \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501         515/515         100.0%   \u2022   0:00:00   \u2022   0:00:24     \n/front_stereo_imu/imu                              \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501         1761/1761       100.0%   \u2022   0:00:00   \u2022   0:00:24     \n/left_stereo_camera/left/camera_info               \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501         527/527         100.0%   \u2022   0:00:00   \u2022   0:00:24     \n/left_stereo_camera/left/image_compressed          \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501         513/513         100.0%   \u2022   0:00:00   \u2022   0:00:24     \n/left_stereo_camera/right/camera_info              \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501         527/527         100.0%   \u2022   0:00:00   \u2022   0:00:24     \n/left_stereo_camera/right/image_compressed         \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501         498/498         100.0%   \u2022   0:00:00   \u2022   0:00:24     \n/right_stereo_camera/left/camera_info              \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501         488/488         100.0%   \u2022   0:00:00   \u2022   0:00:24     \n/right_stereo_camera/left/image_compressed         \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501         488/488         100.0%   \u2022   0:00:00   \u2022   0:00:24     \n/right_stereo_camera/right/camera_info             \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501         488/488         100.0%   \u2022   0:00:00   \u2022   0:00:24     \n/right_stereo_camera/right/image_compressed        \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501         488/488         100.0%   \u2022   0:00:00   \u2022   0:00:24     \n/tf                                                \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501         4282/4282       100.0%   \u2022   0:00:00   \u2022   0:00:24     \n/tf_static                                         \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501         1/1             100.0%   \u2022   0:00:00   \u2022   0:00:00     \nTotal Upload                                       \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501         17632/17632     100.0%   \u2022   0:00:00   \u2022   0:00:24     \n\n...Other logging messages\n</code></pre>"},{"location":"SDK/howto/ros_injection_1/#step-by-step-guide","title":"Step-by-Step Guide","text":""},{"location":"SDK/howto/ros_injection_1/#step-1-custom-ontology-definition-isaacpy","title":"Step 1: Custom Ontology Definition (<code>isaac.py</code>)","text":"<p>In Mosaico, data is strongly typed. When dealing with specialized hardware like the NVIDIA Isaac Nova encoders, with custom data models, not available in the SDK, we must define a model that the platform understands.</p>"},{"location":"SDK/howto/ros_injection_1/#the-data-model","title":"The Data Model","text":"<p>The <code>EncoderTicks</code> class defines the physical storage format.</p> <pre><code>import pyarrow as pa\nfrom mosaicolabs import HeaderMixin, Serializable\n\nclass EncoderTicks(Serializable, HeaderMixin):\n    # --- Wire Schema Definition ---\n    __msco_pyarrow_struct__ = pa.struct([\n        pa.field(\"left_ticks\", pa.uint32(), nullable=False),\n        pa.field(\"right_ticks\", pa.uint32(), nullable=False),\n        pa.field(\"encoder_timestamp\", pa.uint64(), nullable=False),\n    ])\n\n    # --- Pydantic Fields ---\n    left_ticks: int\n    right_ticks: int\n    encoder_timestamp: int\n</code></pre> <p>What is happening here?</p> <ul> <li><code>Serializable</code>: Inheriting from this class automatically registers your model in the Mosaico ecosystem, making it dispatchable to the data platform, and enables the <code>.Q</code> query proxy.</li> <li><code>HeaderMixin</code>: This \"injects\" a standard <code>header</code> (including a timestamp and frame ID) into your model, ensuring it remains compatible with time-series analysis.</li> <li>Schema Alignment: The field names in the <code>pa.struct</code> must match exactly the names of the Python attributes.</li> </ul> <p>For a more in-depth explanation:</p> <ul> <li>How-To: Customizing the Data Ontology</li> <li>Documentation: Data Models &amp; Ontology</li> </ul>"},{"location":"SDK/howto/ros_injection_1/#step-2-implementing-the-ros-adapter-isaac_adapterspy","title":"Step 2: Implementing the ROS Adapter (<code>isaac_adapters.py</code>)","text":"<p>A ROS Bag contains raw data dictionaries, that we need to translate into our custom ontology data model, by using adapters. The <code>ROSAdapterBase</code> class provides the necessary infrastructure for this. We just need to implement the <code>from_dict</code> method, which is responsible for converting the raw ROS message dictionary into our custom ontology model.</p>"},{"location":"SDK/howto/ros_injection_1/#the-adapter-implementation","title":"The Adapter Implementation","text":"<pre><code>from mosaicolabs.ros_bridge import ROSMessage, ROSAdapterBase, register_adapter\nfrom mosaicolabs.ros_bridge.adapters.helpers import _make_header, _validate_msgdata\nfrom .isaac import EncoderTicks\n\n@register_adapter\nclass EncoderTicksAdapter(ROSAdapterBase[EncoderTicks]):\n    ros_msgtype = (\"isaac_ros_nova_interfaces/msg/EncoderTicks\",)\n    __mosaico_ontology_type__ = EncoderTicks\n    _REQUIRED_KEYS = (\"left_ticks\", \"right_ticks\", \"encoder_timestamp\")\n\n    @classmethod\n    def from_dict(cls, ros_data: dict) -&gt; EncoderTicks:\n        \"\"\"\n        Convert a ROS message dictionary to an EncoderTicks object.\n        \"\"\"\n        _validate_msgdata(cls, ros_data)\n        return EncoderTicks(\n            header=_make_header(ros_data.get(\"header\")),\n            left_ticks=ros_data[\"left_ticks\"],\n            right_ticks=ros_data[\"right_ticks\"],\n            encoder_timestamp=ros_data[\"encoder_timestamp\"],\n        )\n\n    @classmethod\n    def translate(cls, ros_msg: ROSMessage, **kwargs: Any) -&gt; Message:\n        \"\"\"\n        Translates a ROS EncoderTicks message into a Mosaico Message container.\n        \"\"\"\n        return super().translate(ros_msg, **kwargs)\n</code></pre> <p>Key Operations:</p> <ul> <li><code>@register_adapter</code>: This decorator registers the adapter with the Mosaico ROS Bridge.</li> <li><code>ros_msgtype</code>: A tuple of strings representing the ROS message types that this adapter can handle.</li> <li><code>__mosaico_ontology_type__</code>: The Mosaico ontology type that this adapter can handle.</li> <li><code>_REQUIRED_KEYS</code>: A tuple of strings representing the required keys in the ROS message. This is used by the <code>_validate_msgdata</code> method to check that the ROS message does contains the required fields.</li> <li><code>from_dict</code>: This is the heart of the translator. It takes a Python dictionary and maps the keys to our <code>EncoderTicks</code> ontology model.</li> <li><code>translate</code>: This method is called by the <code>RosbagInjector</code> class for each message in the bag. It is responsible for converting the raw ROS message dictionary into the Mosaico message, wrapping the custom ontology model.</li> </ul> <p>For a more in-depth explanation:</p> <ul> <li>Documentation: ROS Bridge</li> <li>API Reference: ROS Bridge</li> </ul>"},{"location":"SDK/howto/ros_injection_1/#step-3-the-execution-pipeline-ros_injectionpy","title":"Step 3: The Execution Pipeline (<code>ros_injection.py</code>)","text":"<p>The main script orchestrates the entire process in three distinct phases.</p>"},{"location":"SDK/howto/ros_injection_1/#phase-1-asset-preparation","title":"Phase 1: Asset Preparation","text":"<p>Before we can ingest data, we need the raw file. This phase downloads a verified dataset from NVIDIA.</p> <pre><code># --- PHASE 1: Asset Preparation ---\nout_bag_file = download_asset(BAGFILE_URL, ASSET_DIR)\n</code></pre>"},{"location":"SDK/howto/ros_injection_1/#phase-2-high-performance-injection","title":"Phase 2: High-Performance Injection","text":"<p>This is where the ROS Bridge takes over. It opens the bag, applies our custom <code>EncoderTicksAdapter</code>, plus the adapters already available in the SDK, and streams the data to the server.</p> <pre><code># Configure the ROS injection. This uses the 'Adaptation' philosophy to translate\n# ROS types into the Mosaico Ontology.\nconfig = ROSInjectionConfig(\n        host=MOSAICO_HOST,\n        port=MOSAICO_PORT,\n        file_path=out_bag_file,\n        sequence_name=out_bag_file.stem,  # Sequence name derived from filename\n        # Some example metadata for the sequence\n        metadata={\n            \"source_url\": BAGFILE_URL,\n            \"ingested_via\": \"mosaico_example_ros_injection\",\n            \"download_time_utc\": str(downloaded_time),\n        },\n        log_level=\"INFO\",\n    )\n\n# Handles connection, loading, adaptation, and batching\ninjector = RosbagInjector(config)\ninjector.run()  # Starts the ingestion process\n</code></pre> <p>The <code>ROSInjectionConfig</code> defines where the server is and what metadata to attach to the sequence. The <code>injector.run()</code> method handles the heavy lifting\u2014file loading, message adaptation, and network batching\u2014automatically. The <code>RosbagInjector</code> uses the SDK features to connect to the Mosaico server, orchestrating sequence and topics creation, etc.</p> <p>For a more in-depth explanation:</p> <ul> <li>Documentation: ROS Bridge</li> <li>API Reference: ROS Bridge</li> </ul>"},{"location":"SDK/howto/ros_injection_1/#phase-3-verification-retrieval","title":"Phase 3: Verification &amp; Retrieval","text":"<p>Once the upload is finished, we connect to the Mosaico Server to retrieve the data from the sequence just created.</p> <pre><code>with MosaicoClient.connect(host=MOSAICO_HOST, port=MOSAICO_PORT) as client:\n    # Ask for a SequenceHandler for the sequence we just created. \n    # The sequence is identified by its name, which is the stem of the bagfile.\n    shandler = client.sequence_handler(out_bag_file.stem)\n\n    # Print some information about the sequence    \n    print(f\"Sequence Name: {shandler.name}\")\n    print(f\"Topics Found: {len(shandler.topics)}\")\n    # ...\n</code></pre> <p>Operations:</p> <ul> <li><code>MosaicoClient.connect()</code>: Establishes a secure connection to the platform.</li> <li><code>MosaicoClient.sequence_handler()</code>: Retrieves a specialized object used to manage and query the specific recording we just uploaded.</li> </ul> <p>For a more in-depth explanation:</p> <ul> <li>Documentation: The Reading Workflow</li> <li>API Reference: Data Retrieval</li> </ul>"},{"location":"SDK/howto/ros_injection_1/#the-full-example-code","title":"The full example code","text":"<p>The full example code is available under <code>mosaico-sdk-py/src/examples/ros_injection/main.py</code>.</p>"},{"location":"SDK/howto/serialized_writing_from_csv/","title":"Writing a Single Topic","text":"<p>This guide demonstrates how to ingest data into the Mosaico Data Platform from custom files. Here the example of a CSV file is provided, but the logic is compatible with any file format and I/O library. You will learn how to use the Mosaico SDK for:</p> <ul> <li>Opening a connection to the Mosaico server.</li> <li>Creating a sequence.</li> <li>Creating a topic.</li> <li>Pushing data into a topic.</li> </ul>"},{"location":"SDK/howto/serialized_writing_from_csv/#step-1-chunked-loading-for-high-volume-data","title":"Step 1: Chunked Loading for High-Volume Data","text":"<p>In this example, we assume our CSV file contains the following columns:</p> imu.csv<pre><code>timestamp, acc_x, acc_y, acc_z, gyro_x, gyro_y, gyro_z\n1110022, 0.0032, 0.001, -0.002, 0.01, 0.005, -0.003\n1111022, 0.0041, 0.002, -0.001, 0.012, 0.006, -0.004\n1112022, 0.0028, 0.0005, -0.003, 0.009, 0.004, -0.002\n</code></pre> <p>The implementation below uses <code>pandas</code> to stream the data, but the logic is compatible with any streaming I/O library.</p> <p>When dealing with massive datasets, we adopt a chunked loading approach for each sensor type.</p> Define the generator functions that yield Message objects.<pre><code>import pandas as pd\nfrom mosaicolabs import (\n    MosaicoClient, # The gateway to the Mosaico Platform\n    OnErrorPolicy, # The error policy for the SequenceWriter\n    Message, # The base class for all data messages\n    IMU, # The IMU sensor data class\n    Vector3d, # The 3D vector class, needed to populate the IMU data\n)\n\ndef stream_imu_from_csv(file_path: str, chunk_size: int = 1000):\n    for chunk in pd.read_csv(file_path, chunksize=chunk_size): # (1)!\n        for row in chunk.itertuples(index=False):\n            try:\n                yield Message(\n                    timestamp_ns=int(row.timestamp),\n                    data=IMU(\n                        acceleration=Vector3d(\n                            x=float(row.acc_x),\n                            y=float(row.acc_y),\n                            z=float(row.acc_z),\n                        ),\n                        angular_velocity=Vector3d(\n                            x=float(row.gyro_x),\n                            y=float(row.gyro_y),\n                            z=float(row.gyro_z),\n                        ),\n                    ),\n                )\n            except Exception:\n                # Yield None only for parsing/type-related errors\n                yield None\n</code></pre> <ol> <li>Use pandas TextFileReader to stream the file in chunks</li> </ol> <p>The Mosaico <code>Message</code> object is an in-memory object wrapping the sensor data with necessary metadata (e.g. timestamp), and ensuring it is ready for serialization and network transmission.</p> <p>In this specific case, the data is an instance of the <code>IMU</code> model. This is a built-in part of the Mosaico default ontology, meaning the platform already understands its schema and how to optimize its storage.</p> <p>For a more in-depth explanation:</p> <ul> <li>Documentation: Data Models &amp; Ontology</li> <li>API Reference: Sensor Models</li> </ul>"},{"location":"SDK/howto/serialized_writing_from_csv/#step-2-orchestrating-the-sequence-upload","title":"Step 2: Orchestrating the Sequence Upload","text":"<p>To write data, we first establish a connection to the Mosaico server via the <code>MosaicoClient.connect()</code> method and create a <code>SequenceWriter</code>. A sequence writer acts as a logical container for related data streams (topics).</p> <p>When initializing your data handling pipeline, it is highly recommended to wrap the <code>MosaicoClient</code> within a <code>with</code> statement. This context manager pattern ensures that underlying network connections and shared resource pools are correctly shut down and released when your operations conclude.</p> Connect to the Mosaico server and create a sequence writer<pre><code>with MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Initialize the Sequence Orchestrator\n    with client.sequence_create(\n        sequence_name=\"csv_ingestion_test\",\n        metadata={\"source\": \"manual_upload\", \"format\": \"csv\"}\n        on_error = OnErrorPolicy.Delete # (1)!\n    ) as swriter:\n        # Step 3 and 4 happen inside this block...\n</code></pre> <ol> <li>Mosaico supports two distinct error policies for sequences: <code>OnErrorPolicy.Delete</code> and <code>OnErrorPolicy.Report</code>.</li> </ol> <p>Context Management</p> <p>It is mandatory to use the <code>SequenceWriter</code> instance returned by <code>client.sequence_create()</code> inside its own <code>with</code> context. The following code will raise an exception:</p> <p><pre><code>swriter = client.sequence_create(\n    sequence_name=\"csv_ingestion_test\",\n    metadata={...},\n) \n# Performing operations using `swriter` will raise an exception\nswriter.topic_create(...) # Raises here\n</code></pre> This choice ensures that the sequence writing orchestrator is closed and cataloged when the block is exited, even if your application encounters a crash or is manually interrupted.</p>"},{"location":"SDK/howto/serialized_writing_from_csv/#sequence-level-error-handling","title":"Sequence-Level Error Handling","text":"<p>The behavior of the orchestrator during a failure is governed by the <code>on_error</code> policy. This is a Last-Resort automated error policy, which dictates how the server manages a sequence if an unhandled exception bubbles up to the <code>SequenceWriter</code> context manager. By default, this is set to <code>OnErrorPolicy.Delete</code>, which signals the server to physically remove the incomplete sequence and its associated topic directories, if any errors occurred. Alternatively, you can specify <code>OnErrorPolicy.Report</code>: in this case, the SDK will not delete the data but will instead send an error notification to the server, allowing the platform to flag the sequence as failed while retaining whatever records were successfully transmitted before the error occurred.</p> <p>For a more in-depth explanation:</p> <ul> <li>Documentation: The Writing Workflow</li> <li>API Reference: Writing Data</li> </ul>"},{"location":"SDK/howto/serialized_writing_from_csv/#step-3-topic-creation","title":"Step 3: Topic Creation","text":"<p>Inside the sequence, we create a Topic Writer, which is assigned to the IMU topic.</p> <pre><code>    with client.sequence_create(...)\n        imu_twriter = swriter.topic_create( # (1)!\n            topic_name=\"sensors/imu\", \n            metadata={\"sensor_id\": \"accel_01\"},\n            ontology_type=IMU,\n        )\n</code></pre> <ol> <li>Here we are creating a dedicated writer for the IMU topic</li> </ol>"},{"location":"SDK/howto/serialized_writing_from_csv/#step-4-pushing-data-into-the-pipeline","title":"Step 4: Pushing Data into the Pipeline","text":"<p>The final stage of the ingestion process involves iterating through your data generators and transmitting records to the Mosaico platform by calling the <code>TopicWriter.push()</code> method for each record. The <code>push()</code> method optimizes the throughput by accumulating messages into internal batches.</p> <pre><code>with client.sequence_create(...)\n    imu_twriter = swriter.topic_create(...)\n\n    for msg in stream_imu_from_csv(\"imu_data.csv\"):\n        if msg is None:\n            # Log and skip, or raise if incomplete data is disallowed\n            print(\"Skipping row due to parsing error\")\n            continue # Ignore malformed records\n        try:\n            imu_twriter.push(message=msg)\n        except Exception as e:\n            # Log and skip, or raise if incomplete data is disallowed\n            print(f\"Error at time: {msg.timestamp_ns}. Inner err: {e}\")\n</code></pre>"},{"location":"SDK/howto/serialized_writing_from_csv/#topic-level-error-management","title":"Topic-Level Error Management","text":"<p>In the code snippet above, we implemented a Controlled Ingestion by wrapping the topic-specific processing and pushing logic within a local <code>try-except</code> block. Because the <code>SequenceWriter</code> cannot natively distinguish which specific topic failed within your custom processing code (such as a coordinate transformation or a malformed CSV row), an unhandled exception will bubble up and trigger the global sequence-level error policy. To avoid this, you should catch errors locally for each topic.</p> <p>Upcoming versions of the SDK will introduce native Topic-Level Error Policies. This feature will allow you to define the error behavior directly when creating the topic, removing the need for boilerplate <code>try-except</code> blocks around every sensor stream.</p>"},{"location":"SDK/howto/serialized_writing_from_csv/#the-full-example-code","title":"The full example code","text":"<pre><code>\"\"\"\nImport the necessary classes from the Mosaico SDK.\n\"\"\"\nimport pandas as pd\nfrom mosaicolabs import (\n    MosaicoClient, # The gateway to the Mosaico Platform\n    OnErrorPolicy, # The error policy for the SequenceWriter\n    Message, # The base class for all data messages\n    IMU, # The IMU sensor data class\n    Vector3d, # The 3D vector class, needed to populate the IMU data\n)\n\n\"\"\"\nDefine the generator functions that yield `Message` objects.\n\"\"\"\ndef stream_imu_from_csv(file_path: str, chunk_size: int = 1000):\n    \"\"\"\n    Efficiently reads a large CSV in chunks to prevent memory exhaustion.\n    \"\"\"\n    # Use pandas TextFileReader to stream the file in chunks\n    for chunk in pd.read_csv(file_path, chunksize=chunk_size):\n        for row in chunk.itertuples(index=False):\n            try:\n                yield Message(\n                    timestamp_ns=int(row.timestamp),\n                    data=IMU(\n                        acceleration=Vector3d(\n                            x=float(row.acc_x),\n                            y=float(row.acc_y),\n                            z=float(row.acc_z),\n                        ),\n                        angular_velocity=Vector3d(\n                            x=float(row.gyro_x),\n                            y=float(row.gyro_y),\n                            z=float(row.gyro_z),\n                        ),\n                    ),\n                )\n            except Exception:\n                # Yield None only for parsing/type-related errors\n                yield None\n\n\"\"\"\nMain ingestion orchestration\n\"\"\"\ndef main():\n    with MosaicoClient.connect(\"localhost\", 6726) as client:\n        # Initialize the Sequence Orchestrator\n        with client.sequence_create(\n            sequence_name=\"csv_ingestion_test\",\n            metadata={\"source\": \"manual_upload\", \"format\": \"csv\"}\n            on_error = OnErrorPolicy.Delete # Default\n        ) as swriter:\n            # Create a dedicated writer for the IMU topic\n            imu_twriter = swriter.topic_create(\n                topic_name=\"sensors/imu\", \n                metadata={\"sensor_id\": \"accel_01\"},\n                ontology_type=IMU,\n            )\n\n            # --- Push IMU Data ---\n            for msg in stream_imu_from_csv(\"imu.csv\"):\n                if msg is None:\n                    # Log and skip, or raise if incomplete data is disallowed\n                    print(\"Skipping row due to parsing error\")\n                    continue # Ignore malformed records\n                try:\n                    imu_twriter.push(message=msg)\n                except Exception as e:\n                    # Log and skip, or raise if incomplete data is disallowed\n                    print(f\"Error processing IMU at time: {msg.timestamp_ns}. Inner err: {e}\")\n\n        # All buffers are flushed and the sequence is committed when exiting the SequenceWriter 'with' block\n        print(\"Successfully injected data from CSV into Mosaico!\")\n\n    # Here the `MosaicoClient` context and all connections are closed\n</code></pre>"},{"location":"SDK/howto/serialized_writing_from_multi_csv/","title":"Writing Multiple Topics Serially","text":"<p>This guide demonstrates how to ingest data from multiple custom files into the Mosaico Data Platform. While the logic below uses CSV files as the primary example, the SDK's modular design is compatible with any file format (JSON, Parquet, binary) and any I/O library.</p> <p>You will learn how to use the Mosaico SDK to:</p> <ul> <li>Open a connection to the Mosaico server.</li> <li>Creating a sequence.</li> <li>Creating topics.</li> <li>Pushing data into topics, via Controlled Ingestion Patterns to prevent a single file failure from aborting the entire upload.</li> </ul>"},{"location":"SDK/howto/serialized_writing_from_multi_csv/#step-1-chunked-loading-for-heterogeneous-data","title":"Step 1: Chunked Loading for Heterogeneous Data","text":"<p>The following implementation defines three distinct generators to stream IMU, GPS, and Pressure data. In this example, we assume our CSV files contain the following columns:</p> imu.csv<pre><code>timestamp, acc_x, acc_y, acc_z, gyro_x, gyro_y, gyro_z\n1110022, 0.0032, 0.001, -0.002, 0.01, 0.005, -0.003\n</code></pre> gps.csv<pre><code>timestamp, latitude, longitude, altitude, status, service\n1110022, 45.123456, -93.123456, 250.0, 1, 1\n</code></pre> pressure.csv<pre><code>timestamp, pressure\n1110022, 101325.0\n</code></pre> <p>When dealing with massive datasets spread across multiple files, we adopt a chunked loading approach for each sensor type.</p> Define the generator functions that yield Message objects<pre><code>import pandas as pd\nfrom mosaicolabs import (\n    MosaicoClient, # The gateway to the Mosaico Platform\n    OnErrorPolicy, # The error policy for the SequenceWriter\n    Message, # The base class for all data messages\n    IMU, # The IMU sensor data class\n    Vector3d, # The 3D vector class, needed to populate the IMU and GPS data\n    GPS, # The GPS sensor data class\n    GPSStatus, # The GPS status enum, needed to populate the GPS data\n    Pressure, # The Pressure sensor data class\n)\n\n\n# Define the generator functions that yield `Message` objects.\n# For each file, open the reading process and yield the messages one by one.\n\n\ndef stream_imu_from_csv(file_path: str, chunk_size: int = 1000):\n    for chunk in pd.read_csv(file_path, chunksize=chunk_size):\n        for row in chunk.itertuples(index=False):\n            yield Message(\n                timestamp_ns=int(row.timestamp),\n                data=IMU(\n                    acceleration=Vector3d(\n                        x=float(row.acc_x),\n                        y=float(row.acc_y),\n                        z=float(row.acc_z),\n                    ),\n                    angular_velocity=Vector3d(\n                        x=float(row.gyro_x),\n                        y=float(row.gyro_y),\n                        z=float(row.gyro_z),\n                    )\n                )\n            )\n\n\n\ndef stream_gps_from_csv(file_path: str, chunk_size: int = 1000):\n    for chunk in pd.read_csv(file_path, chunksize=chunk_size):\n        for row in chunk.itertuples(index=False):            \n            yield Message(\n                timestamp_ns=int(row.timestamp),\n                data=GPS(\n                    position=Vector3d(\n                        x=float(row.latitude),\n                        y=float(row.longitude),\n                        z=float(row.altitude),\n                    ),\n                    status=GPSStatus(\n                        status=int(row.status), \n                        service=int(row.service),\n                    )\n                )\n            )\n\n\ndef stream_pressure_from_csv(file_path: str, chunk_size: int = 1000):\n    for chunk in pd.read_csv(file_path, chunksize=chunk_size):\n        for row in chunk.itertuples(index=False):\n            yield Message(\n                timestamp_ns=int(row.timestamp),\n                data=Pressure(value=row.pressure)\n            )\n</code></pre>"},{"location":"SDK/howto/serialized_writing_from_multi_csv/#understanding-the-output","title":"Understanding the Output","text":"<p>The Mosaico <code>Message</code> object is an in-memory object wrapping the sensor data with necessary metadata (e.g. timestamp), and ensuring it is ready for serialization and network transmission.</p> <p>In this specific case, the data are instances of the <code>IMU</code>, <code>GPS</code> and <code>Pressure</code> models. These are built-in parts of the Mosaico default ontology, meaning the platform already understands their schema and how to optimize their storage.</p> <p>For a more in-depth explanation:</p> <ul> <li>Documentation: Data Models &amp; Ontology</li> <li>API Reference: Sensor Models</li> </ul>"},{"location":"SDK/howto/serialized_writing_from_multi_csv/#step-2-orchestrating-the-multi-topic-sequence","title":"Step 2: Orchestrating the Multi-Topic Sequence","text":"<p>To write data, we first establish a connection to the Mosaico server via the <code>MosaicoClient.connect()</code> method and create a <code>SequenceWriter</code>. A sequence writer acts as a logical container for related sensor data streams (topics).</p> <p>When initializing your data handling pipeline, it is highly recommended to wrap the Mosaico Client within a <code>with</code> statement. This context manager pattern ensures that underlying network connections and shared resource pools are correctly shut down and released when your operations conclude.</p> Connect to the Mosaico server and create a sequence writer<pre><code>with MosaicoClient.connect(\"localhost\", 6726) as client:\n    with client.sequence_create(\n        sequence_name=\"multi_sensor_ingestion\",\n        metadata={\"mission\": \"alpha_test\", \"environment\": \"laboratory\"},\n        on_error=OnErrorPolicy.Delete # (1)!\n    ) as swriter:\n        # Steps 3 and 4 (Topic Creation &amp; serial Pushing) happen here...\n</code></pre> <ol> <li>Mosaico supports two distinct error policies for sequences: <code>OnErrorPolicy.Delete</code> and <code>OnErrorPolicy.Report</code>.</li> </ol> <p>Context Management</p> <p>It is mandatory to use the <code>SequenceWriter</code> instance returned by <code>client.sequence_create()</code> inside its own <code>with</code> context. The following code will raise an exception:</p> <p><pre><code>swriter = client.sequence_create(\n    sequence_name=\"multi_sensor_ingestion\",\n    metadata={...},\n) \n# Performing operations using `swriter` will raise an exception\nswriter.topic_create(...) # Raises here\n</code></pre> This choice ensures that the sequence writing orchestrator is closed and cataloged when the block is exited, even if your application encounters a crash or is manually interrupted.</p>"},{"location":"SDK/howto/serialized_writing_from_multi_csv/#sequence-level-error-handling","title":"Sequence-Level Error Handling","text":"<p>The behavior of the orchestrator during a failure is governed by the <code>on_error</code> policy. This is a Last-Resort automated error policy, which dictates how the server manages a sequence if an unhandled exception bubbles up to the <code>SequenceWriter</code> context manager. By default, this is set to <code>OnErrorPolicy.Delete</code>, which signals the server to physically remove the incomplete sequence and its associated topic directories, if any errors occurred. Alternatively, you can specify <code>OnErrorPolicy.Report</code>: in this case, the SDK will not delete the data but will instead send an error notification to the server, allowing the platform to flag the sequence as failed while retaining whatever records were successfully transmitted before the error occurred.</p> <p>For a more in-depth explanation:</p> <ul> <li>Documentation: The Writing Workflow</li> <li>API Reference: Writing Data</li> </ul>"},{"location":"SDK/howto/serialized_writing_from_multi_csv/#step-3-topic-creation-and-resource-allocation","title":"Step 3: Topic Creation and Resource Allocation","text":"<p>Inside the sequence, we create individual Topic Writers to manage data streams. Each writer is an independent \"lane\" assigned its own internal buffer and background thread for serialization.</p> <pre><code>with client.sequence_create(...) as swriter:\n\n    # Create dedicated Topic Writers for each sensor stream\n    imu_twriter = swriter.topic_create( # (1)!\n        topic_name=\"sensors/imu\",\n        metadata={\"sensor_id\": \"accel_01\"},\n        ontology_type=IMU,\n    )\n\n    gps_twriter = swriter.topic_create( # (2)!\n        topic_name=\"sensors/gps\",\n        metadata={\"sensor_id\": \"gps_01\"},\n        ontology_type=GPS,\n    )\n\n    pressure_twriter = swriter.topic_create( # (3)!\n        topic_name=\"sensors/pressure\",\n        metadata={\"sensor_id\": \"pressure_01\"},\n        ontology_type=Pressure,\n    )\n</code></pre> <ol> <li>Here we are creating a dedicated writer for the IMU topic</li> <li>Here we are creating a dedicated writer for the GPS topic</li> <li>Here we are creating a dedicated writer for the Pressure topic</li> </ol>"},{"location":"SDK/howto/serialized_writing_from_multi_csv/#step-4-pushing-data-into-the-pipeline","title":"Step 4: Pushing Data into the Pipeline","text":"<p>The final stage of the ingestion process involves iterating through your data generators and transmitting records to the Mosaico platform by calling the <code>TopicWriter.push()</code> method for each record. The <code>push()</code> method optimizes the throughput by accumulating messages into internal batches.</p> <pre><code>        # 1. Push IMU Data\n        for msg in stream_imu_from_csv(\"imu.csv\"):\n            if msg is None:\n                # Log and skip, or raise if incomplete data is disallowed\n                print(\"Skipping row due to parsing error\")\n                continue # Ignore malformed records\n            try:\n                imu_twriter.push(message=msg)\n            except Exception as e:\n                # Log and skip, or raise if incomplete data is disallowed\n                print(f\"Error processing IMU at time: {msg.timestamp_ns}. Inner err: {e}\")\n\n        # 2. Push GPS Data with Custom Processing\n        for msg in stream_gps_from_csv(\"gps.csv\"):\n            if msg is None:\n                # Log and skip, or raise if incomplete data is disallowed\n                print(\"Skipping row due to parsing error\")\n                continue # Ignore malformed records\n            try:\n                # This custom processing might fail\n                process_gps_message(msg) \n                gps_twriter.push(message=msg)\n            except Exception as e:\n                # Log and skip, or raise if incomplete data is disallowed\n                print(f\"Error processing GPS at time: {msg.timestamp_ns}. Inner err: {e}\")\n\n        # 3. Push Pressure Data\n        for msg in stream_pressure_from_csv(\"pressure.csv\"):\n            if msg is None:\n                # Log and skip, or raise if incomplete data is disallowed\n                print(\"Skipping row due to parsing error\")\n                continue # Ignore malformed records\n            try:\n                pressure_twriter.push(message=msg)\n            except Exception as e:\n                # Log and skip, or raise if incomplete data is disallowed\n                print(f\"Error processing pressure at time: {msg.timestamp_ns}. Inner err: {e}\")\n</code></pre>"},{"location":"SDK/howto/serialized_writing_from_multi_csv/#topic-level-error-management","title":"Topic-Level Error Management","text":"<p>In the code snippet above, we implemented a Controlled Ingestion by wrapping the topic-specific processing and pushing logic within a local <code>try-except</code> block. Because the <code>SequenceWriter</code> cannot natively distinguish which specific topic failed within your custom processing code (such as a coordinate transformation or a malformed CSV row), an unhandled exception will bubble up and trigger the global sequence-level error policy. To avoid this, you should catch errors locally for each topic.</p> <p>Upcoming versions of the SDK will introduce native Topic-Level Error Policies. This feature will allow you to define the error behavior directly when creating the topic, removing the need for boilerplate <code>try-except</code> blocks around every sensor stream.</p>"},{"location":"SDK/howto/serialized_writing_from_multi_csv/#the-full-example-code","title":"The full example code","text":"<pre><code>\"\"\"\nImport the necessary classes from the Mosaico SDK.\n\"\"\"\nimport pandas as pd\nfrom mosaicolabs import (\n    MosaicoClient, # The gateway to the Mosaico Platform\n    OnErrorPolicy, # The error policy for the SequenceWriter\n    Message, # The base class for all data messages\n    IMU, # The IMU sensor data class\n    Vector3d, # The 3D vector class, needed to populate the IMU and GPS data\n    GPS, # The GPS sensor data class\n    GPSStatus, # The GPS status enum, needed to populate the GPS data\n    Pressure, # The Pressure sensor data class\n)\n\n\"\"\"\nDefine the generator functions that yield `Message` objects.\nFor each file, open the reading process and yield the messages one by one.\n\"\"\"\ndef stream_imu_from_csv(file_path: str, chunk_size: int = 1000):\n    \"\"\"Efficiently streams IMU data.\"\"\"\n    for chunk in pd.read_csv(file_path, chunksize=chunk_size):\n        for row in chunk.itertuples(index=False):\n            try:\n                yield Message(\n                    timestamp_ns=int(row.timestamp),\n                    data=IMU(\n                        acceleration=Vector3d(\n                            x=float(row.acc_x),\n                            y=float(row.acc_y),\n                            z=float(row.acc_z),\n                        ),\n                        angular_velocity=Vector3d(\n                            x=float(row.gyro_x),\n                            y=float(row.gyro_y),\n                            z=float(row.gyro_z),\n                        )\n                    )\n                )\n            except Exception:\n                # Yield None only for parsing/type-related errors\n                yield None\n\n\ndef stream_gps_from_csv(file_path: str, chunk_size: int = 1000):\n    \"\"\"Efficiently streams GPS data.\"\"\"\n    for chunk in pd.read_csv(file_path, chunksize=chunk_size):\n        for row in chunk.itertuples(index=False):\n            try:\n                yield Message(\n                    timestamp_ns=int(row.timestamp),\n                    data=GPS(\n                        position=Vector3d(\n                            x=float(row.latitude),\n                            y=float(row.longitude),\n                            z=float(row.altitude),\n                        ),\n                        status=GPSStatus(\n                            status=int(row.status), \n                            service=int(row.service),\n                        )\n                    )\n                )\n\n            except Exception:\n                # Yield None only for parsing/type-related errors\n                yield None\n\ndef stream_pressure_from_csv(file_path: str, chunk_size: int = 1000):\n    \"\"\"Efficiently streams Barometric Pressure data.\"\"\"\n    for chunk in pd.read_csv(file_path, chunksize=chunk_size):\n        for row in chunk.itertuples(index=False):\n            try:\n                yield Message(\n                    timestamp_ns=int(row.timestamp),\n                    data=Pressure(value=row.pressure)\n                )\n            except Exception:\n                # Yield None only for parsing/type-related errors\n                yield None\n\n\"\"\"\nMain ingestion orchestration\n\"\"\"\ndef main():\n    with MosaicoClient.connect(\"localhost\", 6726) as client:\n        # Initialize the Orchestrator for the entire mission\n        with client.sequence_create(\n            sequence_name=\"multi_sensor_ingestion\",\n            metadata={\"mission\": \"alpha_test\", \"environment\": \"laboratory\"},\n            on_error=OnErrorPolicy.Delete # Deletes the whole sequence if a fatal crash occurs\n        ) as swriter:\n            # Create dedicated Topic Writers for each sensor stream\n            imu_twriter = swriter.topic_create(\n                topic_name=\"sensors/imu\",\n                metadata={\"sensor_id\": \"accel_01\"},\n                ontology_type=IMU,\n            )\n\n            gps_twriter = swriter.topic_create(\n                topic_name=\"sensors/gps\",\n                metadata={\"sensor_id\": \"gps_01\"},\n                ontology_type=GPS,\n            )\n\n            pressure_twriter = swriter.topic_create(\n                topic_name=\"sensors/pressure\",\n                metadata={\"sensor_id\": \"pressure_01\"},\n                ontology_type=Pressure,\n            )\n\n            # --- 1. Push IMU Data ---\n            for msg in stream_imu_from_csv(\"imu.csv\"):\n                if msg is None:\n                    # Log and skip, or raise if incomplete data is disallowed\n                    print(\"Skipping row due to parsing error\")\n                    continue # Ignore malformed records\n                try:\n                    imu_twriter.push(message=msg)\n                except Exception as e:\n                    # Log and skip, or raise if incomplete data is disallowed\n                    print(f\"Error processing IMU at time: {msg.timestamp_ns}. Inner err: {e}\") \n\n            # --- 2. Push GPS Data with Custom Processing ---\n            for msg in stream_gps_from_csv(\"gps.csv\"):\n                if msg is None:\n                    # Log and skip, or raise if incomplete data is disallowed\n                    print(\"Skipping row due to parsing error\")\n                    continue # Ignore malformed records\n                try:\n                    # This custom processing might fail\n                    process_gps_message(msg) \n                    gps_twriter.push(message=msg)\n                except Exception as e:\n                    # Log and skip, or raise if incomplete data is disallowed\n                    print(f\"Error processing GPS at time: {msg.timestamp_ns}. Inner err: {e}\")\n\n            # --- 3. Push Pressure Data ---\n            for msg in stream_pressure_from_csv(\"pressure.csv\"):\n                if msg is None:\n                    # Log and skip, or raise if incomplete data is disallowed\n                    print(\"Skipping row due to parsing error\")\n                    continue # Ignore malformed records\n                try:\n                    pressure_twriter.push(message=msg)\n                except Exception as e:\n                    # Log and skip, or raise if incomplete data is disallowed\n                    print(f\"Error processing pressure at time: {msg.timestamp_ns}. Inner err: {e}\")\n\n        # All buffers are flushed and the sequence is committed when exiting the SequenceWriter 'with' block\n        print(\"Multi-topic ingestion completed!\")\n</code></pre>"},{"location":"SDK/howto/streaming/","title":"Streaming Data from Sequences and Topics","text":"<p>Prerequisites</p> <p>To fully grasp the following How-To, we recommend you to read the Reading a Sequence and its Topics How-To.</p> <p>This guide demonstrates how to interact with the Mosaico Data Platform to retrieve the data stream that has been previously ingested. You will learn how to use the Mosaico SDK to:</p> <ul> <li>Obtain a <code>SequenceDataStreamer</code> to consume recordings from a sequence.</li> <li>Obtain a <code>TopicDataStreamer</code> to consume recordings from a topic.</li> </ul> <p>For a more in-depth explanation:</p> <ul> <li>Documentation: The Reading Workflow</li> <li>API Reference: Data Retrieval</li> </ul>"},{"location":"SDK/howto/streaming/#unified-multi-sensor-replay","title":"Unified Multi-Sensor Replay","text":"<p>A <code>SequenceDataStreamer</code> is designed for sensor fusion and full-system replay. It allows you to consume synchronized multiple data streams\u2014such as high-rate IMU data and low-rate GPS fixes\u2014as if they were a single, coherent timeline.</p> <pre><code>from mosaicolabs import MosaicoClient \n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    seq_handler = client.sequence_handler(\"mission_alpha\")\n\n    if seq_handler:\n        # Initialize a Unified Stream for synchronized multi-sensor analysis\n        streamer = seq_handler.get_data_streamer(\n            # Filter specific topics\n            topics=[\"/gps\", \"/imu\"],\n            # Define the optional temporal window: Only data in this range will be streamed\n            start_timestamp_ns=1738508778000000000,\n            end_timestamp_ns=1738509618000000000,\n        )\n\n\n        print(f\"Streaming starts at: {streamer.next_timestamp()}\")\n\n        # Consume the stream. The loop yields messages from both topics in perfect chronological order\n        for topic, msg in streamer:\n            print(f\"[{topic}] at {msg.timestamp_ns}: {type(msg.data).__name__}\")\n\n        # Finalize the reading channel to release server resources\n        seq_handler.close()\n</code></pre>"},{"location":"SDK/howto/streaming/#targeted-access","title":"Targeted Access","text":"<p>A <code>TopicDataStreamer</code> provides a dedicated channel for interacting with a single data resource.</p> <pre><code>from mosaicolabs import MosaicoClient, IMU\n\nwith MosaicoClient.connect(\"localhost\", 6726) as client:\n    # Access a specific topic handler directly via the client\n    top_handler = client.topic_handler(\"mission_alpha\", \"/front/imu\")\n\n    if top_handler:\n        # Start a Targeted Stream for isolated, low-overhead replay\n        imu_stream = top_handler.get_data_streamer(\n            # Define the optional temporal window: Only data in this range will be streamed\n            start_timestamp_ns=1738508778000000000,\n            end_timestamp_ns=1738509618000000000,\n        )\n\n        # Query the next timestamp, without consuming the message\n        print(f\"First sample at: {imu_stream.next_timestamp()}\")\n\n        # Direct loop for maximum efficiency\n        for imu_msg in imu_stream:\n            # Access the strongly-typed IMU data directly\n            process_sample(imu_msg.get_data(IMU)) \n\n        # Finalize the topic channel\n        top_handler.close()\n</code></pre>"},{"location":"SDK/howto/streaming/#streamer-comparison","title":"Streamer Comparison","text":"Feature <code>SequenceDataStreamer</code> <code>TopicDataStreamer</code> Primary Use Case Multi-sensor fusion &amp; system-wide replay Isolated sensor analysis &amp; ML training Logic Overhead K-Way Merge Sorting Direct Stream Output Type Tuple of <code>(topic_name, message)</code> Single <code>message</code> object Temporal Slicing Supported Supported"},{"location":"daemon/","title":"Backend Overview","text":"<p>The Mosaico Daemon, a.k.a. <code>mosaicod</code>, acts as engine of the data platform. Developed in Rust, it is engineered to be the high-performance arbiter for all data interactions, guaranteeing that every byte of robotics data is strictly typed, atomically stored, and efficiently retrievable.</p> <p>It functions on a standard client-server model, mediating between your high-level applications (via the SDKs) and the low-level storage infrastructure.</p>"},{"location":"daemon/#architectural-design","title":"Architectural Design","text":"<p><code>mosaicod</code> is architected atop the Apache Arrow Flight protocol. Apache Arrow Flight is a general-purpose, high-performance client-server framework developed for the exchange of massive datasets. It operates directly on Apache Arrow columnar data, enabling efficient transport over gRPC without the overhead of serialization.</p> <p>Unlike traditional REST APIs which serialize data into text-based JSON, Flight is designed specifically for high-throughput data systems. This architectural choice provides Mosaico with three critical advantages:</p> <p>Zero-Copy Serialization. Data is transmitted in the Arrow columnar format, the exact same format used in-memory by modern analytics tools like pandas and Polars. This eliminates the CPU-heavy cost of serializing and deserializing data at every hop.</p> <p>Parallelized Transport. Operations are not bound to a single pipe; data transfer can be striped across multiple connections to saturate available bandwidth.</p> <p>Snapshot-Based Schema Enforcement. Data types are not guessed, nor are they forced into a rigid global model. Instead, the protocol enforces a rigorous schema handshake that validates data against a specific schema snapshot stored with the sequence.</p>"},{"location":"daemon/#resource-addressing","title":"Resource Addressing","text":"<p>Mosaico treats every entity in the system, whether it's a Sequence or a Topic, as a uniquely addressable resource. These resources are identified by a Resource Locator, a uniform logical path that remains consistent across all channels. </p> <p>Mosaico uses two types of resource locators:</p> <ul> <li>A Sequence Locator identifies a recording session by its sequence name (e.g., <code>run_2023_01</code>).</li> <li>A Topic Locator identifies a specific data stream using a hierarchical path that includes the sequence name and topic path (e.g., <code>run_2023_01/sensors/lidar_front</code>).</li> </ul>"},{"location":"daemon/#flight-endpoints","title":"Flight Endpoints","text":"<p>The daemon exposes Apache Arrow Flight endpoints that handle various operations using Flight's core methods: <code>list_flights</code> and <code>get_flight_info</code> for discovery and metadata management, <code>do_put</code> for high-speed data ingestion, and <code>do_get</code> for efficient data retrieval.  This design ensures administrative operations don't interfere with data throughput while maintaining low-latency columnar data access.</p>"},{"location":"daemon/#storage-architecture","title":"Storage Architecture","text":"<p><code>mosaicod</code> uses a database to perform fast queries on metadata, manage system state such as sequence and topic definitions, and handle the event queue for processing asynchronous tasks like background data processing or notifications. An object store (such as S3, MinIO, or local filesystem) provides long-term storage for resilience and durability, holding the bulk sensor data, images, point clouds, and immutable schema snapshots that define data structures.</p> <p>Database Durability and Recovery</p> <p>The database state is entirely transient and can be fully reconstructed from the object store. This also enables importing data from other stores. </p> <p>Currently, there is no way to import data and reconstruct the database, but we are designing the system to enable this feature in future releases. </p> <p>If the metadata database is corrupted or destroyed, <code>mosaicod</code> can rebuild the entire catalog by rescanning the durable object storage. This design ensures that while the database provides performance, the store guarantees long-term durability and recovery, protecting your data against catastrophic infrastructure failure.</p>"},{"location":"daemon/actions/","title":"Custom Actions","text":"<p>Mosaico implements its own administrative protocols directly on top of Apache Arrow Flight. Rather than relying on a separate control channel abstraction, Mosaico leverages the Flight <code>DoAction</code> RPC mechanism to handle discrete lifecycle events, administrative interfaces, and resource management.</p> <p>Unlike streaming endpoints designed for continuous data throughput, these custom actions manage the platform's overarching state. While individual calls are synchronous, they often initiate or conclude multi-step processes, such as topic upload, that govern the long-term integrity of data within the platform.</p> <p>All custom actions follow a standardized pattern: they expect a JSON-serialized payload defining the request parameters and return a JSON-serialized response containing the result.</p>"},{"location":"daemon/actions/#sequence-management","title":"Sequence Management","text":"<p>Sequences are the fundamental containers for data recordings in Mosaico. These custom actions enforce a strict lifecycle state machine to guarantee data integrity.</p> Action Description <code>sequence_create</code> Initializes a new, empty sequence. It generates and returns a unique key (UUID). This key acts as a write token, authorizing subsequent data ingestion into this specific sequence. This avoids concurrent access and creation issues when multiple clients attempt to create sequences simultaneously. <code>sequence_finalize</code> Transitions a sequence from uploading to archived. This action locks the sequence, marking it as immutable. Once finalized, no further data can be added or modified, ensuring a perfect audit trail. <code>sequence_abort</code> A cleanup operation for failed uploads. It discards a sequence that is currently being uploaded, purging any partial data from the storage to prevent zombie records. <code>sequence_delete</code> Permanently removes a sequence from the platform. To protect data lineage, this is typically permitted only on unlocked (incomplete) sequences."},{"location":"daemon/actions/#topic-management","title":"Topic Management","text":"<p>Topics represent the individual sensor streams (e.g., <code>camera/front</code>, <code>gps</code>) contained within a sequence.</p> Action Description <code>topic_create</code> Registers a new topic. <code>topic_delete</code> Removes a specific topic from a sequence, permitted only if the parent sequence is still unlocked."},{"location":"daemon/actions/#notification-system","title":"Notification System","text":"<p>The platform includes a tagging mechanism to attach alerts or informational messages to resources. For example, if an exception is raised during an upload, the notification system automatically registers the event, ensuring the failure is logged and visible for troubleshooting.</p> Action Description <code>*_notify_create</code> Attaches a notification to a Sequence or Topic, such as logging an error or status update. <code>*_notify_list</code> Retrieves the history of active notifications for a resource, allowing clients to review alerts. <code>*_notify_purge</code> Clears the notification history for a resource, useful for cleanup after resolution. <p>Here, <code>*</code> can be either <code>sequence</code> or <code>topic</code>.</p>"},{"location":"daemon/actions/#query","title":"Query","text":"Action Description <code>query</code> This action serves as the gateway to the query system. It accepts a complex filter object and returns a list of resources that match the criteria."},{"location":"daemon/cli/","title":"CLI Reference","text":""},{"location":"daemon/cli/#run","title":"Run","text":"<p>Start the server locally with verbose logging:</p> <pre><code>mosaicod run [OPTIONS]\n</code></pre> Option Default Description <code>--host</code> <code>false</code> Listen on all addresses, including LAN and public addresses. <code>--port &lt;PORT&gt;</code> <code>6726</code> Port to listen on. <code>--local-store &lt;PATH&gt;</code> <code>None</code> Enable storage of objects on the local filesystem at the specified directory path."},{"location":"daemon/ingestion/","title":"Ingestion","text":"<p>Data ingestion in Mosaico is handled by the Flight <code>DoPut</code> streaming endpoint.  This channel is explicitly engineered to handle write-heavy workloads, enabling the system to absorb high-bandwidth sensor data, such as 4K video streams or high-frequency Lidar point clouds\u2014without contending with administrative traffic.</p>"},{"location":"daemon/ingestion/#the-ingestion-protocol","title":"The Ingestion Protocol","text":"<p>Data ingestion follows a structured protocol to ensure type safety and proper sequencing. The process begins with creating a new sequence using <code>sequence_create</code>, which takes a sequence name and optional user metadata, returning a unique sequence UUID.</p> <p>Within this sequence, you create topics for each data stream via <code>topic_create</code>, associating them with the sequence UUID and assigning unique paths like <code>my_sequence/topic/1</code>. Each topic can also include its own metadata. For each topic, data is uploaded using the Flight <code>do_put</code> operation, starting with an Arrow schema for validation, followed by streaming <code>RecordBatch</code> payloads.</p> <p>Once all topics are uploaded, the sequence is finalized with <code>sequence_finalize</code>, committing it to make the data immutable and queryable. During this process, the server validates schemas against registered ontologies, chunks data for efficient storage, and computes indices for fast querying.</p> Ingestion protocol in pseudo-code<pre><code>sq_uuid = do_action&lt;sequence_create&gt;(\"my_sequence\", metadata)\n\n# Create topic and upload data\nt1_uuid = do_action&lt;topic_create&gt;(sq_uuid, \"my_sequence/topic/1\", metadata) # (1)!\ndo_put(t1_uuid, data_stream) \n\ndo_action&lt;sequence_finalize&gt;(sq_uuid) # (2)!\n</code></pre> <ol> <li>The <code>topic_create</code> action returns a UUID that must be passed to the <code>do_put</code> call.</li> <li>During finalization, all resources are consolidated and locked. Alternatively, you can call <code>sequence_abort(sq_uuid)</code>.</li> </ol> <p>Why UUIDs?</p> <p>UUIDs are employed in the ingestion protocol to prevent contentious uploads of the same resources. For instance, if two users attempt to create a new resource (such as a sequence or topic) with the same name, only one will succeed and receive a UUID. This UUID is then used in subsequent calls to ensure that operations are performed by the user who successfully created the resource.</p>"},{"location":"daemon/ingestion/#chunking-indexing-strategy","title":"Chunking &amp; Indexing Strategy","text":"<p>The backend automatically manages chunking to efficiently handle intra-sequence queries and prevent memory overload from streaming data. As data streams in, the server buffers the incoming data until a full chunk is accumulated, then writes it to disk as an optimal storage unit called a chunk.</p> <p>For each chunk written to disk, the server calculates and stores skip indices in the metadata database. These indices include ontology-specific statistics, such as type-specific metadata (e.g., coordinate bounding boxes for GPS data or value ranges for sensors). This allows the query engine to perform content-based filtering without needing to read the entire bulk data.</p>"},{"location":"daemon/install/","title":"Setup","text":"<p>For rapid prototyping, we provide a Docker Compose configuration. This sets up a volatile environment that includes both the Mosaico server and a PostgreSQL database.</p> <p><pre><code># Navigate to the quick start directory form the root folder\ncd docker/quick_start\n# Startup the infra in background\ndocker compose up -d\n</code></pre> This launches PostgreSQL on port <code>5432</code> and <code>mosaicod</code> on its default port <code>6726</code></p> <p>Volatile storage</p> <p>The default Mosaico configuration uses non persistent storage. This means that if the container is destroyed, all stored data will be lost. Since Mosaico is still under active development, we provide this simple, volatile setup by default. For persistent storage, the standard <code>compose.yml</code> file can be easily extended to utilize a Docker volume.</p>"},{"location":"daemon/install/#building-from-source","title":"Building from Source","text":"<p>To build Mosaico for production, you need a Rust toolchain. Mosaico uses <code>sqlx</code> for compile-time query verification, which typically requires a live database connection. However, we support an offline build mode using cached metadata (<code>.sqlx</code> folder).</p>"},{"location":"daemon/install/#offline-build-recommended","title":"Offline Build - Recommended","text":"<p><pre><code>SQLX_OFFLINE=true cargo build --release\n</code></pre> The binary will be located at <code>target/release/mosaicod</code>.</p>"},{"location":"daemon/install/#live-migrations","title":"Live Migrations","text":"<p>If you need to modify the database schema, a running PostgreSQL instance is required. This allows <code>sqlx</code> to verify queries against a live database during compilation. You can use the provided Docker Compose file in <code>docker/devel</code> which sets up an instance of MinIO and a PostgreSQL database.</p> <p>First, start the development environment. From inside the <code>docker/devel</code> directory, run: <pre><code># Start the services in the background\ndocker compose up -d\n\n# To stop and remove the volumes (which clears all data), run:\ndocker compose down -v\n</code></pre></p> <p>Next, from the root of the <code>mosaicod</code> workspace, install the necessary tools, configure the environment, and run the build. <pre><code># Install the SQLx command-line tool\ncargo install sqlx-cli\n\n# Copy the development environment variables for the database connection\ncp env.devel .env\n\n# Apply the database migrations\ncargo sqlx migrate run \n\n# Finally, compile the project\ncargo build --release\n</code></pre></p>"},{"location":"daemon/install/#configuration","title":"Configuration","text":"<p>The server supports S3-compatible object storage by default but can be configured for local storage via command line options.</p>"},{"location":"daemon/install/#database","title":"Database","text":"<p>Mosaico requires a connection to a running PostgreSQL instance, which is defined via the <code>MOSAICO_REPOSITORY_DB_URL</code> environment variable.</p>"},{"location":"daemon/install/#remote-storage-configuration","title":"Remote Storage Configuration","text":"<p>For production deployments, <code>mosaicod</code> should be configured to use an S3-compatible object store (such as AWS S3, Google Cloud Storage, Hetzner Object Store, etc) for durable, long-term storage. This is configured through the following environment variables:</p> Environment Variable Description <code><code>MOSAICO_STORE_BUCKET</code></code> The name of the S3 bucket where Mosaico will store all data blobs. This bucket must be created before starting the server. <code><code>MOSAICO_STORE_ENDPOINT</code></code> The full URL endpoint for the S3-compatible service. This is necessary for non-AWS providers (e.g., <code>http://localhost:9000</code> for a local MinIO instance). <code><code>MOSAICO_STORE_ACCESS_KEY</code></code> The access key ID for authenticating with your object storage service. <code><code>MOSAICO_STORE_SECRET_KEY</code></code> The secret access key that corresponds to the provided access key ID, used for authentication."},{"location":"daemon/install/#local-storage-configuration","title":"Local Storage Configuration","text":"<p>This command will start a <code>mosaicod</code> instance using the local filesystem as storage layer.  <pre><code>mosaicod run --local-store /tmp/mosaicod\n</code></pre></p>"},{"location":"daemon/query/","title":"Queries","text":"<p>Mosaico distinguishes itself from simple file stores with a powerful Query System capable of filtering data based on both high-level metadata and content values. The query engine operates through the <code>query</code> action, accepting structured JSON-based filter expressions that can span the entire data hierarchy.</p>"},{"location":"daemon/query/#query-architecture","title":"Query Architecture","text":"<p>The query engine is designed around a three-tier filtering model that allows you to construct complex, multi-dimensional searches:</p> <p>Sequence Filtering. Target recordings by structural attributes like sequence name, creation timestamp, or user-defined metadata tags. This level allows you to narrow down which recording sessions are relevant to your search.</p> <p>Topic Filtering. Refine your search to specific data streams within sequences. You can filter by topic name, ontology tag (the data type), serialization format, or topic-level user metadata.</p> <p>Ontology Filtering. Query the actual physical values recorded inside the sensor data without scanning terabytes of files. The engine leverages statistical indices computed during ingestion, min/max bounds stored in the metadata cache for each chunk, to rapidly include or exclude entire segments of data.</p>"},{"location":"daemon/query/#filter-domains","title":"Filter Domains","text":""},{"location":"daemon/query/#sequence-filter","title":"Sequence Filter","text":"<p>The sequence filter allows you to target specific recording sessions based on their metadata:</p> Field Description <code>sequence.name</code> The sequence identifier (supports text operations) <code>sequence.creation</code> The creation timestamp in nanoseconds (supports timestamp operations) <code>sequence.user_metadata.&lt;key&gt;</code> Custom user-defined metadata attached to the sequence"},{"location":"daemon/query/#topic-filter","title":"Topic Filter","text":"<p>The topic filter narrows the search to specific data streams within matching sequences:</p> Field Description <code>topic.name</code> The topic path within the sequence (supports text operations) <code>topic.creation</code> The topic creation timestamp in nanoseconds (supports timestamp operations) <code>topic.ontology_tag</code> The data type identifier (e.g., <code>Lidar</code>, <code>Camera</code>, <code>IMU</code>) <code>topic.serialization_format</code> The binary layout format (<code>Default</code>, <code>Ragged</code>, or <code>Image</code>) <code>topic.user_metadata.&lt;key&gt;</code> Custom user-defined metadata attached to the topic"},{"location":"daemon/query/#ontology-filter","title":"Ontology Filter","text":"<p>The ontology filter queries the actual sensor data values. Fields are specified using dot notation: <code>&lt;ontology_tag&gt;.&lt;field_path&gt;</code>.</p> <p>For example, to query IMU acceleration data: <code>imu.acceleration.x</code>, where <code>imu</code> is the ontology tag and <code>acceleration.x</code> is the field path within that data model.</p>"},{"location":"daemon/query/#timestamp-query-support","title":"Timestamp query support","text":"<p>If <code>include_timestamp_range</code> is set to <code>true</code> the response will also return timestamps ranges for each query.</p>"},{"location":"daemon/query/#supported-operators","title":"Supported Operators","text":"<p>The query engine supports a rich set of comparison operators. Each operator is prefixed with <code>$</code> in the JSON syntax:</p> Operator Description <code>$eq</code> Equal to (supports all types) <code>$neq</code> Not equal to (supports all types) <code>$lt</code> Less than (numeric and timestamp only) <code>$gt</code> Greater than (numeric and timestamp only) <code>$leq</code> Less than or equal to (numeric and timestamp only) <code>$geq</code> Greater than or equal to (numeric and timestamp only) <code>$between</code> Within a range <code>[min, max]</code> inclusive (numeric and timestamp only) <code>$in</code> Value is in a set of options (supports integers and text) <code>$match</code> Matches a pattern (text only, supports SQL LIKE patterns with <code>%</code> wildcards) <code>$ex</code> Field exists <code>$nex</code> Field does not exist"},{"location":"daemon/query/#query-syntax","title":"Query Syntax","text":"<p>Queries are submitted as JSON objects. Each field is mapped to an operator and value. Multiple conditions are combined with implicit AND logic.</p> <pre><code>{\n  \"sequence\": {\n    \"name\": { \"$match\": \"test_run_%\" },\n    \"user_metadata\": {\n      \"driver\": { \"$eq\": \"Alice\" }\n    }\n  },\n  \"topic\": {\n    \"ontology_tag\": { \"$eq\": \"imu\" }\n  },\n  \"ontology\": {\n    \"imu.acceleration.x\": { \"$gt\": 5.0 },\n    \"imu.acceleration.y\": { \"$between\": [-2.0, 2.0] },\n\n    \"include_timestamp_range\": true, // (1)!\n  }\n}\n</code></pre> <ol> <li>This filed is optional, if set to <code>true</code> the query returns the timestamp ranges</li> </ol> <p>This query searches for:</p> <ul> <li>Sequences with names matching <code>test_run_%</code> pattern</li> <li>Where the user metadata field <code>driver</code> equals <code>\"Alice\"</code></li> <li>Containing topics with ontology tag <code>imu</code></li> <li>Where the IMU's x-axis acceleration exceeds 5.0</li> <li>And the y-axis acceleration is between -2.0 and 2.0</li> </ul>"},{"location":"daemon/query/#response-structure","title":"Response Structure","text":"<p>The query response is hierarchically grouped by sequence. For each matching sequence, it provides the list of topics that satisfied the filter criteria, along with optional timestamp ranges indicating when the ontology conditions were met.</p> Query response example<pre><code>{\n  \"items\": [\n    {\n      \"sequence\": \"test_run_01\",\n      \"topics\": [\n        { \n          \"locator\": \"test_run_01/sensors/imu\",\n          \"timestamp_range\": [1000000000, 2000000000]\n        },\n        {\n          \"locator\": \"test_run_01/sensors/gps\",\n          \"timestamp_range\": [1000000000, 2000000000]\n        }\n      ]\n    },\n    {\n      \"sequence\": \"test_run_02\",\n      \"topics\": [\n        {\n          \"locator\": \"test_run_02/camera/front\",\n          \"timestamp_range\": [1500000000, 2500000000]\n        },\n        {\n          \"locator\": \"test_run_02/lidar/point_cloud\",\n          \"timestamp_range\": [1500000000, 2500000000]\n        }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"daemon/query/#timestamps","title":"Timestamps","text":"<p>It returns the time window <code>[min, max]</code> where the filter conditions were met for that topic, with <code>min</code> being the timestamp of the first matching event and max being the timestamp of the last matching event. This allows you to retrieve only the relevant data slices using the retrieval protocol.</p> <p>Note</p> <p>The <code>timestamp_range</code> field is included only when ontology filters are applied and <code>include_timestamp_range</code> is set to <code>true</code> inside the <code>ontology</code> filter. </p>"},{"location":"daemon/query/#performance-characteristics","title":"Performance Characteristics","text":"<p>The query engine is optimized for high performance by minimizing unnecessary data retrieval and I/O operations.  During execution, the engine uses index-based pruning to evaluate precomputed min/max statistics and skip indices, allowing it to bypass irrelevant data chunks without reading the underlying files. </p> <p>Performance is further improved by executing metadata cache queries, such as sequence and topic filters, directly within the database, which ensures sub-second response times even across thousands of sequences.</p> <p>The system employs lazy evaluation to keep network payloads lightweight; instead of returning raw data immediately, queries return locators and timestamp ranges. This architecture allows client applications to fetch only the required data slices via the retrieval protocol as needed.</p>"},{"location":"daemon/retrieval/","title":"Retrieval","text":"<p>Measurement data in Mosaico is accessed through the Flight <code>DoGet</code> endpoint for high-performance read operations. Unlike simple file downloads, this channel provides an interface for requesting precise data slices, dynamically assembled and streamed back as optimized Arrow batches.</p>"},{"location":"daemon/retrieval/#the-retrieval-protocol","title":"The Retrieval Protocol","text":"<p>Accessing data requires specifying the Locator, which defines the topic path, and an optional time range in nanoseconds.</p> <p>The resolution process follows a coordinated sequence. Upon receiving a request, the server performs an index lookup in the metadata cache to identify physical data chunks intersecting the requested time window. This is followed by pruning, discarding chunks outside the query bounds to avoid redundant I/O. Once relevant segments are identified, the server streams the data by opening underlying files and delivering it in a high-throughput pipeline.</p> <p>In the protocol, the <code>get_flight_info</code> call returns a list of resources, each containing an endpoint (the name of the topic or sequence, such as <code>my_sequence</code> or <code>my_sequence/my/topic</code>) and a ticket, an opaque binary blob used by the server in the <code>do_get</code> call to extract and stream the data. </p> <p>Calling <code>get_flight_info</code> on a sequence returns all topics associated with that sequence, whereas calling it on a specific topic returns only the endpoint and ticket for that topic.</p> Retrieval protocol in pseudo-code<pre><code>locator = \"my_sequence/topic/1\"\ntime_range = (start_ns, end_ns)  # optional\n\nresources = get_flight_info(locator, time_range)\nfor res in resources:\n    print(res.endpoint)\n    data_stream = do_get(res.ticket)\n</code></pre>"},{"location":"daemon/retrieval/#metadata-context-headers","title":"Metadata Context Headers","text":"<p>To provide full context, the data stream is prefixed with a Schema message containing embedded custom metadata. Mosaico injects context into this header for client reconstruction of the environment.</p> <p>This includes user metadata, preserving original project context like experimental tags or vehicle IDs, and the ontology tag, informing the client of sensor data types (e.g., <code>Lidar</code>, <code>Camera</code>) for type-safe deserialization.</p> <p>The serialization format guides interpretation of the underlying serialization protocol used. Now the supported formats include:</p> <ul> <li><code>Default</code>: The standard Arrow columnar layout.</li> <li><code>Ragged</code>: Optimized for variable-length lists.</li> <li><code>Image</code>: An optimized array format for high-resolution visual data.</li> </ul>"},{"location":"development/release_cycle/","title":"Release Cycle","text":"<p>This document describes briefly how the release process is handled for Mosaico project.</p> <p>We use semantic versioning <code>v&lt;MAJOR&gt;.&lt;MINOR&gt;.&lt;PATCH&gt;</code> to label every new official release.</p>"},{"location":"development/release_cycle/#development-process","title":"Development process","text":"<p>The basic idea is to use more than one develop branch to consent the progress of various versions simultaneously.</p> <p>Below, we introduce the terminology of branches and tags involved in the process:</p> <ul> <li><code>main</code>: this is the only stable branch, where every commit is an official release. Critical patches to the latest version are merged directly on this branch </li> <li><code>release/x.y.0</code>: this is the catch-all branch for the version <code>x.y.0</code>. Once ready it is merged back into <code>main</code> and deleted.</li> <li><code>issue/&lt;num&gt;/x.y.z</code>: this kind of branch is associated to the corresponding Github issue <code>#&lt;num&gt;</code>. It can contain the development of a new feature or a bug-fix. It is a child of the corresponding <code>release/x.y.z</code> branch and it's merged back into it when completed </li> <li><code>hotfix/x.y.&lt;z+1&gt;</code>: this branch is intended to contain critical fixes. It is derived directly from <code>main</code> and merged back into it to produce the new official version <code>x.y.&lt;z+1&gt;</code>.</li> <li><code>chore/x.y.&lt;z+1&gt;</code>: this is a particular branch used for maintainance tasks, like updating workflows or documentation.</li> <li><code>vx.y.z</code> this tag is created when a new stable version is ready.</li> </ul> <p>Let's have a look to an example</p> <p></p>"},{"location":"development/release_cycle/#maintenance-process","title":"Maintenance process","text":"<p>Maintenance of older major versions (LTS) follows a slightly different process.</p> <p>We add to the terminology the following branch:</p> <ul> <li><code>lts/x</code> this branch is created from the last official release of version x present in <code>main</code> and lives until the end of support. Only fixes are permitted using <code>issue/&lt;num&gt;</code> branches. Once a new version is ready, it is tagged incrementing only the patch version (<code>vx.y.&lt;z+1&gt;</code>).</li> </ul>"}]}